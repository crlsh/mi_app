This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-20 18:19:17

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
app
  plugins
    flujo_e.py
    flujo_a.py
    __init__.py
    flujo_d.py
    flujo_c.py
    flujo_g.py
    flujo_f.py
    flujo_b.py
    flujo_h.py
  flujo_loader.py
  .gitignore
  templates
    flujo.html
    resultados.html
    index.html
    excel_viewer.html
  main.py
requirements.txt
repomix-output.md
docs
  Flujo A - Doc tecnico.md
  commentarios del proy.md
  Estructura del proyecto.md
README.md
.gitignore
```

# Repository Files


## app/plugins/flujo_e.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_a.py

- Characters: 1853
- Tokens: 0

```python
import pandas as pd
import os

def ejecutar(respuesta):
    """
    Ejecuta el Flujo A (Ajuste de medida)
    
    Args:
        respuesta (str): "SI" o "NO" según la respuesta del usuario
        
    Returns:
        DataFrame: DataFrame con los materiales seleccionados o vacío
    """
    # Si la respuesta es NO, retornar DataFrame vacío
    if respuesta == "NO":
        return pd.DataFrame()
        
    # Si la respuesta es SI, procesar el archivo Excel
    try:
        # Ruta del archivo Excel
        file_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                               "data", "ajuste_de_medida.xlsx")
        
        # Verificar si el archivo existe
        if not os.path.exists(file_path):
            print(f"El archivo {file_path} no existe")
            return pd.DataFrame()
            
        # Cargar el archivo Excel
        df = pd.read_excel(file_path)
        
        # Limpiar los datos
        df.columns = df.columns.str.strip()
        
        # Aquí iría la lógica específica del Flujo A
        # Por ahora, simplemente retornamos todo el DataFrame
        
        # Renombrar columnas según requerimiento
        df_renombrado = df.rename(
            columns={
                "1. Cód.SAP": "Cód.SAP",
                "2. MATERIAL": "MATERIAL",
                "3. Descripción": "Descripción",
                "5.CONDICIÓN": "CONDICIÓN"
            }
        )
        
        # Asegurarse de que queden las columnas requeridas
        columnas = ["Cód.SAP", "MATERIAL", "Descripción", "4.CANTIDAD", "CONDICIÓN"]
        columnas_presentes = [col for col in columnas if col in df_renombrado.columns]
        
        return df_renombrado[columnas_presentes]
        
    except Exception as e:
        print(f"Error en Flujo A: {e}")
        return pd.DataFrame()
```

## app/plugins/__init__.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_d.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_c.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_g.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_f.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_b.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_h.py

- Characters: 0
- Tokens: 0

```python

```

## app/flujo_loader.py

- Characters: 0
- Tokens: 0

```python

```

## app/.gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## app/templates/flujo.html

- Characters: 1116
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Flujo {{ flujo }}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
        form { display: inline-block; text-align: left; }
        label, select { display: block; margin-bottom: 10px; }
        .boton { padding: 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        .tabla { margin-top: 20px; width: 80%; border-collapse: collapse; }
        th, td { border: 1px solid black; padding: 8px; text-align: left; }
    </style>
</head>
<body>

<h1>Flujo {{ flujo }}</h1>

<form method="POST">
    <label>Diámetro:</label>
    <select name="diametro">
        <option value="TODOS">Todos</option>
        <option value="10">10 mm</option>
        <option value="20">20 mm</option>
    </select>

    <label>Tipo:</label>
    <select name="tipo">
        <option value="TODOS">Todos</option>
        <option value="Acero">Acero</option>
        <option value="Aluminio">Aluminio</option>
    </select>

    <button type="submit" class="boton">Aplicar Filtros</button>
</form>

</body>
</html>
```

## app/templates/resultados.html

- Characters: 1411
- Tokens: 0

```html
<!-- templates/resultados.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Resultados Finales</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        button { 
            padding: 10px; 
            background-color: #4CAF50; 
            color: white; 
            border: none; 
            cursor: pointer; 
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .flujo-section {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Listado final de materiales de todos los flujos ejecutados</h1>
    
    {% for flujo, df in materiales %}
        <div class="flujo-section">
            <h2>{{ flujo }}</h2>
            {% if df.empty %}
                <p>No hay datos disponibles para este flujo.</p>
            {% else %}
                {{ df.to_html(index=False) | safe }}
            {% endif %}
        </div>
    {% endfor %}
    
    <a href="/"><button>Volver al inicio</button></a>
</body>
</html>
```

## app/templates/index.html

- Characters: 1878
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Visualizador de Excel</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 0;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .reload-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            border: none;
            cursor: pointer;
        }
        .reload-btn:hover {
            background-color: #45a049;
        }
        .start-flujo-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #007bff;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }
        .start-flujo-btn:hover {
            background-color: #0056b3;
        }
        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <h1>Visualizador de Excel</h1>
    
    <form action="/" method="get">
        <button type="submit" class="reload-btn">Recargar Datos</button>
    </form>
    
    <div class="container" id="main-content">
        <!-- El contenido se cargará aquí dinámicamente -->
        {% include 'excel_viewer.html' %}
    </div>
    
    {% if tablas %}
        <a href="{{ url_for('flujo', nombre_flujo='A') }}" class="start-flujo-btn">Iniciar Flujo de Selección</a>
    {% endif %}
</body>
</html>
```

## app/templates/excel_viewer.html

- Characters: 1302
- Tokens: 0

```html
<!-- templates/components/excel_viewer.html -->
{% if tablas %}
    {% for nombre, tabla_html in tablas %}
        <div class="tabla-contenedor">
            <h2>{{ nombre }}</h2>
            {{ tabla_html | safe }}
        </div>
    {% endfor %}
{% else %}
    <div class="mensaje-vacio">
        <p>No se encontraron archivos Excel en la carpeta "data".</p>
        <p>Por favor, coloque sus archivos Excel en la carpeta "data" y recargue la página.</p>
    </div>
{% endif %}

<style>
    .tabla-contenedor {
        margin-bottom: 40px;
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h2 {
        color: #4CAF50;
        margin-top: 0;
    }
    .table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
    }
    .table th {
        background-color: #4CAF50;
        color: white;
        padding: 10px;
        text-align: left;
    }
    .table td {
        border: 1px solid #ddd;
        padding: 8px;
    }
    .table-striped tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    .mensaje-vacio {
        text-align: center;
        padding: 20px;
        background-color: #f8f9fa;
        border-radius: 5px;
        color: #6c757d;
    }
</style>
```

## requirements.txt

- Characters: 55
- Tokens: 0

```text
flask==2.3.3
openpyxl==3.1.2
pandas
xlrd==2.0.1
repomix
```

## repomix-output.md

- Characters: 224833
- Tokens: 0

``````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-20 14:53:00

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
app
  plugins
    flujo_e.py
    flujo_a.py
    __init__.py
    flujo_d.py
    flujo_c.py
    flujo_g.py
    flujo_f.py
    flujo_b.py
    flujo_h.py
  flujo_loader.py
  .gitignore
  templates
    flujo.html
    resultados.html
    index.html
  main.py
requirements.txt
repomix-output.md
docs
  Flujo A - Doc tecnico.md
  commentarios del proy.md
  Estructura del proyecto.md
README.md
.gitignore
```

# Repository Files


## app/plugins/flujo_e.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_a.py

- Characters: 1853
- Tokens: 0

```python
import pandas as pd
import os

def ejecutar(respuesta):
    """
    Ejecuta el Flujo A (Ajuste de medida)
    
    Args:
        respuesta (str): "SI" o "NO" según la respuesta del usuario
        
    Returns:
        DataFrame: DataFrame con los materiales seleccionados o vacío
    """
    # Si la respuesta es NO, retornar DataFrame vacío
    if respuesta == "NO":
        return pd.DataFrame()
        
    # Si la respuesta es SI, procesar el archivo Excel
    try:
        # Ruta del archivo Excel
        file_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                               "data", "ajuste_de_medida.xlsx")
        
        # Verificar si el archivo existe
        if not os.path.exists(file_path):
            print(f"El archivo {file_path} no existe")
            return pd.DataFrame()
            
        # Cargar el archivo Excel
        df = pd.read_excel(file_path)
        
        # Limpiar los datos
        df.columns = df.columns.str.strip()
        
        # Aquí iría la lógica específica del Flujo A
        # Por ahora, simplemente retornamos todo el DataFrame
        
        # Renombrar columnas según requerimiento
        df_renombrado = df.rename(
            columns={
                "1. Cód.SAP": "Cód.SAP",
                "2. MATERIAL": "MATERIAL",
                "3. Descripción": "Descripción",
                "5.CONDICIÓN": "CONDICIÓN"
            }
        )
        
        # Asegurarse de que queden las columnas requeridas
        columnas = ["Cód.SAP", "MATERIAL", "Descripción", "4.CANTIDAD", "CONDICIÓN"]
        columnas_presentes = [col for col in columnas if col in df_renombrado.columns]
        
        return df_renombrado[columnas_presentes]
        
    except Exception as e:
        print(f"Error en Flujo A: {e}")
        return pd.DataFrame()
```

## app/plugins/__init__.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_d.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_c.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_g.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_f.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_b.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_h.py

- Characters: 0
- Tokens: 0

```python

```

## app/flujo_loader.py

- Characters: 0
- Tokens: 0

```python

```

## app/.gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## app/templates/flujo.html

- Characters: 1116
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Flujo {{ flujo }}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
        form { display: inline-block; text-align: left; }
        label, select { display: block; margin-bottom: 10px; }
        .boton { padding: 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        .tabla { margin-top: 20px; width: 80%; border-collapse: collapse; }
        th, td { border: 1px solid black; padding: 8px; text-align: left; }
    </style>
</head>
<body>

<h1>Flujo {{ flujo }}</h1>

<form method="POST">
    <label>Diámetro:</label>
    <select name="diametro">
        <option value="TODOS">Todos</option>
        <option value="10">10 mm</option>
        <option value="20">20 mm</option>
    </select>

    <label>Tipo:</label>
    <select name="tipo">
        <option value="TODOS">Todos</option>
        <option value="Acero">Acero</option>
        <option value="Aluminio">Aluminio</option>
    </select>

    <button type="submit" class="boton">Aplicar Filtros</button>
</form>

</body>
</html>
```

## app/templates/resultados.html

- Characters: 1411
- Tokens: 0

```html
<!-- templates/resultados.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Resultados Finales</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        button { 
            padding: 10px; 
            background-color: #4CAF50; 
            color: white; 
            border: none; 
            cursor: pointer; 
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .flujo-section {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Listado final de materiales de todos los flujos ejecutados</h1>
    
    {% for flujo, df in materiales %}
        <div class="flujo-section">
            <h2>{{ flujo }}</h2>
            {% if df.empty %}
                <p>No hay datos disponibles para este flujo.</p>
            {% else %}
                {{ df.to_html(index=False) | safe }}
            {% endif %}
        </div>
    {% endfor %}
    
    <a href="/"><button>Volver al inicio</button></a>
</body>
</html>
```

## app/templates/index.html

- Characters: 2996
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Visualizador de Excel</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 0;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .tabla-contenedor {
            margin-bottom: 40px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #4CAF50;
            margin-top: 0;
        }
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        .table th {
            background-color: #4CAF50;
            color: white;
            padding: 10px;
            text-align: left;
        }
        .table td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        .table-striped tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .mensaje-vacio {
            text-align: center;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 5px;
            color: #6c757d;
        }
        .reload-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            border: none;
            cursor: pointer;
        }
        .reload-btn:hover {
            background-color: #45a049;
        }
        .start-flujo-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #007bff;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }
        .start-flujo-btn:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <h1>Visualizador de Excel</h1>
    
    <form action="/" method="get">
        <button type="submit" class="reload-btn">Recargar Datos</button>
    </form>
    
    {% if tablas %}
        {% for nombre, tabla_html in tablas %}
            <div class="tabla-contenedor">
                <h2>{{ nombre }}</h2>
                {{ tabla_html | safe }}
            </div>
        {% endfor %}
        <a href="{{ url_for('flujo', nombre_flujo='A') }}" class="start-flujo-btn">Iniciar Flujo de Selección</a>
    {% else %}
        <div class="mensaje-vacio">
            <p>No se encontraron archivos Excel en la carpeta "data".</p>
            <p>Por favor, coloque sus archivos Excel en la carpeta "data" y recargue la página.</p>
        </div>
    {% endif %}
</body>
</html>
```

## requirements.txt

- Characters: 55
- Tokens: 0

```text
flask==2.3.3
openpyxl==3.1.2
pandas
xlrd==2.0.1
repomix
```

## repomix-output.md

- Characters: 150044
- Tokens: 0

`````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-19 17:54:36

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
app
  plugins
    flujo_e.py
    flujo_a.py
    __init__.py
    flujo_d.py
    flujo_c.py
    flujo_g.py
    flujo_f.py
    flujo_b.py
    flujo_h.py
  flujo_loader.py
  .gitignore
  templates
    flujo.html
    resultados.html
    index.html
  main.py
requirements.txt
repomix-output.md
docs
  Flujo A - Doc tecnico.md
  commentarios del proy.md
  Estructura del proyecto.md
README.md
.gitignore
```

# Repository Files


## app/plugins/flujo_e.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_a.py

- Characters: 1853
- Tokens: 0

```python
import pandas as pd
import os

def ejecutar(respuesta):
    """
    Ejecuta el Flujo A (Ajuste de medida)
    
    Args:
        respuesta (str): "SI" o "NO" según la respuesta del usuario
        
    Returns:
        DataFrame: DataFrame con los materiales seleccionados o vacío
    """
    # Si la respuesta es NO, retornar DataFrame vacío
    if respuesta == "NO":
        return pd.DataFrame()
        
    # Si la respuesta es SI, procesar el archivo Excel
    try:
        # Ruta del archivo Excel
        file_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                               "data", "ajuste_de_medida.xlsx")
        
        # Verificar si el archivo existe
        if not os.path.exists(file_path):
            print(f"El archivo {file_path} no existe")
            return pd.DataFrame()
            
        # Cargar el archivo Excel
        df = pd.read_excel(file_path)
        
        # Limpiar los datos
        df.columns = df.columns.str.strip()
        
        # Aquí iría la lógica específica del Flujo A
        # Por ahora, simplemente retornamos todo el DataFrame
        
        # Renombrar columnas según requerimiento
        df_renombrado = df.rename(
            columns={
                "1. Cód.SAP": "Cód.SAP",
                "2. MATERIAL": "MATERIAL",
                "3. Descripción": "Descripción",
                "5.CONDICIÓN": "CONDICIÓN"
            }
        )
        
        # Asegurarse de que queden las columnas requeridas
        columnas = ["Cód.SAP", "MATERIAL", "Descripción", "4.CANTIDAD", "CONDICIÓN"]
        columnas_presentes = [col for col in columnas if col in df_renombrado.columns]
        
        return df_renombrado[columnas_presentes]
        
    except Exception as e:
        print(f"Error en Flujo A: {e}")
        return pd.DataFrame()
```

## app/plugins/__init__.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_d.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_c.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_g.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_f.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_b.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_h.py

- Characters: 0
- Tokens: 0

```python

```

## app/flujo_loader.py

- Characters: 0
- Tokens: 0

```python

```

## app/.gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## app/templates/flujo.html

- Characters: 1116
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Flujo {{ flujo }}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
        form { display: inline-block; text-align: left; }
        label, select { display: block; margin-bottom: 10px; }
        .boton { padding: 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        .tabla { margin-top: 20px; width: 80%; border-collapse: collapse; }
        th, td { border: 1px solid black; padding: 8px; text-align: left; }
    </style>
</head>
<body>

<h1>Flujo {{ flujo }}</h1>

<form method="POST">
    <label>Diámetro:</label>
    <select name="diametro">
        <option value="TODOS">Todos</option>
        <option value="10">10 mm</option>
        <option value="20">20 mm</option>
    </select>

    <label>Tipo:</label>
    <select name="tipo">
        <option value="TODOS">Todos</option>
        <option value="Acero">Acero</option>
        <option value="Aluminio">Aluminio</option>
    </select>

    <button type="submit" class="boton">Aplicar Filtros</button>
</form>

</body>
</html>
```

## app/templates/resultados.html

- Characters: 1411
- Tokens: 0

```html
<!-- templates/resultados.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Resultados Finales</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        button { 
            padding: 10px; 
            background-color: #4CAF50; 
            color: white; 
            border: none; 
            cursor: pointer; 
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .flujo-section {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Listado final de materiales de todos los flujos ejecutados</h1>
    
    {% for flujo, df in materiales %}
        <div class="flujo-section">
            <h2>{{ flujo }}</h2>
            {% if df.empty %}
                <p>No hay datos disponibles para este flujo.</p>
            {% else %}
                {{ df.to_html(index=False) | safe }}
            {% endif %}
        </div>
    {% endfor %}
    
    <a href="/"><button>Volver al inicio</button></a>
</body>
</html>
```

## app/templates/index.html

- Characters: 2996
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Visualizador de Excel</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 0;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .tabla-contenedor {
            margin-bottom: 40px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #4CAF50;
            margin-top: 0;
        }
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        .table th {
            background-color: #4CAF50;
            color: white;
            padding: 10px;
            text-align: left;
        }
        .table td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        .table-striped tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .mensaje-vacio {
            text-align: center;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 5px;
            color: #6c757d;
        }
        .reload-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            border: none;
            cursor: pointer;
        }
        .reload-btn:hover {
            background-color: #45a049;
        }
        .start-flujo-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #007bff;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }
        .start-flujo-btn:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <h1>Visualizador de Excel</h1>
    
    <form action="/" method="get">
        <button type="submit" class="reload-btn">Recargar Datos</button>
    </form>
    
    {% if tablas %}
        {% for nombre, tabla_html in tablas %}
            <div class="tabla-contenedor">
                <h2>{{ nombre }}</h2>
                {{ tabla_html | safe }}
            </div>
        {% endfor %}
        <a href="{{ url_for('flujo', nombre_flujo='A') }}" class="start-flujo-btn">Iniciar Flujo de Selección</a>
    {% else %}
        <div class="mensaje-vacio">
            <p>No se encontraron archivos Excel en la carpeta "data".</p>
            <p>Por favor, coloque sus archivos Excel en la carpeta "data" y recargue la página.</p>
        </div>
    {% endif %}
</body>
</html>
```

## requirements.txt

- Characters: 55
- Tokens: 0

```text
flask==2.3.3
openpyxl==3.1.2
pandas
xlrd==2.0.1
repomix
```

## repomix-output.md

- Characters: 75258
- Tokens: 0

````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-19 16:55:51

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
app
  plugins
    flujo_e.py
    flujo_a.py
    __init__.py
    flujo_d.py
    flujo_c.py
    flujo_g.py
    flujo_f.py
    flujo_b.py
    flujo_h.py
  flujo_loader.py
  .gitignore
  templates
    flujo.html
    resultados.html
    index.html
  main.py
requirements.txt
docs
  Flujo A - Doc tecnico.md
  commentarios del proy.md
  Estructura del proyecto.md
README.md
.gitignore
```

# Repository Files


## app/plugins/flujo_e.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_a.py

- Characters: 1853
- Tokens: 0

```python
import pandas as pd
import os

def ejecutar(respuesta):
    """
    Ejecuta el Flujo A (Ajuste de medida)
    
    Args:
        respuesta (str): "SI" o "NO" según la respuesta del usuario
        
    Returns:
        DataFrame: DataFrame con los materiales seleccionados o vacío
    """
    # Si la respuesta es NO, retornar DataFrame vacío
    if respuesta == "NO":
        return pd.DataFrame()
        
    # Si la respuesta es SI, procesar el archivo Excel
    try:
        # Ruta del archivo Excel
        file_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                               "data", "ajuste_de_medida.xlsx")
        
        # Verificar si el archivo existe
        if not os.path.exists(file_path):
            print(f"El archivo {file_path} no existe")
            return pd.DataFrame()
            
        # Cargar el archivo Excel
        df = pd.read_excel(file_path)
        
        # Limpiar los datos
        df.columns = df.columns.str.strip()
        
        # Aquí iría la lógica específica del Flujo A
        # Por ahora, simplemente retornamos todo el DataFrame
        
        # Renombrar columnas según requerimiento
        df_renombrado = df.rename(
            columns={
                "1. Cód.SAP": "Cód.SAP",
                "2. MATERIAL": "MATERIAL",
                "3. Descripción": "Descripción",
                "5.CONDICIÓN": "CONDICIÓN"
            }
        )
        
        # Asegurarse de que queden las columnas requeridas
        columnas = ["Cód.SAP", "MATERIAL", "Descripción", "4.CANTIDAD", "CONDICIÓN"]
        columnas_presentes = [col for col in columnas if col in df_renombrado.columns]
        
        return df_renombrado[columnas_presentes]
        
    except Exception as e:
        print(f"Error en Flujo A: {e}")
        return pd.DataFrame()
```

## app/plugins/__init__.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_d.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_c.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_g.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_f.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_b.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_h.py

- Characters: 0
- Tokens: 0

```python

```

## app/flujo_loader.py

- Characters: 0
- Tokens: 0

```python

```

## app/.gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## app/templates/flujo.html

- Characters: 1682
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Flujo A - Ajuste de Medida</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
        form { display: inline-block; text-align: left; }
        label, select { display: block; margin-bottom: 10px; }
        .boton { padding: 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        .tabla { margin-top: 20px; width: 80%; border-collapse: collapse; }
        th, td { border: 1px solid black; padding: 8px; text-align: left; }
    </style>
</head>
<body>

<h1>Flujo A - Ajuste de Medida</h1>

<form method="POST">
    <label>Diámetro:</label>
    <select name="diametro">
        <option value="TODOS">Todos</option>
        <option value="10">10 mm</option>
        <option value="20">20 mm</option>
    </select>

    <label>Tipo:</label>
    <select name="tipo">
        <option value="TODOS">Todos</option>
        <option value="Acero">Acero</option>
        <option value="Aluminio">Aluminio</option>
    </select>

    <button type="submit" class="boton">Aplicar Filtros</button>
</form>

{% if materiales is not none %}
    <h2>Materiales Filtrados</h2>
    <table class="tabla">
        <tr>
            <th>Diámetro</th>
            <th>Tipo</th>
            <th>Grado de Acero</th>
        </tr>
        {% for index, row in materiales.iterrows() %}
        <tr>
            <td>{{ row["DIÁMETRO"] }}</td>
            <td>{{ row["TIPO"] }}</td>
            <td>{{ row["GRADO DE ACERO"] }}</td>
        </tr>
        {% endfor %}
    </table>
    <a href="/flujo_h"><button class="boton">Continuar a Flujo H</button></a>
{% endif %}

</body>
</html>
```

## app/templates/resultados.html

- Characters: 1411
- Tokens: 0

```html
<!-- templates/resultados.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Resultados Finales</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        button { 
            padding: 10px; 
            background-color: #4CAF50; 
            color: white; 
            border: none; 
            cursor: pointer; 
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .flujo-section {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Listado final de materiales de todos los flujos ejecutados</h1>
    
    {% for flujo, df in materiales %}
        <div class="flujo-section">
            <h2>{{ flujo }}</h2>
            {% if df.empty %}
                <p>No hay datos disponibles para este flujo.</p>
            {% else %}
                {{ df.to_html(index=False) | safe }}
            {% endif %}
        </div>
    {% endfor %}
    
    <a href="/"><button>Volver al inicio</button></a>
</body>
</html>
```

## app/templates/index.html

- Characters: 2996
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Visualizador de Excel</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 0;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .tabla-contenedor {
            margin-bottom: 40px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #4CAF50;
            margin-top: 0;
        }
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        .table th {
            background-color: #4CAF50;
            color: white;
            padding: 10px;
            text-align: left;
        }
        .table td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        .table-striped tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .mensaje-vacio {
            text-align: center;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 5px;
            color: #6c757d;
        }
        .reload-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            border: none;
            cursor: pointer;
        }
        .reload-btn:hover {
            background-color: #45a049;
        }
        .start-flujo-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #007bff;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }
        .start-flujo-btn:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <h1>Visualizador de Excel</h1>
    
    <form action="/" method="get">
        <button type="submit" class="reload-btn">Recargar Datos</button>
    </form>
    
    {% if tablas %}
        {% for nombre, tabla_html in tablas %}
            <div class="tabla-contenedor">
                <h2>{{ nombre }}</h2>
                {{ tabla_html | safe }}
            </div>
        {% endfor %}
        <a href="{{ url_for('flujo', nombre_flujo='A') }}" class="start-flujo-btn">Iniciar Flujo de Selección</a>
    {% else %}
        <div class="mensaje-vacio">
            <p>No se encontraron archivos Excel en la carpeta "data".</p>
            <p>Por favor, coloque sus archivos Excel en la carpeta "data" y recargue la página.</p>
        </div>
    {% endif %}
</body>
</html>
```

## requirements.txt

- Characters: 55
- Tokens: 0

```text
flask==2.3.3
openpyxl==3.1.2
pandas
xlrd==2.0.1
repomix
```

## docs/Flujo A - Doc tecnico.md

- Characters: 2871
- Tokens: 0

```markdown
📌 Especificación Técnica para Desarrollo – FLUJO A (Ajuste de Medida)
1️⃣ Descripción General
FLUJO A permite al usuario seleccionar materiales basados en criterios específicos de ajuste de medida. Si el usuario acepta el ajuste, el flujo filtra los materiales y salta directamente a FLUJO H. Si el usuario rechaza, salta a FLUJO B sin procesar datos.

2️⃣ Datos de Entrada
La información proviene de una tabla estructurada (ajuste_de_medida.xlsx), con las siguientes columnas clave:

Columna	Tipo	Descripción
DIÁMETRO	string	Diámetro del material
TIPO	string	Tipo de material
GRADO DE ACERO	string	Grado de acero
GRADO DE ACERO CUPLA	string	Grado de acero de la cupla
TIPO DE CUPLA	string	Tipo de cupla
4.CANTIDAD	float	Cantidad del material (opcional)
3️⃣ Flujo de Ejecución
Pregunta al usuario:

Si responde "NO" → Salta directamente a FLUJO B.
Si responde "SÍ" → Carga la tabla y aplica filtros.
Carga y Filtrado de Datos:

Carga la tabla ajuste_de_medida.xlsx y limpia valores.
El usuario selecciona valores en los siguientes filtros:
DIÁMETRO
TIPO
GRADO DE ACERO
GRADO DE ACERO CUPLA
TIPO DE CUPLA
Si el usuario no selecciona un valor, se usa "TODOS" como fallback.
Construcción de final_condition (máscara booleana de filtrado):

Inicializa final_condition con False para excluir todos los registros.
Para cada DIÁMETRO seleccionado, evalúa si los materiales cumplen con los criterios del usuario.
Incluye "TODOS" en cada filtro para garantizar que los valores no seleccionados no eliminen registros útiles.
Se combinan las condiciones (| lógico) para crear el filtro final.
Aplicación del Filtro:

python
Copy
Edit
final_df = df[final_condition]
Solo quedan los materiales que cumplen con los criterios del usuario.
Almacena los materiales filtrados en materiales_finales:

python
Copy
Edit
materiales_finales.append(("FLUJO A", final_df_renombrado))
Salto a FLUJO H (el flujo no sigue la secuencia normal):

Si el usuario ejecuta FLUJO A, no sigue a FLUJO B, sino directamente a FLUJO H.
4️⃣ Consideraciones Técnicas
✔ No modifica la estructura de la tabla, solo aplica filtros.
✔ Debe permitir múltiples selecciones en cada filtro.
✔ Evita pérdida de datos con "TODOS" en cada condición.
✔ Encapsular final_condition como lógica reutilizable para otros flujos.
✔ Optimizar el acceso a archivos si se requiere ejecución frecuente.

📌 Resumen Final
FLUJO A solo se ejecuta si el usuario dice "SÍ".
Carga una tabla de materiales y filtra datos según selección del usuario.
Almacena los materiales seleccionados y salta directamente a FLUJO H.
Si el usuario dice "NO", salta a FLUJO B sin procesar nada.
final_condition es el mecanismo que define qué materiales quedan en la selección final.
🚀 Resultado esperado: Un módulo optimizado que procesa materiales en base a filtros dinámicos y garantiza la continuidad del flujo sin interrumpir la secuencia de ejecución.
```

## docs/commentarios del proy.md

- Characters: 52736
- Tokens: 0

```markdown
engo varios códigos por separado que representan diferentes flujos para la selección de materiales en la intervención de un pozo petrolero: FLUJO A, FLUJO B, FLUJO C, FLUJO D, FLUJO E, FLUJO F, FLUJO G y FLUJO H. Cada uno de ellos inicia con una pregunta que, si el usuario responde “NO”, salta inmediatamente al siguiente flujo; y si el usuario responde “SÍ”, entonces ejecuta su lógica, imprime una lista de materiales y luego avanza al siguiente flujo.

Los flujos se llaman y se encadenan de la siguiente forma:

FLUJO A (Ajuste de medida)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO H.
Si el usuario responde NO , salta a FLUJO B.
FLUJO B (Tubo de saca)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO C.
Si el usuario responde NO , salta a FLUJO C.
FLUJO C (tubería de Baja)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO D.
Si el usuario responde NO , salta a FLUJO D.
FLUJO D (Profundiza)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO E.
Si el usuario responde NO , salta a FLUJO E.
FLUJO E (Baja varillas)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO G.
Luego de terminar FLUJO G , debe continuar a FLUJO H .
Si el usuario responde NO , salta a FLUJO F , y al terminar FLUJO F , avanza a FLUJO H.
FLUJO F (Abandona pozo)
Luego de terminar (sea cual sea la respuesta, si aplica), avanza a FLUJO H .
FLUJO G (Instalación BM)
Cuando termine este flujo, avanza a FLUJO H.
FLUJO H (Material de agregación)
No es condicional: se supone que, al llegar aquí, se ejecuta y finaliza.
El resultado deseado es un único script de Python que combina estos ocho flujos en el orden descrito y respeta las condiciones de salto (SÍ/NO). Cada flujo debe:

Preguntar al usuario si desea ejecutar ese flujo (excepto FLUJO H, que siempre se ejecuta al llegar).
Si responde SÍ: ejecute la lógica interna de ese flujo (por ejemplo, las preguntas o procesos que incluían), e imprima la lista de materiales correspondientes.
Terminar ese flujo y, en lugar de salirse del programa, encadenar inmediatamente con el siguiente flujo indicado.
Si responde NO: saltarse la ejecución de ese flujo (no imprime materiales) y avanzar al siguiente flujo, salvo en el caso de FLUJO A y FLUJO E, que ya tienen desvíos particulares a otros flujos.


EL CODIGO EJECUTADO EN JUPYTER ES: ESTA UN POCO DESPROLIJO, PERO BUENO AL MENOS FUNCIONA


import os

import pandas as pd

import ipywidgets as widgets

from IPython.display import display, clear_output

 

# Variable global para almacenar los DataFrames finales de cada flujo

materiales_finales = []

 

# Función para renombrar las columnas y dejar solo las 5 requeridas

def renombrar_columnas(df):

    df_renombrado = df.rename(

        columns={

            "1. Cód.SAP": "Cód.SAP",

            "2. MATERIAL": "MATERIAL",

            "3. Descripción": "Descripción",

            "5.CONDICIÓN": "CONDICIÓN"

        }

    )

    # Asegurarse de que queden las siguientes columnas

    columnas = ["Cód.SAP", "MATERIAL", "Descripción", "4.CANTIDAD", "CONDICIÓN"]

    columnas_presentes = [col for col in columnas if col in df_renombrado.columns]

    return df_renombrado[columnas_presentes]

 

# ===============================

# FLUJO A: Ajuste de medida

# ===============================

def flujo_A():

    clear_output()

    print("FLUJO A: Ajuste de medida")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¿Ajuste de medida?",

        value="seleccionar"

    )

   

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\ajuste de medida.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DIÁMETRO"] = df["DIÁMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DIÁMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DIÁMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

       

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay TIPO disponibles. Se usará 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

       

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay valores para {columna}. Se usará 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

       

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DIÁMETRO: {diam_value}")

       

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

       

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

       

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DIÁMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False] * len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False] * len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DIÁMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                # En lugar de mostrar inmediatamente, se almacena el DataFrame renombrado

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO A", final_df_renombrado))

                # print("Materiales del FLUJO A guardados.")  # Desactivado

               

                # Botón para continuar a FLUJO H (ya que en FLUJO A si se responde SI se salta directamente a H)

                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                def on_continue(b):

                    flujo_H()

                continue_button.on_click(on_continue)

                display(continue_button)

       

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccionó NO en FLUJO A. Saltando a FLUJO B...")  # Desactivado

                flujo_B()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO B: Tubo de saca

# ===============================

def flujo_B():

    clear_output()

    print("FLUJO B: Tubo de saca")

    folder_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales"

    filename_saca = "saca tubing.xlsx"

    file_path_saca = os.path.join(folder_path, filename_saca)

    global df_saca_tubing

    df_saca_tubing = None

 

    def load_saca_tubing_excel():

        global df_saca_tubing

        if not os.path.exists(file_path_saca):

            print(f"El archivo {file_path_saca} no se encontró.")

            return

        df_tmp = pd.read_excel(file_path_saca)

        df_tmp.columns = df_tmp.columns.str.strip()

        for c in df_tmp.columns:

            if df_tmp[c].dtype == object:

                df_tmp[c] = df_tmp[c].astype(str).str.strip()

        df_saca_tubing = df_tmp.copy()

        diametro_multi_picker.options = sorted(

            [d for d in df_saca_tubing['DIÁMETRO'].unique() if d.upper() != 'TODOS']

        )

 

    diametro_multi_picker = widgets.SelectMultiple(

        options=[],

        description='DIÁMETRO:',

        style={'description_width': 'initial'}

    )

    confirm_diameter_button = widgets.Button(

        description='Confirmar diámetros',

        button_style='info'

    )

    quantities_container = widgets.VBox()

    final_output = widgets.Output()

    show_table_button = widgets.Button(

        description='Mostrar tabla final',

        button_style='success'

    )

 

    def on_show_table_button_clicked(b):

        with final_output:

            clear_output()

            if df_saca_tubing is None:

                print("No hay datos cargados de saca tubing.")

                return

            selected_diameters = list(diametro_multi_picker.value)

            df_filtered = df_saca_tubing[

                (df_saca_tubing['DIÁMETRO'].isin(selected_diameters)) |

                (df_saca_tubing['DIÁMETRO'].str.upper() == 'TODOS')

            ].copy()

            for child in quantities_container.children:

                dia = child.description

                cantidad = child.value

                mask = (df_filtered['DIÁMETRO'] == dia)

                df_filtered.loc[mask, '4.CANTIDAD'] = cantidad

            df_filtered_renombrado = renombrar_columnas(df_filtered)

            materiales_finales.append(("FLUJO B", df_filtered_renombrado))

            print("Materiales del FLUJO B guardados.")

 

        # Cierra la interfaz de FLUJO B

        multi_select_container.close()

 

        # Muestra el botón para continuar al FLUJO C

        continue_button = widgets.Button(

            description="Continuar a FLUJO C",

            button_style="success"

        )

        def on_continue(b):

            clear_output()

            flujo_C()

        continue_button.on_click(on_continue)

        display(continue_button)

 

    show_table_button.on_click(on_show_table_button_clicked)

 

    def on_confirm_diameter_button_clicked(b):

        with final_output:

            clear_output()

        quantities_container.children = []

        for dia in diametro_multi_picker.value:

            qty_widget = widgets.IntText(

                value=0,

                description=dia,

                style={'description_width': 'initial'}

            )

            quantities_container.children += (qty_widget,)

 

    confirm_diameter_button.on_click(on_confirm_diameter_button_clicked)

 

    multi_select_container = widgets.VBox([

        diametro_multi_picker,

        confirm_diameter_button,

        quantities_container,

        show_table_button,

        final_output

    ])

 

    bajara_tubing_picker = widgets.Dropdown(

        options=["Seleccione opción", "SI", "NO"],

        value="Seleccione opción",

        description="¿saca Tubing?:"

    )

 

    def on_bajara_tubing_change(change):

        clear_output()

        if change['new'] == "SI":

            load_saca_tubing_excel()

            display(multi_select_container)

        elif change['new'] == "NO":

            print("No se saca tubing.")

            flujo_C()

 

    bajara_tubing_picker.observe(on_bajara_tubing_change, names='value')

 

    print("¿Saca Tubing?")

    display(bajara_tubing_picker)

 

# ===============================

# FLUJO C: Tubería de Baja

# ===============================

def flujo_C():

    clear_output()

    print("FLUJO C: Tubería de Baja")

    file_path_baja = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja tubing.xlsx"

    global df_baja_tubing

    df_baja_tubing = None

    output = widgets.Output()

    baja_tubing_widget = widgets.ToggleButtons(

        options=['SI', 'NO'],

        description='¿Baja Tubing?',

        disabled=False,

        value=None

    )

    display(baja_tubing_widget, output)

   

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_baja):

                print(f"El archivo no se encontró en la ruta:\n{file_path_baja}")

                return False

            try:

                df = pd.read_excel(file_path_baja)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DIÁMETRO CSG' in df.columns:

                    df['DIÁMETRO CSG'] = df['DIÁMETRO CSG'].replace('nan', '').fillna('')

                global df_baja_tubing

                df_baja_tubing = df.copy()

                print("Archivo cargado y limpiado con éxito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

   

    def show_diametro_selection():

        with output:

            print("\n--- Selección de DIÁMETRO ---")

            df = df_baja_tubing

            unique_diametros = sorted([x for x in df['DIÁMETRO'].unique() if x != "TODOS"])

            diametro_widget = widgets.SelectMultiple(

                options=unique_diametros,

                value=(),

                description="DIÁMETRO",

                layout=widgets.Layout(width='50%')

            )

            display(diametro_widget)

            button_diametro = widgets.Button(description="Siguiente - Selección DIÁMETRO")

            display(button_diametro)

           

            def on_diametro_button_clicked(_):

                selected = list(diametro_widget.value)

                selected_diametros = ["TODOS"] if not selected else selected

                show_tipo_accordion(selected_diametros)

            button_diametro.on_click(on_diametro_button_clicked)

   

    def show_tipo_accordion(selected_diametros):

        with output:

            print("\n--- Selección de TIPO para cada DIÁMETRO ---")

            df = df_baja_tubing

            tipo_widgets = {}

            children = []

            titles = []

            for d in selected_diametros:

                df_temp = df if d=="TODOS" else df[df['DIÁMETRO'] == d]

                unique_tipos = sorted([x for x in df_temp['TIPO'].unique() if x != "TODOS"])

                widget_t = widgets.SelectMultiple(

                    options=unique_tipos,

                    value=(),

                    description=f"TIPO ({d})",

                    layout=widgets.Layout(width='50%')

                )

                tipo_widgets[d] = widget_t

                children.append(widget_t)

                titles.append(f"DIÁMETRO: {d}")

            accordion = widgets.Accordion(children=children)

            for idx, title in enumerate(titles):

                accordion.set_title(idx, title)

            display(accordion)

            button_tipo = widgets.Button(description="Siguiente - Selección TIPO")

            display(button_tipo)

           

            def on_tipo_button_clicked(_):

                selected_tipos_dict = {}

                for d, widget_t in tipo_widgets.items():

                    st = list(widget_t.value)

                    if not st:

                        st = ["TODOS"]

                    selected_tipos_dict[d] = st

                show_diametro_csg_selection(selected_diametros, selected_tipos_dict)

            button_tipo.on_click(on_tipo_button_clicked)

   

    def show_diametro_csg_selection(selected_diametros, selected_tipos_dict):

        with output:

            print("\n--- Selección de DIÁMETRO CSG ---")

            df = df_baja_tubing

            union_tipos = set()

            for tlist in selected_tipos_dict.values():

                if tlist == ["TODOS"]:

                    union_tipos.add("TODOS")

                else:

                    union_tipos.update(tlist)

                    union_tipos.add("TODOS")

            diam_filter = ["TODOS"] if selected_diametros == ["TODOS"] else selected_diametros + ["TODOS"]

            df_filtered = df[df['DIÁMETRO'].isin(diam_filter) & df['TIPO'].isin(union_tipos)]

            unique_csg = sorted([x for x in df_filtered['DIÁMETRO CSG'].unique() if x != "TODOS"])

            if not unique_csg:

                print("Nota: Solo 'TODOS' disponible para DIÁMETRO CSG. Se procede automáticamente.")

                show_quantity_inputs(selected_diametros, selected_tipos_dict, ["TODOS"])

            else:

                csg_widget = widgets.Dropdown(

                    options=unique_csg,

                    value=unique_csg[0],

                    description="DIÁMETRO CSG",

                    layout=widgets.Layout(width='50%')

                )

                display(csg_widget)

                button_csg = widgets.Button(description="Siguiente - Selección DIÁMETRO CSG")

                display(button_csg)

               

                def on_csg_button_clicked(_):

                    selected_csg = csg_widget.value

                    selected_csg_filter = [selected_csg, "TODOS"] if selected_csg != "TODOS" else ["TODOS"]

                    show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter)

                button_csg.on_click(on_csg_button_clicked)

   

    def show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter):

        with output:

            print("\n--- Ingreso de Cantidades ---")

            df = df_baja_tubing

            quantity_widgets = {}

            qty_items = []

            for d in selected_diametros:

                for t in selected_tipos_dict[d]:

                    key = (d, t)

                    w = widgets.IntText(

                        value=0,

                        description=f"{d} - {t}:",

                        layout=widgets.Layout(width='400px')

                    )

                    quantity_widgets[key] = w

                    qty_items.append(w)

            quantity_box = widgets.VBox(qty_items)

            display(quantity_box)

            update_qty_button = widgets.Button(description="Aplicar Cantidades", button_style="success")

            display(update_qty_button)

           

            def on_update_qty(b2):

                for (d, t), qty_widget in quantity_widgets.items():

                    qty_value = qty_widget.value

                    if d == "TODOS":

                        continue

                    condition = (df["DIÁMETRO"].isin([d, "TODOS"]) & df["TIPO"].isin([t, "TODOS"]))

                    df.loc[condition & df["4.CANTIDAD"].isna(), "4.CANTIDAD"] = qty_value

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in selected_tipos_dict.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict:

                        cond = (df["DIÁMETRO"].isin([diam_value, "TODOS"]) & df["TIPO"].isin([tipo_val, "TODOS"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO C", final_df_renombrado))

                # print("Materiales del FLUJO C guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO D", button_style="success")

                def on_continue(b):

                    flujo_D()

                continue_button.on_click(on_continue)

                display(continue_button)

            update_qty_button.on_click(on_update_qty)

   

    def on_baja_tubing_change(change):

        if change['name'] == 'value' and change['new'] is not None:

            if change['new'] == 'SI':

                if load_excel():

                    show_diametro_selection()

            else:

                with output:

                    print("No se procede con Baja Tubing.")

                flujo_D()

    baja_tubing_widget.observe(on_baja_tubing_change, names='value')

   

# ===============================

# FLUJO D: Profundiza

# ===============================

def flujo_D():

    clear_output()

    print("FLUJO D: Profundiza")

    output = widgets.Output()

    file_path_prof = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\profundiza.xlsx"

    global df_prof

    df_prof = None

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_prof):

                print(f"El archivo no se encontró en la ruta:\n{file_path_prof}")

                return False

            try:

                df = pd.read_excel(file_path_prof)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DIÁMETRO CSG' in df.columns:

                    df['DIÁMETRO CSG'] = df['DIÁMETRO CSG'].replace('nan', '').fillna('')

                global df_prof

                df_prof = df.copy()

                print("Archivo cargado y limpiado con éxito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

    profundiza_widget = widgets.Dropdown(

        options=["seleccionar", "SI", "NO"],

        description="Profundizar:",

        value="seleccionar"

    )

    def on_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(output)

            if change['new'] == "SI":

                if load_excel():

                    if "DIÁMETRO" in df_prof.columns:

                        col_diametro = "DIÁMETRO"

                    elif "DIÁMETRO CSG" in df_prof.columns:

                        col_diametro = "DIÁMETRO CSG"

                    else:

                        with output:

                            print("La columna de DIÁMETRO no se encontró en el Excel.")

                        return

                    diametro_select = widgets.SelectMultiple(

                        options=df_prof[col_diametro].unique().tolist(),

                        description="DIÁMETRO",

                        rows=10

                    )

                    display(diametro_select)

                    confirm_button = widgets.Button(description="Confirmar selección")

                    output_area = widgets.Output()

                    def on_confirm(b):

                        with output_area:

                            clear_output()

                            selected_diametros = list(diametro_select.value)

                            if not selected_diametros:

                                print("No se seleccionaron diámetros.")

                                return

                            print("Ingrese la cantidad para cada DIÁMETRO seleccionado:")

                            numeric_widgets = {}

                            for d in selected_diametros:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1000000,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                            apply_button = widgets.Button(description="Aplicar cantidades")

                            def on_apply(b):

                                filtered_df = df_prof[df_prof[col_diametro].isin(selected_diametros)].copy()

                                for d in selected_diametros:

                                    cantidad = numeric_widgets[d].value

                                    filtered_df.loc[filtered_df[col_diametro] == d, "4.CANTIDAD"] = cantidad

                                final_df_renombrado = renombrar_columnas(filtered_df)

                                materiales_finales.append(("FLUJO D", final_df_renombrado))

                                # print("Materiales del FLUJO D guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO E", button_style="success")

                                def on_continue(b):

                                    flujo_E()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                            apply_button.on_click(on_apply)

                            display(apply_button)

                    confirm_button.on_click(on_confirm)

                    display(confirm_button, output_area)

            else:

                with output:

                    print("No se profundizará en la información.")

                flujo_E()

    profundiza_widget.observe(on_change)

    display(profundiza_widget)

    display(output)

 

# ===============================

# FLUJO E: Baja varillas

# ===============================

def flujo_E():

    clear_output()

    print("FLUJO E: Baja varillas")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¿Baja Varilla?",

        value="seleccionar"

    )

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja varillas.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DIÁMETRO"] = df["DIÁMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DIÁMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DIÁMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay TIPO disponibles. Se usará 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay valores para {columna}. Se usará 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DIÁMETRO: {diam_value}")

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DIÁMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DIÁMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO E", final_df_renombrado))

                # print("Materiales del FLUJO E guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO G", button_style="success")

                def on_continue(b):

                    flujo_G()

                continue_button.on_click(on_continue)

                display(continue_button)

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccionó NO en FLUJO E. Saltando a FLUJO F...")  # Desactivado

                flujo_F()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO F: Abandona pozo

# ===============================

def flujo_F():

    clear_output()

    print("FLUJO F: Abandona pozo")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\abandono-recupero.xlsx"

    global df_abandono

    df_abandono = None

    output = widgets.Output()

    question_widget = widgets.Dropdown(

        options=["NO", "SI"],

        value="NO",

        description="¿Abandono/recupero?:"

    )

    def filter_by_todos(df, column, selected_values):

        if "TODOS" in selected_values:

            return df

        else:

            allowed_values = list(selected_values) + ["TODOS"]

            return df[df[column].isin(allowed_values)]

    def on_question_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(question_widget, output)

            if change['new'] == "SI":

                with output:

                    # print("Cargando el Excel...")  # (Este print no está en la lista a desactivar, se mantiene)

                    if not os.path.exists(file_path):

                        print(f"No se encontró el archivo:\n{file_path}")

                        return

                    global df_abandono

                    try:

                        df_abandono = pd.read_excel(file_path)

                    except Exception as e:

                        print("Error al cargar el Excel:", e)

                        return

                    print("Archivo cargado exitosamente.")

                df_abandono.columns = df_abandono.columns.str.strip()

                for col in df_abandono.columns:

                    if df_abandono[col].dtype == object:

                        df_abandono[col] = df_abandono[col].astype(str).str.strip()

                if "DIÁMETRO" not in df_abandono.columns:

                    with output:

                        print("La columna 'DIÁMETRO' no existe en el Excel.")

                    return

                unique_diametros = df_abandono["DIÁMETRO"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros:

                    unique_diametros.insert(0, "TODOS")

                else:

                    unique_diametros.remove("TODOS")

                    unique_diametros.insert(0, "TODOS")

                if "DIÁMETRO CSG" not in df_abandono.columns:

                    with output:

                        print("La columna 'DIÁMETRO CSG' no existe en el Excel.")

                    return

                unique_diametros_csg = df_abandono["DIÁMETRO CSG"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros_csg:

                    unique_diametros_csg.insert(0, "TODOS")

                else:

                    unique_diametros_csg.remove("TODOS")

                    unique_diametros_csg.insert(0, "TODOS")

                diametro_multi = widgets.SelectMultiple(

                    options=unique_diametros,

                    value=["TODOS"],

                    description="DIÁMETRO:",

                    rows=6

                )

                diametro_csg_single = widgets.Dropdown(

                    options=unique_diametros_csg,

                    value="TODOS",

                    description="DIÁM CSG:"

                )

                confirm_button = widgets.Button(

                    description="Confirmar Filtros",

                    button_style="info"

                )

                next_output = widgets.Output()

                def on_confirm_filters(b):

                    with next_output:

                        clear_output()

                        selected_diametros = list(diametro_multi.value)

                        selected_diametro_csg = diametro_csg_single.value

                        filtered_df = df_abandono.copy()

                        filtered_df = filter_by_todos(filtered_df, "DIÁMETRO", selected_diametros)

                        filtered_df = filter_by_todos(filtered_df, "DIÁMETRO CSG", [selected_diametro_csg])

                        print("Filtrado Aplicado. A continuación, ingrese cantidades (solo para celdas vacías).")

                        numeric_widgets = {}

                        diametros_especificos = [d for d in selected_diametros if d != "TODOS"]

                        if diametros_especificos:

                            print("Ingrese la cantidad para cada DIÁMETRO seleccionado:")

                            for d in diametros_especificos:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1e9,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                        else:

                            print("No se seleccionaron diámetros específicos. No se solicitarán cantidades.")

                        apply_button = widgets.Button(

                            description="Aplicar Cantidades",

                            button_style="success"

                        )

                        final_output = widgets.Output()

                        def on_apply_quantities(btn):

                            with final_output:

                                clear_output()

                                if "4.CANTIDAD" not in df_abandono.columns:

                                    print("La columna '4.CANTIDAD' no existe en el Excel.")

                                    return

                                df_abandono["4.CANTIDAD"] = pd.to_numeric(df_abandono["4.CANTIDAD"], errors="coerce")

                                for d in diametros_especificos:

                                    qty = numeric_widgets[d].value

                                    mask_diam = (df_abandono["DIÁMETRO"] == d)

                                    mask_nan = df_abandono["4.CANTIDAD"].isna()

                                    df_abandono.loc[mask_diam & mask_nan, "4.CANTIDAD"] = qty

                                filtered_final = df_abandono.copy()

                                filtered_final = filter_by_todos(filtered_final, "DIÁMETRO", selected_diametros)

                                filtered_final = filter_by_todos(filtered_final, "DIÁMETRO CSG", [selected_diametro_csg])

                                print("Listado Final Filtrado:")

                                filtered_final_renombrado = renombrar_columnas(filtered_final)

                                materiales_finales.append(("FLUJO F", filtered_final_renombrado))

                                # print("Materiales del FLUJO F guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                                def on_continue(b):

                                    flujo_H()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                        apply_button.on_click(on_apply_quantities)

                        display(apply_button, final_output)

                confirm_button.on_click(on_confirm_filters)

                display(diametro_multi, diametro_csg_single, confirm_button, next_output)

            else:

                with output:

                    # print("No se realizará la acción. Saltando a FLUJO H...")  # Desactivado

                    pass

                flujo_H()

    question_widget.observe(on_question_change, names='value')

    display(question_widget, output)

 

 

# ===============================

# FLUJO G: Instalación BM

# ===============================

def flujo_G():

    clear_output()

    print("FLUJO G: Instalación BM")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\WO.xlsx"

    pregunta_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¿WO a BM?",

        value="seleccionar"

    )

    def mostrar_materiales(change):

        clear_output()

        display(pregunta_widget)

        if change['new'] == "SI":

            try:

                df = pd.read_excel(file_path)

                print("Lista de materiales:")

                df_renombrado = renombrar_columnas(df)

                materiales_finales.append(("FLUJO G", df_renombrado))

                # print("Materiales del FLUJO G guardados.")  # Desactivado

            except Exception as e:

                print("Error al cargar Excel:", e)

            continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

            def on_continue(b):

                flujo_H()

            continue_button.on_click(on_continue)

            display(continue_button)

        elif change['new'] == "NO":

            print("No se mostrarán los materiales.")

            flujo_H()

    pregunta_widget.observe(mostrar_materiales, names='value')

    display(pregunta_widget)

 

def flujo_H():

    clear_output()

    print("=== FLUJO H: Material de agregación ===")

    try:

        file_path_H = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\GENERAL(1).xlsx"

        df_H = pd.read_excel(file_path_H)

        df_H.columns = df_H.columns.str.strip()

        if "4.CANTIDAD" not in df_H.columns:

            df_H["4.CANTIDAD"] = 0

    except Exception as e:

        print("Error al cargar el Excel:", e)

        df_H = pd.DataFrame()

   

    pregunta_widget_H = widgets.RadioButtons(

        options=["Seleccionar", "SI", "NO"],

        description="¿Agregar más material?",

        value="Seleccionar"

    )

    output_container_H = widgets.Output()

 

    apply_selection_button_H = widgets.Button(description="Aplicar selección", button_style="info")

    apply_qty_button_H = widgets.Button(description="Asignar cantidades", button_style="success")

   

    final_list_button = widgets.Button(description="Mostrar Listado Final de Materiales", button_style="warning")

    final_button_container = widgets.VBox([final_list_button])

   

    def on_show_final_list(b):

        clear_output()

        print("Listado final de materiales de todos los flujos ejecutados:")

        for flow, df in materiales_finales:

            print(f"\n---- {flow} ----")

            display(df)

    final_list_button.on_click(on_show_final_list)

   

    if not df_H.empty and "2. MATERIAL" in df_H.columns:

        materiales = df_H["2. MATERIAL"].astype(str).unique().tolist()

    else:

        materiales = []

    materiales_widget_H = widgets.SelectMultiple(

        options=materiales,

        description="Materiales",

        layout=widgets.Layout(width='50%', height='150px')

    )

    qty_widgets_H = {}

   

    def on_apply_selection_H(b):

        with output_container_H:

            clear_output()

            seleccionados = list(materiales_widget_H.value)

            if not seleccionados:

                print("No se seleccionó ningún material.")

                return

            print("Materiales seleccionados:")

            for mat in seleccionados:

                print("-", mat)

            qty_widgets_H.clear()

            input_boxes = []

            for mat in seleccionados:

                qty_box = widgets.BoundedFloatText(

                    value=0,

                    min=0,

                    step=1,

                    description=f"Cant: {mat}",

                    layout=widgets.Layout(width='50%')

                )

                qty_widgets_H[mat] = qty_box

                input_boxes.append(qty_box)

            display(widgets.VBox(input_boxes))

            display(apply_qty_button_H)

   

    def on_apply_qty_H(b):

        with output_container_H:

            clear_output()

            if df_H.empty:

                print("El DataFrame está vacío o no se cargó correctamente.")

                return

            selected_materials = list(qty_widgets_H.keys())

            for mat, widget_box in qty_widgets_H.items():

                cant = widget_box.value

                df_H.loc[df_H["2. MATERIAL"].astype(str) == mat, "4.CANTIDAD"] = cant

            assigned_df = df_H[

                df_H["2. MATERIAL"].astype(str).isin(selected_materials) &

                (df_H["4.CANTIDAD"] > 0)

            ]

            if not assigned_df.empty:

                assigned_df_renombrado = renombrar_columnas(assigned_df)

                materiales_finales.append(("FLUJO H", assigned_df_renombrado))

                # print("Materiales del FLUJO H guardados.")  # Desactivado

            else:

                print("No se asignaron cantidades (o todas fueron 0).")

           

            display(final_button_container)

   

    def on_pregunta_change_H(change):

        with output_container_H:

            clear_output()

            if change['new'] == "SI":

                if df_H.empty:

                    print("El DataFrame no se cargó o está vacío.")

                    return

                print("Lista completa de materiales del Excel:\n")

                display(df_H)

                print("\nSeleccione los materiales que desea agregar:")

                display(materiales_widget_H)

                display(apply_selection_button_H)

            elif change['new'] == "NO":

                print("No se agregarán más materiales.")

                display(final_button_container)

   

    pregunta_widget_H.observe(on_pregunta_change_H, names='value')

    apply_selection_button_H.on_click(on_apply_selection_H)

    apply_qty_button_H.on_click(on_apply_qty_H)

   

    display(pregunta_widget_H)

    display(output_container_H)

   

    # print("FLUJO H finalizado. Fin del proceso.")  # Desactivado

 

 

# ===============================

# Función principal: inicia en FLUJO A

# ===============================

def main():

    flujo_A()

 

# Inicia el proceso

main()
```

## docs/Estructura del proyecto.md

- Characters: 6225
- Tokens: 0

```markdown
🔹 1. Introducción
Este documento detalla la arquitectura propuesta para la implementación de un sistema de flujos modulares en una aplicación basada en Python y Flask. El objetivo es permitir la ejecución de múltiples flujos de trabajo (Flujo A, B, C, etc.), en los cuales cada flujo es un módulo independiente que recibe entradas del usuario, filtra datos de archivos Excel, y proporciona salidas que pueden afectar a los siguientes flujos.

🔹 2. Análisis Inicial del Problema
El código original consistía en una serie de filtros aplicados secuencialmente sobre distintos archivos de datos. Cada flujo:

Preguntaba al usuario si debía ejecutarse.
Aplicaba filtros a un conjunto de datos en función de la respuesta.
Mostraba los materiales resultantes.
Determinaba el siguiente flujo a ejecutar.
📌 Conclusión: La lógica de cada flujo era principalmente un filtro condicional sobre un conjunto de datos basado en respuestas del usuario.

Problemas detectados en la implementación inicial
❌ Código monolítico y difícil de extender.
❌ Falta de modularidad: cada flujo estaba acoplado a la lógica general.
❌ No había un manejo centralizado del estado y flujo de datos.

🔹 3. Patrón de Diseño Elegido
Se adoptó una arquitectura basada en plugins combinada con un manejo centralizado del flujo utilizando Flask Sessions. Esto permite:

📌 Modularidad: Cada flujo es un plugin independiente que puede añadirse sin modificar la estructura general.
📌 Flexibilidad: El orden de ejecución se define externamente y no dentro de cada módulo.
📌 Escalabilidad: Es fácil agregar nuevos flujos sin afectar el sistema.
📌 Manejo de Estado: Se utiliza Flask Sessions para almacenar respuestas y materiales seleccionados.
🔹 Patrón de diseño:
Plugin-Based Architecture + State Management
Cada flujo actúa como un plugin independiente y el sistema maneja las transiciones y datos entre ellos.

🔹 4. Arquitectura Resultante
📂 Estructura del Proyecto
bash
Copy
Edit
/app
  ├── main.py               # Punto de entrada de la aplicación
  ├── flujo_loader.py       # Carga y gestiona los flujos dinámicamente
  ├── plugins/              # Módulos independientes de cada flujo
  │   ├── __init__.py
  │   ├── flujo_a.py        # Flujo A
  │   ├── flujo_b.py        # Flujo B
  │   ├── flujo_c.py        # Flujo C
  │   ├── flujo_d.py        # Flujo D
  │   ├── flujo_e.py        # Flujo E
  │   ├── flujo_f.py        # Flujo F
  │   ├── flujo_g.py        # Flujo G
  │   ├── flujo_h.py        # Flujo H (siempre se ejecuta)
  ├── templates/            # HTML para la interfaz de usuario
  │   ├── base.html
  │   ├── index.html
  │   ├── flujo.html        # Página genérica para cada flujo
  │   ├── resultados.html   # Página de resultados finales
  ├── static/               # Archivos CSS y JS
  ├── data/                 # Archivos Excel
  ├── requirements.txt
  └── README.md
🔹 5. Manejo del Flujo de Ejecución
En lugar de definir el orden de los flujos dentro de cada módulo, se utiliza un diccionario de transición que maneja la lógica centralmente.

📌 Configuración de flujos en flujo_loader.py

python
Copy
Edit
SECUENCIA_FLUJOS = {
    "A": {"SI": "H", "NO": "B"},
    "B": {"SI": "C", "NO": "C"},
    "C": {"SI": "D", "NO": "D"},
    "D": {"SI": "E", "NO": "E"},
    "E": {"SI": "G", "NO": "F"},
    "F": {"SI": "H", "NO": "H"},
    "G": {"SI": "H", "NO": "H"},
    "H": None  # Último flujo
}
📌 Cómo funciona:

Cada flujo tiene una entrada (respuesta del usuario).
Se determina el siguiente flujo basado en la respuesta (SI o NO).
Los datos de cada flujo se almacenan en session para ser utilizados en flujos posteriores.
🔹 6. Ejemplo de Flujo Individual
Cada flujo es un módulo independiente en la carpeta plugins/.

📌 Ejemplo de plugins/flujo_a.py

python
Copy
Edit
from flask import render_template, request

nombre = "A"

def ejecutar():
    if request.method == "POST":
        respuesta = request.form.get("respuesta")
        materiales_seleccionados = ["Material X", "Material Y"] if respuesta == "SI" else []
        return respuesta, materiales_seleccionados

    return render_template("flujo.html", flujo=nombre)
📌 Explicación:

Cada flujo recibe una entrada (POST del usuario).
Si el usuario responde "SI", filtra materiales y los guarda.
Si el usuario responde "NO", se salta el procesamiento.
El sistema decide cuál es el siguiente flujo.
🔹 7. Manejo del Estado Global
Se utiliza Flask Sessions para mantener los datos entre flujos.

📌 Ejemplo de cómo se almacenan los datos en session

python
Copy
Edit
@app.route("/flujo/<nombre_flujo>", methods=["GET", "POST"])
def flujo(nombre_flujo):
    if nombre_flujo in flujos:
        respuesta, materiales, siguiente_flujo = ejecutar_flujo(nombre_flujo, session)

        # Guardar en sesión
        session[nombre_flujo] = {"respuesta": respuesta, "materiales": materiales}

        # Continuar al siguiente flujo o finalizar
        return redirect(url_for("flujo", nombre_flujo=siguiente_flujo)) if siguiente_flujo else redirect(url_for("resultados"))

    return redirect(url_for("index"))
📌 Beneficios del uso de session ✔ Permite almacenar datos persistentes sin base de datos.
✔ Mantiene la continuidad entre flujos.
✔ Hace que cada flujo sea independiente sin necesidad de modificar otros flujos.

🔹 8. Beneficios de la Arquitectura
Característica	Beneficio
Plugins Modulares	Se pueden agregar nuevos flujos sin modificar main.py.
Configuración Centralizada	El orden de ejecución se define en flujo_loader.py.
Manejo de Estado con session	Cada flujo puede acceder a respuestas y materiales previos.
Separación de Responsabilidades	main.py maneja la app, flujo_loader.py los flujos, y los plugins contienen la lógica específica.
Escalabilidad	Fácil de expandir sin modificar el código existente.
🔹 9. Conclusión
Se pasó de una estructura monolítica a una arquitectura basada en plugins donde:

Cada flujo es un módulo autónomo con entrada y salida.
El flujo de ejecución es gestionado dinámicamente.
Se utiliza session para almacenar respuestas y datos.
Los desarrolladores pueden agregar nuevos flujos sin modificar la estructura base.
Este modelo permite escalabilidad, modularidad y facilidad de mantenimiento, alineándose con buenas prácticas de arquitectura de software.
```

## README.md

- Characters: 1903
- Tokens: 0

```markdown
# Visualizador de Excel

Esta aplicación simple permite visualizar archivos Excel como tablas HTML en un navegador web.

## Requisitos

- Python 3.6 o superior
- pip (gestor de paquetes de Python)

## Instalación

1. Clona o descarga este repositorio
2. Instala las dependencias:

# Configuración y ejecución en VS Code (Windows)
Requisitos previos

Python 3.6 o superior
pip (gestor de paquetes de Python)

Pasos para ejecutar la aplicación
1. Clonar el repositorio
Copygit clone [URL_DEL_REPOSITORIO]
cd mi_app
2. Crear y activar un entorno virtual
Copy# Crear entorno virtual
python -m venv venv

# Activar el entorno virtual
venv\Scripts\activate
3. Instalar dependencias
Copy# Instalar todas las dependencias necesarias
pip install flask==2.3.3 openpyxl==3.1.2 pandas xlrd==2.0.1
4. Preparar los archivos Excel

Coloca tus archivos Excel (.xlsx o .xls) en la carpeta app/data/
Si la carpeta no existe, se creará automáticamente al iniciar la aplicación

5. Ejecutar la aplicación
Copy# Navegar a la carpeta app
cd app

# Iniciar la aplicación
python main.py
6. Acceder a la aplicación

Abre tu navegador y navega a: http://127.0.0.1:5000
Verás todos los archivos Excel cargados y podrás iniciar los flujos de trabajo

7. Desactivar el entorno virtual cuando termines
Copydeactivate
Solución de problemas comunes

Error "No module named...": Verifica que el entorno virtual esté activado y que todas las dependencias estén instaladas
Archivos Excel no visibles: Asegúrate de que estén en la carpeta correcta (app/data/) y tengan la extensión correcta (.xlsx o .xls)

3. Abre tu navegador y ve a `http://localhost:5000`

## Notas

- La aplicación mostrará todos los archivos Excel (.xlsx o .xls) encontrados en la carpeta `data`
- Cada archivo se convertirá en una tabla HTML
- Puedes recargar la página para actualizar los datos si agregas nuevos archivos Excel mientras la aplicación está corriendo
```

## .gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## Statistics

- Total Files: 20
- Total Characters: 77654
- Total Tokens: 0
````

## docs/Flujo A - Doc tecnico.md

- Characters: 2871
- Tokens: 0

```markdown
📌 Especificación Técnica para Desarrollo – FLUJO A (Ajuste de Medida)
1️⃣ Descripción General
FLUJO A permite al usuario seleccionar materiales basados en criterios específicos de ajuste de medida. Si el usuario acepta el ajuste, el flujo filtra los materiales y salta directamente a FLUJO H. Si el usuario rechaza, salta a FLUJO B sin procesar datos.

2️⃣ Datos de Entrada
La información proviene de una tabla estructurada (ajuste_de_medida.xlsx), con las siguientes columnas clave:

Columna	Tipo	Descripción
DIÁMETRO	string	Diámetro del material
TIPO	string	Tipo de material
GRADO DE ACERO	string	Grado de acero
GRADO DE ACERO CUPLA	string	Grado de acero de la cupla
TIPO DE CUPLA	string	Tipo de cupla
4.CANTIDAD	float	Cantidad del material (opcional)
3️⃣ Flujo de Ejecución
Pregunta al usuario:

Si responde "NO" → Salta directamente a FLUJO B.
Si responde "SÍ" → Carga la tabla y aplica filtros.
Carga y Filtrado de Datos:

Carga la tabla ajuste_de_medida.xlsx y limpia valores.
El usuario selecciona valores en los siguientes filtros:
DIÁMETRO
TIPO
GRADO DE ACERO
GRADO DE ACERO CUPLA
TIPO DE CUPLA
Si el usuario no selecciona un valor, se usa "TODOS" como fallback.
Construcción de final_condition (máscara booleana de filtrado):

Inicializa final_condition con False para excluir todos los registros.
Para cada DIÁMETRO seleccionado, evalúa si los materiales cumplen con los criterios del usuario.
Incluye "TODOS" en cada filtro para garantizar que los valores no seleccionados no eliminen registros útiles.
Se combinan las condiciones (| lógico) para crear el filtro final.
Aplicación del Filtro:

python
Copy
Edit
final_df = df[final_condition]
Solo quedan los materiales que cumplen con los criterios del usuario.
Almacena los materiales filtrados en materiales_finales:

python
Copy
Edit
materiales_finales.append(("FLUJO A", final_df_renombrado))
Salto a FLUJO H (el flujo no sigue la secuencia normal):

Si el usuario ejecuta FLUJO A, no sigue a FLUJO B, sino directamente a FLUJO H.
4️⃣ Consideraciones Técnicas
✔ No modifica la estructura de la tabla, solo aplica filtros.
✔ Debe permitir múltiples selecciones en cada filtro.
✔ Evita pérdida de datos con "TODOS" en cada condición.
✔ Encapsular final_condition como lógica reutilizable para otros flujos.
✔ Optimizar el acceso a archivos si se requiere ejecución frecuente.

📌 Resumen Final
FLUJO A solo se ejecuta si el usuario dice "SÍ".
Carga una tabla de materiales y filtra datos según selección del usuario.
Almacena los materiales seleccionados y salta directamente a FLUJO H.
Si el usuario dice "NO", salta a FLUJO B sin procesar nada.
final_condition es el mecanismo que define qué materiales quedan en la selección final.
🚀 Resultado esperado: Un módulo optimizado que procesa materiales en base a filtros dinámicos y garantiza la continuidad del flujo sin interrumpir la secuencia de ejecución.
```

## docs/commentarios del proy.md

- Characters: 52736
- Tokens: 0

```markdown
engo varios códigos por separado que representan diferentes flujos para la selección de materiales en la intervención de un pozo petrolero: FLUJO A, FLUJO B, FLUJO C, FLUJO D, FLUJO E, FLUJO F, FLUJO G y FLUJO H. Cada uno de ellos inicia con una pregunta que, si el usuario responde “NO”, salta inmediatamente al siguiente flujo; y si el usuario responde “SÍ”, entonces ejecuta su lógica, imprime una lista de materiales y luego avanza al siguiente flujo.

Los flujos se llaman y se encadenan de la siguiente forma:

FLUJO A (Ajuste de medida)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO H.
Si el usuario responde NO , salta a FLUJO B.
FLUJO B (Tubo de saca)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO C.
Si el usuario responde NO , salta a FLUJO C.
FLUJO C (tubería de Baja)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO D.
Si el usuario responde NO , salta a FLUJO D.
FLUJO D (Profundiza)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO E.
Si el usuario responde NO , salta a FLUJO E.
FLUJO E (Baja varillas)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO G.
Luego de terminar FLUJO G , debe continuar a FLUJO H .
Si el usuario responde NO , salta a FLUJO F , y al terminar FLUJO F , avanza a FLUJO H.
FLUJO F (Abandona pozo)
Luego de terminar (sea cual sea la respuesta, si aplica), avanza a FLUJO H .
FLUJO G (Instalación BM)
Cuando termine este flujo, avanza a FLUJO H.
FLUJO H (Material de agregación)
No es condicional: se supone que, al llegar aquí, se ejecuta y finaliza.
El resultado deseado es un único script de Python que combina estos ocho flujos en el orden descrito y respeta las condiciones de salto (SÍ/NO). Cada flujo debe:

Preguntar al usuario si desea ejecutar ese flujo (excepto FLUJO H, que siempre se ejecuta al llegar).
Si responde SÍ: ejecute la lógica interna de ese flujo (por ejemplo, las preguntas o procesos que incluían), e imprima la lista de materiales correspondientes.
Terminar ese flujo y, en lugar de salirse del programa, encadenar inmediatamente con el siguiente flujo indicado.
Si responde NO: saltarse la ejecución de ese flujo (no imprime materiales) y avanzar al siguiente flujo, salvo en el caso de FLUJO A y FLUJO E, que ya tienen desvíos particulares a otros flujos.


EL CODIGO EJECUTADO EN JUPYTER ES: ESTA UN POCO DESPROLIJO, PERO BUENO AL MENOS FUNCIONA


import os

import pandas as pd

import ipywidgets as widgets

from IPython.display import display, clear_output

 

# Variable global para almacenar los DataFrames finales de cada flujo

materiales_finales = []

 

# Función para renombrar las columnas y dejar solo las 5 requeridas

def renombrar_columnas(df):

    df_renombrado = df.rename(

        columns={

            "1. Cód.SAP": "Cód.SAP",

            "2. MATERIAL": "MATERIAL",

            "3. Descripción": "Descripción",

            "5.CONDICIÓN": "CONDICIÓN"

        }

    )

    # Asegurarse de que queden las siguientes columnas

    columnas = ["Cód.SAP", "MATERIAL", "Descripción", "4.CANTIDAD", "CONDICIÓN"]

    columnas_presentes = [col for col in columnas if col in df_renombrado.columns]

    return df_renombrado[columnas_presentes]

 

# ===============================

# FLUJO A: Ajuste de medida

# ===============================

def flujo_A():

    clear_output()

    print("FLUJO A: Ajuste de medida")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¿Ajuste de medida?",

        value="seleccionar"

    )

   

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\ajuste de medida.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DIÁMETRO"] = df["DIÁMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DIÁMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DIÁMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

       

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay TIPO disponibles. Se usará 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

       

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay valores para {columna}. Se usará 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

       

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DIÁMETRO: {diam_value}")

       

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

       

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

       

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DIÁMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False] * len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False] * len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DIÁMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                # En lugar de mostrar inmediatamente, se almacena el DataFrame renombrado

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO A", final_df_renombrado))

                # print("Materiales del FLUJO A guardados.")  # Desactivado

               

                # Botón para continuar a FLUJO H (ya que en FLUJO A si se responde SI se salta directamente a H)

                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                def on_continue(b):

                    flujo_H()

                continue_button.on_click(on_continue)

                display(continue_button)

       

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccionó NO en FLUJO A. Saltando a FLUJO B...")  # Desactivado

                flujo_B()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO B: Tubo de saca

# ===============================

def flujo_B():

    clear_output()

    print("FLUJO B: Tubo de saca")

    folder_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales"

    filename_saca = "saca tubing.xlsx"

    file_path_saca = os.path.join(folder_path, filename_saca)

    global df_saca_tubing

    df_saca_tubing = None

 

    def load_saca_tubing_excel():

        global df_saca_tubing

        if not os.path.exists(file_path_saca):

            print(f"El archivo {file_path_saca} no se encontró.")

            return

        df_tmp = pd.read_excel(file_path_saca)

        df_tmp.columns = df_tmp.columns.str.strip()

        for c in df_tmp.columns:

            if df_tmp[c].dtype == object:

                df_tmp[c] = df_tmp[c].astype(str).str.strip()

        df_saca_tubing = df_tmp.copy()

        diametro_multi_picker.options = sorted(

            [d for d in df_saca_tubing['DIÁMETRO'].unique() if d.upper() != 'TODOS']

        )

 

    diametro_multi_picker = widgets.SelectMultiple(

        options=[],

        description='DIÁMETRO:',

        style={'description_width': 'initial'}

    )

    confirm_diameter_button = widgets.Button(

        description='Confirmar diámetros',

        button_style='info'

    )

    quantities_container = widgets.VBox()

    final_output = widgets.Output()

    show_table_button = widgets.Button(

        description='Mostrar tabla final',

        button_style='success'

    )

 

    def on_show_table_button_clicked(b):

        with final_output:

            clear_output()

            if df_saca_tubing is None:

                print("No hay datos cargados de saca tubing.")

                return

            selected_diameters = list(diametro_multi_picker.value)

            df_filtered = df_saca_tubing[

                (df_saca_tubing['DIÁMETRO'].isin(selected_diameters)) |

                (df_saca_tubing['DIÁMETRO'].str.upper() == 'TODOS')

            ].copy()

            for child in quantities_container.children:

                dia = child.description

                cantidad = child.value

                mask = (df_filtered['DIÁMETRO'] == dia)

                df_filtered.loc[mask, '4.CANTIDAD'] = cantidad

            df_filtered_renombrado = renombrar_columnas(df_filtered)

            materiales_finales.append(("FLUJO B", df_filtered_renombrado))

            print("Materiales del FLUJO B guardados.")

 

        # Cierra la interfaz de FLUJO B

        multi_select_container.close()

 

        # Muestra el botón para continuar al FLUJO C

        continue_button = widgets.Button(

            description="Continuar a FLUJO C",

            button_style="success"

        )

        def on_continue(b):

            clear_output()

            flujo_C()

        continue_button.on_click(on_continue)

        display(continue_button)

 

    show_table_button.on_click(on_show_table_button_clicked)

 

    def on_confirm_diameter_button_clicked(b):

        with final_output:

            clear_output()

        quantities_container.children = []

        for dia in diametro_multi_picker.value:

            qty_widget = widgets.IntText(

                value=0,

                description=dia,

                style={'description_width': 'initial'}

            )

            quantities_container.children += (qty_widget,)

 

    confirm_diameter_button.on_click(on_confirm_diameter_button_clicked)

 

    multi_select_container = widgets.VBox([

        diametro_multi_picker,

        confirm_diameter_button,

        quantities_container,

        show_table_button,

        final_output

    ])

 

    bajara_tubing_picker = widgets.Dropdown(

        options=["Seleccione opción", "SI", "NO"],

        value="Seleccione opción",

        description="¿saca Tubing?:"

    )

 

    def on_bajara_tubing_change(change):

        clear_output()

        if change['new'] == "SI":

            load_saca_tubing_excel()

            display(multi_select_container)

        elif change['new'] == "NO":

            print("No se saca tubing.")

            flujo_C()

 

    bajara_tubing_picker.observe(on_bajara_tubing_change, names='value')

 

    print("¿Saca Tubing?")

    display(bajara_tubing_picker)

 

# ===============================

# FLUJO C: Tubería de Baja

# ===============================

def flujo_C():

    clear_output()

    print("FLUJO C: Tubería de Baja")

    file_path_baja = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja tubing.xlsx"

    global df_baja_tubing

    df_baja_tubing = None

    output = widgets.Output()

    baja_tubing_widget = widgets.ToggleButtons(

        options=['SI', 'NO'],

        description='¿Baja Tubing?',

        disabled=False,

        value=None

    )

    display(baja_tubing_widget, output)

   

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_baja):

                print(f"El archivo no se encontró en la ruta:\n{file_path_baja}")

                return False

            try:

                df = pd.read_excel(file_path_baja)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DIÁMETRO CSG' in df.columns:

                    df['DIÁMETRO CSG'] = df['DIÁMETRO CSG'].replace('nan', '').fillna('')

                global df_baja_tubing

                df_baja_tubing = df.copy()

                print("Archivo cargado y limpiado con éxito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

   

    def show_diametro_selection():

        with output:

            print("\n--- Selección de DIÁMETRO ---")

            df = df_baja_tubing

            unique_diametros = sorted([x for x in df['DIÁMETRO'].unique() if x != "TODOS"])

            diametro_widget = widgets.SelectMultiple(

                options=unique_diametros,

                value=(),

                description="DIÁMETRO",

                layout=widgets.Layout(width='50%')

            )

            display(diametro_widget)

            button_diametro = widgets.Button(description="Siguiente - Selección DIÁMETRO")

            display(button_diametro)

           

            def on_diametro_button_clicked(_):

                selected = list(diametro_widget.value)

                selected_diametros = ["TODOS"] if not selected else selected

                show_tipo_accordion(selected_diametros)

            button_diametro.on_click(on_diametro_button_clicked)

   

    def show_tipo_accordion(selected_diametros):

        with output:

            print("\n--- Selección de TIPO para cada DIÁMETRO ---")

            df = df_baja_tubing

            tipo_widgets = {}

            children = []

            titles = []

            for d in selected_diametros:

                df_temp = df if d=="TODOS" else df[df['DIÁMETRO'] == d]

                unique_tipos = sorted([x for x in df_temp['TIPO'].unique() if x != "TODOS"])

                widget_t = widgets.SelectMultiple(

                    options=unique_tipos,

                    value=(),

                    description=f"TIPO ({d})",

                    layout=widgets.Layout(width='50%')

                )

                tipo_widgets[d] = widget_t

                children.append(widget_t)

                titles.append(f"DIÁMETRO: {d}")

            accordion = widgets.Accordion(children=children)

            for idx, title in enumerate(titles):

                accordion.set_title(idx, title)

            display(accordion)

            button_tipo = widgets.Button(description="Siguiente - Selección TIPO")

            display(button_tipo)

           

            def on_tipo_button_clicked(_):

                selected_tipos_dict = {}

                for d, widget_t in tipo_widgets.items():

                    st = list(widget_t.value)

                    if not st:

                        st = ["TODOS"]

                    selected_tipos_dict[d] = st

                show_diametro_csg_selection(selected_diametros, selected_tipos_dict)

            button_tipo.on_click(on_tipo_button_clicked)

   

    def show_diametro_csg_selection(selected_diametros, selected_tipos_dict):

        with output:

            print("\n--- Selección de DIÁMETRO CSG ---")

            df = df_baja_tubing

            union_tipos = set()

            for tlist in selected_tipos_dict.values():

                if tlist == ["TODOS"]:

                    union_tipos.add("TODOS")

                else:

                    union_tipos.update(tlist)

                    union_tipos.add("TODOS")

            diam_filter = ["TODOS"] if selected_diametros == ["TODOS"] else selected_diametros + ["TODOS"]

            df_filtered = df[df['DIÁMETRO'].isin(diam_filter) & df['TIPO'].isin(union_tipos)]

            unique_csg = sorted([x for x in df_filtered['DIÁMETRO CSG'].unique() if x != "TODOS"])

            if not unique_csg:

                print("Nota: Solo 'TODOS' disponible para DIÁMETRO CSG. Se procede automáticamente.")

                show_quantity_inputs(selected_diametros, selected_tipos_dict, ["TODOS"])

            else:

                csg_widget = widgets.Dropdown(

                    options=unique_csg,

                    value=unique_csg[0],

                    description="DIÁMETRO CSG",

                    layout=widgets.Layout(width='50%')

                )

                display(csg_widget)

                button_csg = widgets.Button(description="Siguiente - Selección DIÁMETRO CSG")

                display(button_csg)

               

                def on_csg_button_clicked(_):

                    selected_csg = csg_widget.value

                    selected_csg_filter = [selected_csg, "TODOS"] if selected_csg != "TODOS" else ["TODOS"]

                    show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter)

                button_csg.on_click(on_csg_button_clicked)

   

    def show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter):

        with output:

            print("\n--- Ingreso de Cantidades ---")

            df = df_baja_tubing

            quantity_widgets = {}

            qty_items = []

            for d in selected_diametros:

                for t in selected_tipos_dict[d]:

                    key = (d, t)

                    w = widgets.IntText(

                        value=0,

                        description=f"{d} - {t}:",

                        layout=widgets.Layout(width='400px')

                    )

                    quantity_widgets[key] = w

                    qty_items.append(w)

            quantity_box = widgets.VBox(qty_items)

            display(quantity_box)

            update_qty_button = widgets.Button(description="Aplicar Cantidades", button_style="success")

            display(update_qty_button)

           

            def on_update_qty(b2):

                for (d, t), qty_widget in quantity_widgets.items():

                    qty_value = qty_widget.value

                    if d == "TODOS":

                        continue

                    condition = (df["DIÁMETRO"].isin([d, "TODOS"]) & df["TIPO"].isin([t, "TODOS"]))

                    df.loc[condition & df["4.CANTIDAD"].isna(), "4.CANTIDAD"] = qty_value

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in selected_tipos_dict.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict:

                        cond = (df["DIÁMETRO"].isin([diam_value, "TODOS"]) & df["TIPO"].isin([tipo_val, "TODOS"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO C", final_df_renombrado))

                # print("Materiales del FLUJO C guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO D", button_style="success")

                def on_continue(b):

                    flujo_D()

                continue_button.on_click(on_continue)

                display(continue_button)

            update_qty_button.on_click(on_update_qty)

   

    def on_baja_tubing_change(change):

        if change['name'] == 'value' and change['new'] is not None:

            if change['new'] == 'SI':

                if load_excel():

                    show_diametro_selection()

            else:

                with output:

                    print("No se procede con Baja Tubing.")

                flujo_D()

    baja_tubing_widget.observe(on_baja_tubing_change, names='value')

   

# ===============================

# FLUJO D: Profundiza

# ===============================

def flujo_D():

    clear_output()

    print("FLUJO D: Profundiza")

    output = widgets.Output()

    file_path_prof = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\profundiza.xlsx"

    global df_prof

    df_prof = None

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_prof):

                print(f"El archivo no se encontró en la ruta:\n{file_path_prof}")

                return False

            try:

                df = pd.read_excel(file_path_prof)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DIÁMETRO CSG' in df.columns:

                    df['DIÁMETRO CSG'] = df['DIÁMETRO CSG'].replace('nan', '').fillna('')

                global df_prof

                df_prof = df.copy()

                print("Archivo cargado y limpiado con éxito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

    profundiza_widget = widgets.Dropdown(

        options=["seleccionar", "SI", "NO"],

        description="Profundizar:",

        value="seleccionar"

    )

    def on_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(output)

            if change['new'] == "SI":

                if load_excel():

                    if "DIÁMETRO" in df_prof.columns:

                        col_diametro = "DIÁMETRO"

                    elif "DIÁMETRO CSG" in df_prof.columns:

                        col_diametro = "DIÁMETRO CSG"

                    else:

                        with output:

                            print("La columna de DIÁMETRO no se encontró en el Excel.")

                        return

                    diametro_select = widgets.SelectMultiple(

                        options=df_prof[col_diametro].unique().tolist(),

                        description="DIÁMETRO",

                        rows=10

                    )

                    display(diametro_select)

                    confirm_button = widgets.Button(description="Confirmar selección")

                    output_area = widgets.Output()

                    def on_confirm(b):

                        with output_area:

                            clear_output()

                            selected_diametros = list(diametro_select.value)

                            if not selected_diametros:

                                print("No se seleccionaron diámetros.")

                                return

                            print("Ingrese la cantidad para cada DIÁMETRO seleccionado:")

                            numeric_widgets = {}

                            for d in selected_diametros:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1000000,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                            apply_button = widgets.Button(description="Aplicar cantidades")

                            def on_apply(b):

                                filtered_df = df_prof[df_prof[col_diametro].isin(selected_diametros)].copy()

                                for d in selected_diametros:

                                    cantidad = numeric_widgets[d].value

                                    filtered_df.loc[filtered_df[col_diametro] == d, "4.CANTIDAD"] = cantidad

                                final_df_renombrado = renombrar_columnas(filtered_df)

                                materiales_finales.append(("FLUJO D", final_df_renombrado))

                                # print("Materiales del FLUJO D guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO E", button_style="success")

                                def on_continue(b):

                                    flujo_E()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                            apply_button.on_click(on_apply)

                            display(apply_button)

                    confirm_button.on_click(on_confirm)

                    display(confirm_button, output_area)

            else:

                with output:

                    print("No se profundizará en la información.")

                flujo_E()

    profundiza_widget.observe(on_change)

    display(profundiza_widget)

    display(output)

 

# ===============================

# FLUJO E: Baja varillas

# ===============================

def flujo_E():

    clear_output()

    print("FLUJO E: Baja varillas")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¿Baja Varilla?",

        value="seleccionar"

    )

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja varillas.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DIÁMETRO"] = df["DIÁMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DIÁMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DIÁMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay TIPO disponibles. Se usará 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay valores para {columna}. Se usará 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DIÁMETRO: {diam_value}")

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DIÁMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DIÁMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO E", final_df_renombrado))

                # print("Materiales del FLUJO E guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO G", button_style="success")

                def on_continue(b):

                    flujo_G()

                continue_button.on_click(on_continue)

                display(continue_button)

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccionó NO en FLUJO E. Saltando a FLUJO F...")  # Desactivado

                flujo_F()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO F: Abandona pozo

# ===============================

def flujo_F():

    clear_output()

    print("FLUJO F: Abandona pozo")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\abandono-recupero.xlsx"

    global df_abandono

    df_abandono = None

    output = widgets.Output()

    question_widget = widgets.Dropdown(

        options=["NO", "SI"],

        value="NO",

        description="¿Abandono/recupero?:"

    )

    def filter_by_todos(df, column, selected_values):

        if "TODOS" in selected_values:

            return df

        else:

            allowed_values = list(selected_values) + ["TODOS"]

            return df[df[column].isin(allowed_values)]

    def on_question_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(question_widget, output)

            if change['new'] == "SI":

                with output:

                    # print("Cargando el Excel...")  # (Este print no está en la lista a desactivar, se mantiene)

                    if not os.path.exists(file_path):

                        print(f"No se encontró el archivo:\n{file_path}")

                        return

                    global df_abandono

                    try:

                        df_abandono = pd.read_excel(file_path)

                    except Exception as e:

                        print("Error al cargar el Excel:", e)

                        return

                    print("Archivo cargado exitosamente.")

                df_abandono.columns = df_abandono.columns.str.strip()

                for col in df_abandono.columns:

                    if df_abandono[col].dtype == object:

                        df_abandono[col] = df_abandono[col].astype(str).str.strip()

                if "DIÁMETRO" not in df_abandono.columns:

                    with output:

                        print("La columna 'DIÁMETRO' no existe en el Excel.")

                    return

                unique_diametros = df_abandono["DIÁMETRO"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros:

                    unique_diametros.insert(0, "TODOS")

                else:

                    unique_diametros.remove("TODOS")

                    unique_diametros.insert(0, "TODOS")

                if "DIÁMETRO CSG" not in df_abandono.columns:

                    with output:

                        print("La columna 'DIÁMETRO CSG' no existe en el Excel.")

                    return

                unique_diametros_csg = df_abandono["DIÁMETRO CSG"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros_csg:

                    unique_diametros_csg.insert(0, "TODOS")

                else:

                    unique_diametros_csg.remove("TODOS")

                    unique_diametros_csg.insert(0, "TODOS")

                diametro_multi = widgets.SelectMultiple(

                    options=unique_diametros,

                    value=["TODOS"],

                    description="DIÁMETRO:",

                    rows=6

                )

                diametro_csg_single = widgets.Dropdown(

                    options=unique_diametros_csg,

                    value="TODOS",

                    description="DIÁM CSG:"

                )

                confirm_button = widgets.Button(

                    description="Confirmar Filtros",

                    button_style="info"

                )

                next_output = widgets.Output()

                def on_confirm_filters(b):

                    with next_output:

                        clear_output()

                        selected_diametros = list(diametro_multi.value)

                        selected_diametro_csg = diametro_csg_single.value

                        filtered_df = df_abandono.copy()

                        filtered_df = filter_by_todos(filtered_df, "DIÁMETRO", selected_diametros)

                        filtered_df = filter_by_todos(filtered_df, "DIÁMETRO CSG", [selected_diametro_csg])

                        print("Filtrado Aplicado. A continuación, ingrese cantidades (solo para celdas vacías).")

                        numeric_widgets = {}

                        diametros_especificos = [d for d in selected_diametros if d != "TODOS"]

                        if diametros_especificos:

                            print("Ingrese la cantidad para cada DIÁMETRO seleccionado:")

                            for d in diametros_especificos:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1e9,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                        else:

                            print("No se seleccionaron diámetros específicos. No se solicitarán cantidades.")

                        apply_button = widgets.Button(

                            description="Aplicar Cantidades",

                            button_style="success"

                        )

                        final_output = widgets.Output()

                        def on_apply_quantities(btn):

                            with final_output:

                                clear_output()

                                if "4.CANTIDAD" not in df_abandono.columns:

                                    print("La columna '4.CANTIDAD' no existe en el Excel.")

                                    return

                                df_abandono["4.CANTIDAD"] = pd.to_numeric(df_abandono["4.CANTIDAD"], errors="coerce")

                                for d in diametros_especificos:

                                    qty = numeric_widgets[d].value

                                    mask_diam = (df_abandono["DIÁMETRO"] == d)

                                    mask_nan = df_abandono["4.CANTIDAD"].isna()

                                    df_abandono.loc[mask_diam & mask_nan, "4.CANTIDAD"] = qty

                                filtered_final = df_abandono.copy()

                                filtered_final = filter_by_todos(filtered_final, "DIÁMETRO", selected_diametros)

                                filtered_final = filter_by_todos(filtered_final, "DIÁMETRO CSG", [selected_diametro_csg])

                                print("Listado Final Filtrado:")

                                filtered_final_renombrado = renombrar_columnas(filtered_final)

                                materiales_finales.append(("FLUJO F", filtered_final_renombrado))

                                # print("Materiales del FLUJO F guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                                def on_continue(b):

                                    flujo_H()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                        apply_button.on_click(on_apply_quantities)

                        display(apply_button, final_output)

                confirm_button.on_click(on_confirm_filters)

                display(diametro_multi, diametro_csg_single, confirm_button, next_output)

            else:

                with output:

                    # print("No se realizará la acción. Saltando a FLUJO H...")  # Desactivado

                    pass

                flujo_H()

    question_widget.observe(on_question_change, names='value')

    display(question_widget, output)

 

 

# ===============================

# FLUJO G: Instalación BM

# ===============================

def flujo_G():

    clear_output()

    print("FLUJO G: Instalación BM")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\WO.xlsx"

    pregunta_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¿WO a BM?",

        value="seleccionar"

    )

    def mostrar_materiales(change):

        clear_output()

        display(pregunta_widget)

        if change['new'] == "SI":

            try:

                df = pd.read_excel(file_path)

                print("Lista de materiales:")

                df_renombrado = renombrar_columnas(df)

                materiales_finales.append(("FLUJO G", df_renombrado))

                # print("Materiales del FLUJO G guardados.")  # Desactivado

            except Exception as e:

                print("Error al cargar Excel:", e)

            continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

            def on_continue(b):

                flujo_H()

            continue_button.on_click(on_continue)

            display(continue_button)

        elif change['new'] == "NO":

            print("No se mostrarán los materiales.")

            flujo_H()

    pregunta_widget.observe(mostrar_materiales, names='value')

    display(pregunta_widget)

 

def flujo_H():

    clear_output()

    print("=== FLUJO H: Material de agregación ===")

    try:

        file_path_H = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\GENERAL(1).xlsx"

        df_H = pd.read_excel(file_path_H)

        df_H.columns = df_H.columns.str.strip()

        if "4.CANTIDAD" not in df_H.columns:

            df_H["4.CANTIDAD"] = 0

    except Exception as e:

        print("Error al cargar el Excel:", e)

        df_H = pd.DataFrame()

   

    pregunta_widget_H = widgets.RadioButtons(

        options=["Seleccionar", "SI", "NO"],

        description="¿Agregar más material?",

        value="Seleccionar"

    )

    output_container_H = widgets.Output()

 

    apply_selection_button_H = widgets.Button(description="Aplicar selección", button_style="info")

    apply_qty_button_H = widgets.Button(description="Asignar cantidades", button_style="success")

   

    final_list_button = widgets.Button(description="Mostrar Listado Final de Materiales", button_style="warning")

    final_button_container = widgets.VBox([final_list_button])

   

    def on_show_final_list(b):

        clear_output()

        print("Listado final de materiales de todos los flujos ejecutados:")

        for flow, df in materiales_finales:

            print(f"\n---- {flow} ----")

            display(df)

    final_list_button.on_click(on_show_final_list)

   

    if not df_H.empty and "2. MATERIAL" in df_H.columns:

        materiales = df_H["2. MATERIAL"].astype(str).unique().tolist()

    else:

        materiales = []

    materiales_widget_H = widgets.SelectMultiple(

        options=materiales,

        description="Materiales",

        layout=widgets.Layout(width='50%', height='150px')

    )

    qty_widgets_H = {}

   

    def on_apply_selection_H(b):

        with output_container_H:

            clear_output()

            seleccionados = list(materiales_widget_H.value)

            if not seleccionados:

                print("No se seleccionó ningún material.")

                return

            print("Materiales seleccionados:")

            for mat in seleccionados:

                print("-", mat)

            qty_widgets_H.clear()

            input_boxes = []

            for mat in seleccionados:

                qty_box = widgets.BoundedFloatText(

                    value=0,

                    min=0,

                    step=1,

                    description=f"Cant: {mat}",

                    layout=widgets.Layout(width='50%')

                )

                qty_widgets_H[mat] = qty_box

                input_boxes.append(qty_box)

            display(widgets.VBox(input_boxes))

            display(apply_qty_button_H)

   

    def on_apply_qty_H(b):

        with output_container_H:

            clear_output()

            if df_H.empty:

                print("El DataFrame está vacío o no se cargó correctamente.")

                return

            selected_materials = list(qty_widgets_H.keys())

            for mat, widget_box in qty_widgets_H.items():

                cant = widget_box.value

                df_H.loc[df_H["2. MATERIAL"].astype(str) == mat, "4.CANTIDAD"] = cant

            assigned_df = df_H[

                df_H["2. MATERIAL"].astype(str).isin(selected_materials) &

                (df_H["4.CANTIDAD"] > 0)

            ]

            if not assigned_df.empty:

                assigned_df_renombrado = renombrar_columnas(assigned_df)

                materiales_finales.append(("FLUJO H", assigned_df_renombrado))

                # print("Materiales del FLUJO H guardados.")  # Desactivado

            else:

                print("No se asignaron cantidades (o todas fueron 0).")

           

            display(final_button_container)

   

    def on_pregunta_change_H(change):

        with output_container_H:

            clear_output()

            if change['new'] == "SI":

                if df_H.empty:

                    print("El DataFrame no se cargó o está vacío.")

                    return

                print("Lista completa de materiales del Excel:\n")

                display(df_H)

                print("\nSeleccione los materiales que desea agregar:")

                display(materiales_widget_H)

                display(apply_selection_button_H)

            elif change['new'] == "NO":

                print("No se agregarán más materiales.")

                display(final_button_container)

   

    pregunta_widget_H.observe(on_pregunta_change_H, names='value')

    apply_selection_button_H.on_click(on_apply_selection_H)

    apply_qty_button_H.on_click(on_apply_qty_H)

   

    display(pregunta_widget_H)

    display(output_container_H)

   

    # print("FLUJO H finalizado. Fin del proceso.")  # Desactivado

 

 

# ===============================

# Función principal: inicia en FLUJO A

# ===============================

def main():

    flujo_A()

 

# Inicia el proceso

main()
```

## docs/Estructura del proyecto.md

- Characters: 6225
- Tokens: 0

```markdown
🔹 1. Introducción
Este documento detalla la arquitectura propuesta para la implementación de un sistema de flujos modulares en una aplicación basada en Python y Flask. El objetivo es permitir la ejecución de múltiples flujos de trabajo (Flujo A, B, C, etc.), en los cuales cada flujo es un módulo independiente que recibe entradas del usuario, filtra datos de archivos Excel, y proporciona salidas que pueden afectar a los siguientes flujos.

🔹 2. Análisis Inicial del Problema
El código original consistía en una serie de filtros aplicados secuencialmente sobre distintos archivos de datos. Cada flujo:

Preguntaba al usuario si debía ejecutarse.
Aplicaba filtros a un conjunto de datos en función de la respuesta.
Mostraba los materiales resultantes.
Determinaba el siguiente flujo a ejecutar.
📌 Conclusión: La lógica de cada flujo era principalmente un filtro condicional sobre un conjunto de datos basado en respuestas del usuario.

Problemas detectados en la implementación inicial
❌ Código monolítico y difícil de extender.
❌ Falta de modularidad: cada flujo estaba acoplado a la lógica general.
❌ No había un manejo centralizado del estado y flujo de datos.

🔹 3. Patrón de Diseño Elegido
Se adoptó una arquitectura basada en plugins combinada con un manejo centralizado del flujo utilizando Flask Sessions. Esto permite:

📌 Modularidad: Cada flujo es un plugin independiente que puede añadirse sin modificar la estructura general.
📌 Flexibilidad: El orden de ejecución se define externamente y no dentro de cada módulo.
📌 Escalabilidad: Es fácil agregar nuevos flujos sin afectar el sistema.
📌 Manejo de Estado: Se utiliza Flask Sessions para almacenar respuestas y materiales seleccionados.
🔹 Patrón de diseño:
Plugin-Based Architecture + State Management
Cada flujo actúa como un plugin independiente y el sistema maneja las transiciones y datos entre ellos.

🔹 4. Arquitectura Resultante
📂 Estructura del Proyecto
bash
Copy
Edit
/app
  ├── main.py               # Punto de entrada de la aplicación
  ├── flujo_loader.py       # Carga y gestiona los flujos dinámicamente
  ├── plugins/              # Módulos independientes de cada flujo
  │   ├── __init__.py
  │   ├── flujo_a.py        # Flujo A
  │   ├── flujo_b.py        # Flujo B
  │   ├── flujo_c.py        # Flujo C
  │   ├── flujo_d.py        # Flujo D
  │   ├── flujo_e.py        # Flujo E
  │   ├── flujo_f.py        # Flujo F
  │   ├── flujo_g.py        # Flujo G
  │   ├── flujo_h.py        # Flujo H (siempre se ejecuta)
  ├── templates/            # HTML para la interfaz de usuario
  │   ├── base.html
  │   ├── index.html
  │   ├── flujo.html        # Página genérica para cada flujo
  │   ├── resultados.html   # Página de resultados finales
  ├── static/               # Archivos CSS y JS
  ├── data/                 # Archivos Excel
  ├── requirements.txt
  └── README.md
🔹 5. Manejo del Flujo de Ejecución
En lugar de definir el orden de los flujos dentro de cada módulo, se utiliza un diccionario de transición que maneja la lógica centralmente.

📌 Configuración de flujos en flujo_loader.py

python
Copy
Edit
SECUENCIA_FLUJOS = {
    "A": {"SI": "H", "NO": "B"},
    "B": {"SI": "C", "NO": "C"},
    "C": {"SI": "D", "NO": "D"},
    "D": {"SI": "E", "NO": "E"},
    "E": {"SI": "G", "NO": "F"},
    "F": {"SI": "H", "NO": "H"},
    "G": {"SI": "H", "NO": "H"},
    "H": None  # Último flujo
}
📌 Cómo funciona:

Cada flujo tiene una entrada (respuesta del usuario).
Se determina el siguiente flujo basado en la respuesta (SI o NO).
Los datos de cada flujo se almacenan en session para ser utilizados en flujos posteriores.
🔹 6. Ejemplo de Flujo Individual
Cada flujo es un módulo independiente en la carpeta plugins/.

📌 Ejemplo de plugins/flujo_a.py

python
Copy
Edit
from flask import render_template, request

nombre = "A"

def ejecutar():
    if request.method == "POST":
        respuesta = request.form.get("respuesta")
        materiales_seleccionados = ["Material X", "Material Y"] if respuesta == "SI" else []
        return respuesta, materiales_seleccionados

    return render_template("flujo.html", flujo=nombre)
📌 Explicación:

Cada flujo recibe una entrada (POST del usuario).
Si el usuario responde "SI", filtra materiales y los guarda.
Si el usuario responde "NO", se salta el procesamiento.
El sistema decide cuál es el siguiente flujo.
🔹 7. Manejo del Estado Global
Se utiliza Flask Sessions para mantener los datos entre flujos.

📌 Ejemplo de cómo se almacenan los datos en session

python
Copy
Edit
@app.route("/flujo/<nombre_flujo>", methods=["GET", "POST"])
def flujo(nombre_flujo):
    if nombre_flujo in flujos:
        respuesta, materiales, siguiente_flujo = ejecutar_flujo(nombre_flujo, session)

        # Guardar en sesión
        session[nombre_flujo] = {"respuesta": respuesta, "materiales": materiales}

        # Continuar al siguiente flujo o finalizar
        return redirect(url_for("flujo", nombre_flujo=siguiente_flujo)) if siguiente_flujo else redirect(url_for("resultados"))

    return redirect(url_for("index"))
📌 Beneficios del uso de session ✔ Permite almacenar datos persistentes sin base de datos.
✔ Mantiene la continuidad entre flujos.
✔ Hace que cada flujo sea independiente sin necesidad de modificar otros flujos.

🔹 8. Beneficios de la Arquitectura
Característica	Beneficio
Plugins Modulares	Se pueden agregar nuevos flujos sin modificar main.py.
Configuración Centralizada	El orden de ejecución se define en flujo_loader.py.
Manejo de Estado con session	Cada flujo puede acceder a respuestas y materiales previos.
Separación de Responsabilidades	main.py maneja la app, flujo_loader.py los flujos, y los plugins contienen la lógica específica.
Escalabilidad	Fácil de expandir sin modificar el código existente.
🔹 9. Conclusión
Se pasó de una estructura monolítica a una arquitectura basada en plugins donde:

Cada flujo es un módulo autónomo con entrada y salida.
El flujo de ejecución es gestionado dinámicamente.
Se utiliza session para almacenar respuestas y datos.
Los desarrolladores pueden agregar nuevos flujos sin modificar la estructura base.
Este modelo permite escalabilidad, modularidad y facilidad de mantenimiento, alineándose con buenas prácticas de arquitectura de software.
```

## README.md

- Characters: 1903
- Tokens: 0

```markdown
# Visualizador de Excel

Esta aplicación simple permite visualizar archivos Excel como tablas HTML en un navegador web.

## Requisitos

- Python 3.6 o superior
- pip (gestor de paquetes de Python)

## Instalación

1. Clona o descarga este repositorio
2. Instala las dependencias:

# Configuración y ejecución en VS Code (Windows)
Requisitos previos

Python 3.6 o superior
pip (gestor de paquetes de Python)

Pasos para ejecutar la aplicación
1. Clonar el repositorio
Copygit clone [URL_DEL_REPOSITORIO]
cd mi_app
2. Crear y activar un entorno virtual
Copy# Crear entorno virtual
python -m venv venv

# Activar el entorno virtual
venv\Scripts\activate
3. Instalar dependencias
Copy# Instalar todas las dependencias necesarias
pip install flask==2.3.3 openpyxl==3.1.2 pandas xlrd==2.0.1
4. Preparar los archivos Excel

Coloca tus archivos Excel (.xlsx o .xls) en la carpeta app/data/
Si la carpeta no existe, se creará automáticamente al iniciar la aplicación

5. Ejecutar la aplicación
Copy# Navegar a la carpeta app
cd app

# Iniciar la aplicación
python main.py
6. Acceder a la aplicación

Abre tu navegador y navega a: http://127.0.0.1:5000
Verás todos los archivos Excel cargados y podrás iniciar los flujos de trabajo

7. Desactivar el entorno virtual cuando termines
Copydeactivate
Solución de problemas comunes

Error "No module named...": Verifica que el entorno virtual esté activado y que todas las dependencias estén instaladas
Archivos Excel no visibles: Asegúrate de que estén en la carpeta correcta (app/data/) y tengan la extensión correcta (.xlsx o .xls)

3. Abre tu navegador y ve a `http://localhost:5000`

## Notas

- La aplicación mostrará todos los archivos Excel (.xlsx o .xls) encontrados en la carpeta `data`
- Cada archivo se convertirá en una tabla HTML
- Puedes recargar la página para actualizar los datos si agregas nuevos archivos Excel mientras la aplicación está corriendo
```

## .gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## Statistics

- Total Files: 21
- Total Characters: 150879
- Total Tokens: 0
`````

## docs/Flujo A - Doc tecnico.md

- Characters: 2871
- Tokens: 0

```markdown
📌 Especificación Técnica para Desarrollo – FLUJO A (Ajuste de Medida)
1️⃣ Descripción General
FLUJO A permite al usuario seleccionar materiales basados en criterios específicos de ajuste de medida. Si el usuario acepta el ajuste, el flujo filtra los materiales y salta directamente a FLUJO H. Si el usuario rechaza, salta a FLUJO B sin procesar datos.

2️⃣ Datos de Entrada
La información proviene de una tabla estructurada (ajuste_de_medida.xlsx), con las siguientes columnas clave:

Columna	Tipo	Descripción
DIÁMETRO	string	Diámetro del material
TIPO	string	Tipo de material
GRADO DE ACERO	string	Grado de acero
GRADO DE ACERO CUPLA	string	Grado de acero de la cupla
TIPO DE CUPLA	string	Tipo de cupla
4.CANTIDAD	float	Cantidad del material (opcional)
3️⃣ Flujo de Ejecución
Pregunta al usuario:

Si responde "NO" → Salta directamente a FLUJO B.
Si responde "SÍ" → Carga la tabla y aplica filtros.
Carga y Filtrado de Datos:

Carga la tabla ajuste_de_medida.xlsx y limpia valores.
El usuario selecciona valores en los siguientes filtros:
DIÁMETRO
TIPO
GRADO DE ACERO
GRADO DE ACERO CUPLA
TIPO DE CUPLA
Si el usuario no selecciona un valor, se usa "TODOS" como fallback.
Construcción de final_condition (máscara booleana de filtrado):

Inicializa final_condition con False para excluir todos los registros.
Para cada DIÁMETRO seleccionado, evalúa si los materiales cumplen con los criterios del usuario.
Incluye "TODOS" en cada filtro para garantizar que los valores no seleccionados no eliminen registros útiles.
Se combinan las condiciones (| lógico) para crear el filtro final.
Aplicación del Filtro:

python
Copy
Edit
final_df = df[final_condition]
Solo quedan los materiales que cumplen con los criterios del usuario.
Almacena los materiales filtrados en materiales_finales:

python
Copy
Edit
materiales_finales.append(("FLUJO A", final_df_renombrado))
Salto a FLUJO H (el flujo no sigue la secuencia normal):

Si el usuario ejecuta FLUJO A, no sigue a FLUJO B, sino directamente a FLUJO H.
4️⃣ Consideraciones Técnicas
✔ No modifica la estructura de la tabla, solo aplica filtros.
✔ Debe permitir múltiples selecciones en cada filtro.
✔ Evita pérdida de datos con "TODOS" en cada condición.
✔ Encapsular final_condition como lógica reutilizable para otros flujos.
✔ Optimizar el acceso a archivos si se requiere ejecución frecuente.

📌 Resumen Final
FLUJO A solo se ejecuta si el usuario dice "SÍ".
Carga una tabla de materiales y filtra datos según selección del usuario.
Almacena los materiales seleccionados y salta directamente a FLUJO H.
Si el usuario dice "NO", salta a FLUJO B sin procesar nada.
final_condition es el mecanismo que define qué materiales quedan en la selección final.
🚀 Resultado esperado: Un módulo optimizado que procesa materiales en base a filtros dinámicos y garantiza la continuidad del flujo sin interrumpir la secuencia de ejecución.
```

## docs/commentarios del proy.md

- Characters: 52736
- Tokens: 0

```markdown
engo varios códigos por separado que representan diferentes flujos para la selección de materiales en la intervención de un pozo petrolero: FLUJO A, FLUJO B, FLUJO C, FLUJO D, FLUJO E, FLUJO F, FLUJO G y FLUJO H. Cada uno de ellos inicia con una pregunta que, si el usuario responde “NO”, salta inmediatamente al siguiente flujo; y si el usuario responde “SÍ”, entonces ejecuta su lógica, imprime una lista de materiales y luego avanza al siguiente flujo.

Los flujos se llaman y se encadenan de la siguiente forma:

FLUJO A (Ajuste de medida)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO H.
Si el usuario responde NO , salta a FLUJO B.
FLUJO B (Tubo de saca)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO C.
Si el usuario responde NO , salta a FLUJO C.
FLUJO C (tubería de Baja)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO D.
Si el usuario responde NO , salta a FLUJO D.
FLUJO D (Profundiza)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO E.
Si el usuario responde NO , salta a FLUJO E.
FLUJO E (Baja varillas)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO G.
Luego de terminar FLUJO G , debe continuar a FLUJO H .
Si el usuario responde NO , salta a FLUJO F , y al terminar FLUJO F , avanza a FLUJO H.
FLUJO F (Abandona pozo)
Luego de terminar (sea cual sea la respuesta, si aplica), avanza a FLUJO H .
FLUJO G (Instalación BM)
Cuando termine este flujo, avanza a FLUJO H.
FLUJO H (Material de agregación)
No es condicional: se supone que, al llegar aquí, se ejecuta y finaliza.
El resultado deseado es un único script de Python que combina estos ocho flujos en el orden descrito y respeta las condiciones de salto (SÍ/NO). Cada flujo debe:

Preguntar al usuario si desea ejecutar ese flujo (excepto FLUJO H, que siempre se ejecuta al llegar).
Si responde SÍ: ejecute la lógica interna de ese flujo (por ejemplo, las preguntas o procesos que incluían), e imprima la lista de materiales correspondientes.
Terminar ese flujo y, en lugar de salirse del programa, encadenar inmediatamente con el siguiente flujo indicado.
Si responde NO: saltarse la ejecución de ese flujo (no imprime materiales) y avanzar al siguiente flujo, salvo en el caso de FLUJO A y FLUJO E, que ya tienen desvíos particulares a otros flujos.


EL CODIGO EJECUTADO EN JUPYTER ES: ESTA UN POCO DESPROLIJO, PERO BUENO AL MENOS FUNCIONA


import os

import pandas as pd

import ipywidgets as widgets

from IPython.display import display, clear_output

 

# Variable global para almacenar los DataFrames finales de cada flujo

materiales_finales = []

 

# Función para renombrar las columnas y dejar solo las 5 requeridas

def renombrar_columnas(df):

    df_renombrado = df.rename(

        columns={

            "1. Cód.SAP": "Cód.SAP",

            "2. MATERIAL": "MATERIAL",

            "3. Descripción": "Descripción",

            "5.CONDICIÓN": "CONDICIÓN"

        }

    )

    # Asegurarse de que queden las siguientes columnas

    columnas = ["Cód.SAP", "MATERIAL", "Descripción", "4.CANTIDAD", "CONDICIÓN"]

    columnas_presentes = [col for col in columnas if col in df_renombrado.columns]

    return df_renombrado[columnas_presentes]

 

# ===============================

# FLUJO A: Ajuste de medida

# ===============================

def flujo_A():

    clear_output()

    print("FLUJO A: Ajuste de medida")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¿Ajuste de medida?",

        value="seleccionar"

    )

   

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\ajuste de medida.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DIÁMETRO"] = df["DIÁMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DIÁMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DIÁMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

       

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay TIPO disponibles. Se usará 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

       

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay valores para {columna}. Se usará 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

       

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DIÁMETRO: {diam_value}")

       

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

       

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

       

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DIÁMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False] * len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False] * len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DIÁMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                # En lugar de mostrar inmediatamente, se almacena el DataFrame renombrado

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO A", final_df_renombrado))

                # print("Materiales del FLUJO A guardados.")  # Desactivado

               

                # Botón para continuar a FLUJO H (ya que en FLUJO A si se responde SI se salta directamente a H)

                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                def on_continue(b):

                    flujo_H()

                continue_button.on_click(on_continue)

                display(continue_button)

       

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccionó NO en FLUJO A. Saltando a FLUJO B...")  # Desactivado

                flujo_B()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO B: Tubo de saca

# ===============================

def flujo_B():

    clear_output()

    print("FLUJO B: Tubo de saca")

    folder_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales"

    filename_saca = "saca tubing.xlsx"

    file_path_saca = os.path.join(folder_path, filename_saca)

    global df_saca_tubing

    df_saca_tubing = None

 

    def load_saca_tubing_excel():

        global df_saca_tubing

        if not os.path.exists(file_path_saca):

            print(f"El archivo {file_path_saca} no se encontró.")

            return

        df_tmp = pd.read_excel(file_path_saca)

        df_tmp.columns = df_tmp.columns.str.strip()

        for c in df_tmp.columns:

            if df_tmp[c].dtype == object:

                df_tmp[c] = df_tmp[c].astype(str).str.strip()

        df_saca_tubing = df_tmp.copy()

        diametro_multi_picker.options = sorted(

            [d for d in df_saca_tubing['DIÁMETRO'].unique() if d.upper() != 'TODOS']

        )

 

    diametro_multi_picker = widgets.SelectMultiple(

        options=[],

        description='DIÁMETRO:',

        style={'description_width': 'initial'}

    )

    confirm_diameter_button = widgets.Button(

        description='Confirmar diámetros',

        button_style='info'

    )

    quantities_container = widgets.VBox()

    final_output = widgets.Output()

    show_table_button = widgets.Button(

        description='Mostrar tabla final',

        button_style='success'

    )

 

    def on_show_table_button_clicked(b):

        with final_output:

            clear_output()

            if df_saca_tubing is None:

                print("No hay datos cargados de saca tubing.")

                return

            selected_diameters = list(diametro_multi_picker.value)

            df_filtered = df_saca_tubing[

                (df_saca_tubing['DIÁMETRO'].isin(selected_diameters)) |

                (df_saca_tubing['DIÁMETRO'].str.upper() == 'TODOS')

            ].copy()

            for child in quantities_container.children:

                dia = child.description

                cantidad = child.value

                mask = (df_filtered['DIÁMETRO'] == dia)

                df_filtered.loc[mask, '4.CANTIDAD'] = cantidad

            df_filtered_renombrado = renombrar_columnas(df_filtered)

            materiales_finales.append(("FLUJO B", df_filtered_renombrado))

            print("Materiales del FLUJO B guardados.")

 

        # Cierra la interfaz de FLUJO B

        multi_select_container.close()

 

        # Muestra el botón para continuar al FLUJO C

        continue_button = widgets.Button(

            description="Continuar a FLUJO C",

            button_style="success"

        )

        def on_continue(b):

            clear_output()

            flujo_C()

        continue_button.on_click(on_continue)

        display(continue_button)

 

    show_table_button.on_click(on_show_table_button_clicked)

 

    def on_confirm_diameter_button_clicked(b):

        with final_output:

            clear_output()

        quantities_container.children = []

        for dia in diametro_multi_picker.value:

            qty_widget = widgets.IntText(

                value=0,

                description=dia,

                style={'description_width': 'initial'}

            )

            quantities_container.children += (qty_widget,)

 

    confirm_diameter_button.on_click(on_confirm_diameter_button_clicked)

 

    multi_select_container = widgets.VBox([

        diametro_multi_picker,

        confirm_diameter_button,

        quantities_container,

        show_table_button,

        final_output

    ])

 

    bajara_tubing_picker = widgets.Dropdown(

        options=["Seleccione opción", "SI", "NO"],

        value="Seleccione opción",

        description="¿saca Tubing?:"

    )

 

    def on_bajara_tubing_change(change):

        clear_output()

        if change['new'] == "SI":

            load_saca_tubing_excel()

            display(multi_select_container)

        elif change['new'] == "NO":

            print("No se saca tubing.")

            flujo_C()

 

    bajara_tubing_picker.observe(on_bajara_tubing_change, names='value')

 

    print("¿Saca Tubing?")

    display(bajara_tubing_picker)

 

# ===============================

# FLUJO C: Tubería de Baja

# ===============================

def flujo_C():

    clear_output()

    print("FLUJO C: Tubería de Baja")

    file_path_baja = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja tubing.xlsx"

    global df_baja_tubing

    df_baja_tubing = None

    output = widgets.Output()

    baja_tubing_widget = widgets.ToggleButtons(

        options=['SI', 'NO'],

        description='¿Baja Tubing?',

        disabled=False,

        value=None

    )

    display(baja_tubing_widget, output)

   

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_baja):

                print(f"El archivo no se encontró en la ruta:\n{file_path_baja}")

                return False

            try:

                df = pd.read_excel(file_path_baja)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DIÁMETRO CSG' in df.columns:

                    df['DIÁMETRO CSG'] = df['DIÁMETRO CSG'].replace('nan', '').fillna('')

                global df_baja_tubing

                df_baja_tubing = df.copy()

                print("Archivo cargado y limpiado con éxito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

   

    def show_diametro_selection():

        with output:

            print("\n--- Selección de DIÁMETRO ---")

            df = df_baja_tubing

            unique_diametros = sorted([x for x in df['DIÁMETRO'].unique() if x != "TODOS"])

            diametro_widget = widgets.SelectMultiple(

                options=unique_diametros,

                value=(),

                description="DIÁMETRO",

                layout=widgets.Layout(width='50%')

            )

            display(diametro_widget)

            button_diametro = widgets.Button(description="Siguiente - Selección DIÁMETRO")

            display(button_diametro)

           

            def on_diametro_button_clicked(_):

                selected = list(diametro_widget.value)

                selected_diametros = ["TODOS"] if not selected else selected

                show_tipo_accordion(selected_diametros)

            button_diametro.on_click(on_diametro_button_clicked)

   

    def show_tipo_accordion(selected_diametros):

        with output:

            print("\n--- Selección de TIPO para cada DIÁMETRO ---")

            df = df_baja_tubing

            tipo_widgets = {}

            children = []

            titles = []

            for d in selected_diametros:

                df_temp = df if d=="TODOS" else df[df['DIÁMETRO'] == d]

                unique_tipos = sorted([x for x in df_temp['TIPO'].unique() if x != "TODOS"])

                widget_t = widgets.SelectMultiple(

                    options=unique_tipos,

                    value=(),

                    description=f"TIPO ({d})",

                    layout=widgets.Layout(width='50%')

                )

                tipo_widgets[d] = widget_t

                children.append(widget_t)

                titles.append(f"DIÁMETRO: {d}")

            accordion = widgets.Accordion(children=children)

            for idx, title in enumerate(titles):

                accordion.set_title(idx, title)

            display(accordion)

            button_tipo = widgets.Button(description="Siguiente - Selección TIPO")

            display(button_tipo)

           

            def on_tipo_button_clicked(_):

                selected_tipos_dict = {}

                for d, widget_t in tipo_widgets.items():

                    st = list(widget_t.value)

                    if not st:

                        st = ["TODOS"]

                    selected_tipos_dict[d] = st

                show_diametro_csg_selection(selected_diametros, selected_tipos_dict)

            button_tipo.on_click(on_tipo_button_clicked)

   

    def show_diametro_csg_selection(selected_diametros, selected_tipos_dict):

        with output:

            print("\n--- Selección de DIÁMETRO CSG ---")

            df = df_baja_tubing

            union_tipos = set()

            for tlist in selected_tipos_dict.values():

                if tlist == ["TODOS"]:

                    union_tipos.add("TODOS")

                else:

                    union_tipos.update(tlist)

                    union_tipos.add("TODOS")

            diam_filter = ["TODOS"] if selected_diametros == ["TODOS"] else selected_diametros + ["TODOS"]

            df_filtered = df[df['DIÁMETRO'].isin(diam_filter) & df['TIPO'].isin(union_tipos)]

            unique_csg = sorted([x for x in df_filtered['DIÁMETRO CSG'].unique() if x != "TODOS"])

            if not unique_csg:

                print("Nota: Solo 'TODOS' disponible para DIÁMETRO CSG. Se procede automáticamente.")

                show_quantity_inputs(selected_diametros, selected_tipos_dict, ["TODOS"])

            else:

                csg_widget = widgets.Dropdown(

                    options=unique_csg,

                    value=unique_csg[0],

                    description="DIÁMETRO CSG",

                    layout=widgets.Layout(width='50%')

                )

                display(csg_widget)

                button_csg = widgets.Button(description="Siguiente - Selección DIÁMETRO CSG")

                display(button_csg)

               

                def on_csg_button_clicked(_):

                    selected_csg = csg_widget.value

                    selected_csg_filter = [selected_csg, "TODOS"] if selected_csg != "TODOS" else ["TODOS"]

                    show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter)

                button_csg.on_click(on_csg_button_clicked)

   

    def show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter):

        with output:

            print("\n--- Ingreso de Cantidades ---")

            df = df_baja_tubing

            quantity_widgets = {}

            qty_items = []

            for d in selected_diametros:

                for t in selected_tipos_dict[d]:

                    key = (d, t)

                    w = widgets.IntText(

                        value=0,

                        description=f"{d} - {t}:",

                        layout=widgets.Layout(width='400px')

                    )

                    quantity_widgets[key] = w

                    qty_items.append(w)

            quantity_box = widgets.VBox(qty_items)

            display(quantity_box)

            update_qty_button = widgets.Button(description="Aplicar Cantidades", button_style="success")

            display(update_qty_button)

           

            def on_update_qty(b2):

                for (d, t), qty_widget in quantity_widgets.items():

                    qty_value = qty_widget.value

                    if d == "TODOS":

                        continue

                    condition = (df["DIÁMETRO"].isin([d, "TODOS"]) & df["TIPO"].isin([t, "TODOS"]))

                    df.loc[condition & df["4.CANTIDAD"].isna(), "4.CANTIDAD"] = qty_value

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in selected_tipos_dict.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict:

                        cond = (df["DIÁMETRO"].isin([diam_value, "TODOS"]) & df["TIPO"].isin([tipo_val, "TODOS"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO C", final_df_renombrado))

                # print("Materiales del FLUJO C guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO D", button_style="success")

                def on_continue(b):

                    flujo_D()

                continue_button.on_click(on_continue)

                display(continue_button)

            update_qty_button.on_click(on_update_qty)

   

    def on_baja_tubing_change(change):

        if change['name'] == 'value' and change['new'] is not None:

            if change['new'] == 'SI':

                if load_excel():

                    show_diametro_selection()

            else:

                with output:

                    print("No se procede con Baja Tubing.")

                flujo_D()

    baja_tubing_widget.observe(on_baja_tubing_change, names='value')

   

# ===============================

# FLUJO D: Profundiza

# ===============================

def flujo_D():

    clear_output()

    print("FLUJO D: Profundiza")

    output = widgets.Output()

    file_path_prof = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\profundiza.xlsx"

    global df_prof

    df_prof = None

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_prof):

                print(f"El archivo no se encontró en la ruta:\n{file_path_prof}")

                return False

            try:

                df = pd.read_excel(file_path_prof)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DIÁMETRO CSG' in df.columns:

                    df['DIÁMETRO CSG'] = df['DIÁMETRO CSG'].replace('nan', '').fillna('')

                global df_prof

                df_prof = df.copy()

                print("Archivo cargado y limpiado con éxito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

    profundiza_widget = widgets.Dropdown(

        options=["seleccionar", "SI", "NO"],

        description="Profundizar:",

        value="seleccionar"

    )

    def on_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(output)

            if change['new'] == "SI":

                if load_excel():

                    if "DIÁMETRO" in df_prof.columns:

                        col_diametro = "DIÁMETRO"

                    elif "DIÁMETRO CSG" in df_prof.columns:

                        col_diametro = "DIÁMETRO CSG"

                    else:

                        with output:

                            print("La columna de DIÁMETRO no se encontró en el Excel.")

                        return

                    diametro_select = widgets.SelectMultiple(

                        options=df_prof[col_diametro].unique().tolist(),

                        description="DIÁMETRO",

                        rows=10

                    )

                    display(diametro_select)

                    confirm_button = widgets.Button(description="Confirmar selección")

                    output_area = widgets.Output()

                    def on_confirm(b):

                        with output_area:

                            clear_output()

                            selected_diametros = list(diametro_select.value)

                            if not selected_diametros:

                                print("No se seleccionaron diámetros.")

                                return

                            print("Ingrese la cantidad para cada DIÁMETRO seleccionado:")

                            numeric_widgets = {}

                            for d in selected_diametros:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1000000,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                            apply_button = widgets.Button(description="Aplicar cantidades")

                            def on_apply(b):

                                filtered_df = df_prof[df_prof[col_diametro].isin(selected_diametros)].copy()

                                for d in selected_diametros:

                                    cantidad = numeric_widgets[d].value

                                    filtered_df.loc[filtered_df[col_diametro] == d, "4.CANTIDAD"] = cantidad

                                final_df_renombrado = renombrar_columnas(filtered_df)

                                materiales_finales.append(("FLUJO D", final_df_renombrado))

                                # print("Materiales del FLUJO D guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO E", button_style="success")

                                def on_continue(b):

                                    flujo_E()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                            apply_button.on_click(on_apply)

                            display(apply_button)

                    confirm_button.on_click(on_confirm)

                    display(confirm_button, output_area)

            else:

                with output:

                    print("No se profundizará en la información.")

                flujo_E()

    profundiza_widget.observe(on_change)

    display(profundiza_widget)

    display(output)

 

# ===============================

# FLUJO E: Baja varillas

# ===============================

def flujo_E():

    clear_output()

    print("FLUJO E: Baja varillas")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¿Baja Varilla?",

        value="seleccionar"

    )

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja varillas.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DIÁMETRO"] = df["DIÁMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DIÁMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DIÁMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay TIPO disponibles. Se usará 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay valores para {columna}. Se usará 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DIÁMETRO: {diam_value}")

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DIÁMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DIÁMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO E", final_df_renombrado))

                # print("Materiales del FLUJO E guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO G", button_style="success")

                def on_continue(b):

                    flujo_G()

                continue_button.on_click(on_continue)

                display(continue_button)

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccionó NO en FLUJO E. Saltando a FLUJO F...")  # Desactivado

                flujo_F()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO F: Abandona pozo

# ===============================

def flujo_F():

    clear_output()

    print("FLUJO F: Abandona pozo")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\abandono-recupero.xlsx"

    global df_abandono

    df_abandono = None

    output = widgets.Output()

    question_widget = widgets.Dropdown(

        options=["NO", "SI"],

        value="NO",

        description="¿Abandono/recupero?:"

    )

    def filter_by_todos(df, column, selected_values):

        if "TODOS" in selected_values:

            return df

        else:

            allowed_values = list(selected_values) + ["TODOS"]

            return df[df[column].isin(allowed_values)]

    def on_question_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(question_widget, output)

            if change['new'] == "SI":

                with output:

                    # print("Cargando el Excel...")  # (Este print no está en la lista a desactivar, se mantiene)

                    if not os.path.exists(file_path):

                        print(f"No se encontró el archivo:\n{file_path}")

                        return

                    global df_abandono

                    try:

                        df_abandono = pd.read_excel(file_path)

                    except Exception as e:

                        print("Error al cargar el Excel:", e)

                        return

                    print("Archivo cargado exitosamente.")

                df_abandono.columns = df_abandono.columns.str.strip()

                for col in df_abandono.columns:

                    if df_abandono[col].dtype == object:

                        df_abandono[col] = df_abandono[col].astype(str).str.strip()

                if "DIÁMETRO" not in df_abandono.columns:

                    with output:

                        print("La columna 'DIÁMETRO' no existe en el Excel.")

                    return

                unique_diametros = df_abandono["DIÁMETRO"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros:

                    unique_diametros.insert(0, "TODOS")

                else:

                    unique_diametros.remove("TODOS")

                    unique_diametros.insert(0, "TODOS")

                if "DIÁMETRO CSG" not in df_abandono.columns:

                    with output:

                        print("La columna 'DIÁMETRO CSG' no existe en el Excel.")

                    return

                unique_diametros_csg = df_abandono["DIÁMETRO CSG"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros_csg:

                    unique_diametros_csg.insert(0, "TODOS")

                else:

                    unique_diametros_csg.remove("TODOS")

                    unique_diametros_csg.insert(0, "TODOS")

                diametro_multi = widgets.SelectMultiple(

                    options=unique_diametros,

                    value=["TODOS"],

                    description="DIÁMETRO:",

                    rows=6

                )

                diametro_csg_single = widgets.Dropdown(

                    options=unique_diametros_csg,

                    value="TODOS",

                    description="DIÁM CSG:"

                )

                confirm_button = widgets.Button(

                    description="Confirmar Filtros",

                    button_style="info"

                )

                next_output = widgets.Output()

                def on_confirm_filters(b):

                    with next_output:

                        clear_output()

                        selected_diametros = list(diametro_multi.value)

                        selected_diametro_csg = diametro_csg_single.value

                        filtered_df = df_abandono.copy()

                        filtered_df = filter_by_todos(filtered_df, "DIÁMETRO", selected_diametros)

                        filtered_df = filter_by_todos(filtered_df, "DIÁMETRO CSG", [selected_diametro_csg])

                        print("Filtrado Aplicado. A continuación, ingrese cantidades (solo para celdas vacías).")

                        numeric_widgets = {}

                        diametros_especificos = [d for d in selected_diametros if d != "TODOS"]

                        if diametros_especificos:

                            print("Ingrese la cantidad para cada DIÁMETRO seleccionado:")

                            for d in diametros_especificos:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1e9,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                        else:

                            print("No se seleccionaron diámetros específicos. No se solicitarán cantidades.")

                        apply_button = widgets.Button(

                            description="Aplicar Cantidades",

                            button_style="success"

                        )

                        final_output = widgets.Output()

                        def on_apply_quantities(btn):

                            with final_output:

                                clear_output()

                                if "4.CANTIDAD" not in df_abandono.columns:

                                    print("La columna '4.CANTIDAD' no existe en el Excel.")

                                    return

                                df_abandono["4.CANTIDAD"] = pd.to_numeric(df_abandono["4.CANTIDAD"], errors="coerce")

                                for d in diametros_especificos:

                                    qty = numeric_widgets[d].value

                                    mask_diam = (df_abandono["DIÁMETRO"] == d)

                                    mask_nan = df_abandono["4.CANTIDAD"].isna()

                                    df_abandono.loc[mask_diam & mask_nan, "4.CANTIDAD"] = qty

                                filtered_final = df_abandono.copy()

                                filtered_final = filter_by_todos(filtered_final, "DIÁMETRO", selected_diametros)

                                filtered_final = filter_by_todos(filtered_final, "DIÁMETRO CSG", [selected_diametro_csg])

                                print("Listado Final Filtrado:")

                                filtered_final_renombrado = renombrar_columnas(filtered_final)

                                materiales_finales.append(("FLUJO F", filtered_final_renombrado))

                                # print("Materiales del FLUJO F guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                                def on_continue(b):

                                    flujo_H()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                        apply_button.on_click(on_apply_quantities)

                        display(apply_button, final_output)

                confirm_button.on_click(on_confirm_filters)

                display(diametro_multi, diametro_csg_single, confirm_button, next_output)

            else:

                with output:

                    # print("No se realizará la acción. Saltando a FLUJO H...")  # Desactivado

                    pass

                flujo_H()

    question_widget.observe(on_question_change, names='value')

    display(question_widget, output)

 

 

# ===============================

# FLUJO G: Instalación BM

# ===============================

def flujo_G():

    clear_output()

    print("FLUJO G: Instalación BM")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\WO.xlsx"

    pregunta_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¿WO a BM?",

        value="seleccionar"

    )

    def mostrar_materiales(change):

        clear_output()

        display(pregunta_widget)

        if change['new'] == "SI":

            try:

                df = pd.read_excel(file_path)

                print("Lista de materiales:")

                df_renombrado = renombrar_columnas(df)

                materiales_finales.append(("FLUJO G", df_renombrado))

                # print("Materiales del FLUJO G guardados.")  # Desactivado

            except Exception as e:

                print("Error al cargar Excel:", e)

            continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

            def on_continue(b):

                flujo_H()

            continue_button.on_click(on_continue)

            display(continue_button)

        elif change['new'] == "NO":

            print("No se mostrarán los materiales.")

            flujo_H()

    pregunta_widget.observe(mostrar_materiales, names='value')

    display(pregunta_widget)

 

def flujo_H():

    clear_output()

    print("=== FLUJO H: Material de agregación ===")

    try:

        file_path_H = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\GENERAL(1).xlsx"

        df_H = pd.read_excel(file_path_H)

        df_H.columns = df_H.columns.str.strip()

        if "4.CANTIDAD" not in df_H.columns:

            df_H["4.CANTIDAD"] = 0

    except Exception as e:

        print("Error al cargar el Excel:", e)

        df_H = pd.DataFrame()

   

    pregunta_widget_H = widgets.RadioButtons(

        options=["Seleccionar", "SI", "NO"],

        description="¿Agregar más material?",

        value="Seleccionar"

    )

    output_container_H = widgets.Output()

 

    apply_selection_button_H = widgets.Button(description="Aplicar selección", button_style="info")

    apply_qty_button_H = widgets.Button(description="Asignar cantidades", button_style="success")

   

    final_list_button = widgets.Button(description="Mostrar Listado Final de Materiales", button_style="warning")

    final_button_container = widgets.VBox([final_list_button])

   

    def on_show_final_list(b):

        clear_output()

        print("Listado final de materiales de todos los flujos ejecutados:")

        for flow, df in materiales_finales:

            print(f"\n---- {flow} ----")

            display(df)

    final_list_button.on_click(on_show_final_list)

   

    if not df_H.empty and "2. MATERIAL" in df_H.columns:

        materiales = df_H["2. MATERIAL"].astype(str).unique().tolist()

    else:

        materiales = []

    materiales_widget_H = widgets.SelectMultiple(

        options=materiales,

        description="Materiales",

        layout=widgets.Layout(width='50%', height='150px')

    )

    qty_widgets_H = {}

   

    def on_apply_selection_H(b):

        with output_container_H:

            clear_output()

            seleccionados = list(materiales_widget_H.value)

            if not seleccionados:

                print("No se seleccionó ningún material.")

                return

            print("Materiales seleccionados:")

            for mat in seleccionados:

                print("-", mat)

            qty_widgets_H.clear()

            input_boxes = []

            for mat in seleccionados:

                qty_box = widgets.BoundedFloatText(

                    value=0,

                    min=0,

                    step=1,

                    description=f"Cant: {mat}",

                    layout=widgets.Layout(width='50%')

                )

                qty_widgets_H[mat] = qty_box

                input_boxes.append(qty_box)

            display(widgets.VBox(input_boxes))

            display(apply_qty_button_H)

   

    def on_apply_qty_H(b):

        with output_container_H:

            clear_output()

            if df_H.empty:

                print("El DataFrame está vacío o no se cargó correctamente.")

                return

            selected_materials = list(qty_widgets_H.keys())

            for mat, widget_box in qty_widgets_H.items():

                cant = widget_box.value

                df_H.loc[df_H["2. MATERIAL"].astype(str) == mat, "4.CANTIDAD"] = cant

            assigned_df = df_H[

                df_H["2. MATERIAL"].astype(str).isin(selected_materials) &

                (df_H["4.CANTIDAD"] > 0)

            ]

            if not assigned_df.empty:

                assigned_df_renombrado = renombrar_columnas(assigned_df)

                materiales_finales.append(("FLUJO H", assigned_df_renombrado))

                # print("Materiales del FLUJO H guardados.")  # Desactivado

            else:

                print("No se asignaron cantidades (o todas fueron 0).")

           

            display(final_button_container)

   

    def on_pregunta_change_H(change):

        with output_container_H:

            clear_output()

            if change['new'] == "SI":

                if df_H.empty:

                    print("El DataFrame no se cargó o está vacío.")

                    return

                print("Lista completa de materiales del Excel:\n")

                display(df_H)

                print("\nSeleccione los materiales que desea agregar:")

                display(materiales_widget_H)

                display(apply_selection_button_H)

            elif change['new'] == "NO":

                print("No se agregarán más materiales.")

                display(final_button_container)

   

    pregunta_widget_H.observe(on_pregunta_change_H, names='value')

    apply_selection_button_H.on_click(on_apply_selection_H)

    apply_qty_button_H.on_click(on_apply_qty_H)

   

    display(pregunta_widget_H)

    display(output_container_H)

   

    # print("FLUJO H finalizado. Fin del proceso.")  # Desactivado

 

 

# ===============================

# Función principal: inicia en FLUJO A

# ===============================

def main():

    flujo_A()

 

# Inicia el proceso

main()
```

## docs/Estructura del proyecto.md

- Characters: 6225
- Tokens: 0

```markdown
🔹 1. Introducción
Este documento detalla la arquitectura propuesta para la implementación de un sistema de flujos modulares en una aplicación basada en Python y Flask. El objetivo es permitir la ejecución de múltiples flujos de trabajo (Flujo A, B, C, etc.), en los cuales cada flujo es un módulo independiente que recibe entradas del usuario, filtra datos de archivos Excel, y proporciona salidas que pueden afectar a los siguientes flujos.

🔹 2. Análisis Inicial del Problema
El código original consistía en una serie de filtros aplicados secuencialmente sobre distintos archivos de datos. Cada flujo:

Preguntaba al usuario si debía ejecutarse.
Aplicaba filtros a un conjunto de datos en función de la respuesta.
Mostraba los materiales resultantes.
Determinaba el siguiente flujo a ejecutar.
📌 Conclusión: La lógica de cada flujo era principalmente un filtro condicional sobre un conjunto de datos basado en respuestas del usuario.

Problemas detectados en la implementación inicial
❌ Código monolítico y difícil de extender.
❌ Falta de modularidad: cada flujo estaba acoplado a la lógica general.
❌ No había un manejo centralizado del estado y flujo de datos.

🔹 3. Patrón de Diseño Elegido
Se adoptó una arquitectura basada en plugins combinada con un manejo centralizado del flujo utilizando Flask Sessions. Esto permite:

📌 Modularidad: Cada flujo es un plugin independiente que puede añadirse sin modificar la estructura general.
📌 Flexibilidad: El orden de ejecución se define externamente y no dentro de cada módulo.
📌 Escalabilidad: Es fácil agregar nuevos flujos sin afectar el sistema.
📌 Manejo de Estado: Se utiliza Flask Sessions para almacenar respuestas y materiales seleccionados.
🔹 Patrón de diseño:
Plugin-Based Architecture + State Management
Cada flujo actúa como un plugin independiente y el sistema maneja las transiciones y datos entre ellos.

🔹 4. Arquitectura Resultante
📂 Estructura del Proyecto
bash
Copy
Edit
/app
  ├── main.py               # Punto de entrada de la aplicación
  ├── flujo_loader.py       # Carga y gestiona los flujos dinámicamente
  ├── plugins/              # Módulos independientes de cada flujo
  │   ├── __init__.py
  │   ├── flujo_a.py        # Flujo A
  │   ├── flujo_b.py        # Flujo B
  │   ├── flujo_c.py        # Flujo C
  │   ├── flujo_d.py        # Flujo D
  │   ├── flujo_e.py        # Flujo E
  │   ├── flujo_f.py        # Flujo F
  │   ├── flujo_g.py        # Flujo G
  │   ├── flujo_h.py        # Flujo H (siempre se ejecuta)
  ├── templates/            # HTML para la interfaz de usuario
  │   ├── base.html
  │   ├── index.html
  │   ├── flujo.html        # Página genérica para cada flujo
  │   ├── resultados.html   # Página de resultados finales
  ├── static/               # Archivos CSS y JS
  ├── data/                 # Archivos Excel
  ├── requirements.txt
  └── README.md
🔹 5. Manejo del Flujo de Ejecución
En lugar de definir el orden de los flujos dentro de cada módulo, se utiliza un diccionario de transición que maneja la lógica centralmente.

📌 Configuración de flujos en flujo_loader.py

python
Copy
Edit
SECUENCIA_FLUJOS = {
    "A": {"SI": "H", "NO": "B"},
    "B": {"SI": "C", "NO": "C"},
    "C": {"SI": "D", "NO": "D"},
    "D": {"SI": "E", "NO": "E"},
    "E": {"SI": "G", "NO": "F"},
    "F": {"SI": "H", "NO": "H"},
    "G": {"SI": "H", "NO": "H"},
    "H": None  # Último flujo
}
📌 Cómo funciona:

Cada flujo tiene una entrada (respuesta del usuario).
Se determina el siguiente flujo basado en la respuesta (SI o NO).
Los datos de cada flujo se almacenan en session para ser utilizados en flujos posteriores.
🔹 6. Ejemplo de Flujo Individual
Cada flujo es un módulo independiente en la carpeta plugins/.

📌 Ejemplo de plugins/flujo_a.py

python
Copy
Edit
from flask import render_template, request

nombre = "A"

def ejecutar():
    if request.method == "POST":
        respuesta = request.form.get("respuesta")
        materiales_seleccionados = ["Material X", "Material Y"] if respuesta == "SI" else []
        return respuesta, materiales_seleccionados

    return render_template("flujo.html", flujo=nombre)
📌 Explicación:

Cada flujo recibe una entrada (POST del usuario).
Si el usuario responde "SI", filtra materiales y los guarda.
Si el usuario responde "NO", se salta el procesamiento.
El sistema decide cuál es el siguiente flujo.
🔹 7. Manejo del Estado Global
Se utiliza Flask Sessions para mantener los datos entre flujos.

📌 Ejemplo de cómo se almacenan los datos en session

python
Copy
Edit
@app.route("/flujo/<nombre_flujo>", methods=["GET", "POST"])
def flujo(nombre_flujo):
    if nombre_flujo in flujos:
        respuesta, materiales, siguiente_flujo = ejecutar_flujo(nombre_flujo, session)

        # Guardar en sesión
        session[nombre_flujo] = {"respuesta": respuesta, "materiales": materiales}

        # Continuar al siguiente flujo o finalizar
        return redirect(url_for("flujo", nombre_flujo=siguiente_flujo)) if siguiente_flujo else redirect(url_for("resultados"))

    return redirect(url_for("index"))
📌 Beneficios del uso de session ✔ Permite almacenar datos persistentes sin base de datos.
✔ Mantiene la continuidad entre flujos.
✔ Hace que cada flujo sea independiente sin necesidad de modificar otros flujos.

🔹 8. Beneficios de la Arquitectura
Característica	Beneficio
Plugins Modulares	Se pueden agregar nuevos flujos sin modificar main.py.
Configuración Centralizada	El orden de ejecución se define en flujo_loader.py.
Manejo de Estado con session	Cada flujo puede acceder a respuestas y materiales previos.
Separación de Responsabilidades	main.py maneja la app, flujo_loader.py los flujos, y los plugins contienen la lógica específica.
Escalabilidad	Fácil de expandir sin modificar el código existente.
🔹 9. Conclusión
Se pasó de una estructura monolítica a una arquitectura basada en plugins donde:

Cada flujo es un módulo autónomo con entrada y salida.
El flujo de ejecución es gestionado dinámicamente.
Se utiliza session para almacenar respuestas y datos.
Los desarrolladores pueden agregar nuevos flujos sin modificar la estructura base.
Este modelo permite escalabilidad, modularidad y facilidad de mantenimiento, alineándose con buenas prácticas de arquitectura de software.
```

## README.md

- Characters: 1903
- Tokens: 0

```markdown
# Visualizador de Excel

Esta aplicación simple permite visualizar archivos Excel como tablas HTML en un navegador web.

## Requisitos

- Python 3.6 o superior
- pip (gestor de paquetes de Python)

## Instalación

1. Clona o descarga este repositorio
2. Instala las dependencias:

# Configuración y ejecución en VS Code (Windows)
Requisitos previos

Python 3.6 o superior
pip (gestor de paquetes de Python)

Pasos para ejecutar la aplicación
1. Clonar el repositorio
Copygit clone [URL_DEL_REPOSITORIO]
cd mi_app
2. Crear y activar un entorno virtual
Copy# Crear entorno virtual
python -m venv venv

# Activar el entorno virtual
venv\Scripts\activate
3. Instalar dependencias
Copy# Instalar todas las dependencias necesarias
pip install flask==2.3.3 openpyxl==3.1.2 pandas xlrd==2.0.1
4. Preparar los archivos Excel

Coloca tus archivos Excel (.xlsx o .xls) en la carpeta app/data/
Si la carpeta no existe, se creará automáticamente al iniciar la aplicación

5. Ejecutar la aplicación
Copy# Navegar a la carpeta app
cd app

# Iniciar la aplicación
python main.py
6. Acceder a la aplicación

Abre tu navegador y navega a: http://127.0.0.1:5000
Verás todos los archivos Excel cargados y podrás iniciar los flujos de trabajo

7. Desactivar el entorno virtual cuando termines
Copydeactivate
Solución de problemas comunes

Error "No module named...": Verifica que el entorno virtual esté activado y que todas las dependencias estén instaladas
Archivos Excel no visibles: Asegúrate de que estén en la carpeta correcta (app/data/) y tengan la extensión correcta (.xlsx o .xls)

3. Abre tu navegador y ve a `http://localhost:5000`

## Notas

- La aplicación mostrará todos los archivos Excel (.xlsx o .xls) encontrados en la carpeta `data`
- Cada archivo se convertirá en una tabla HTML
- Puedes recargar la página para actualizar los datos si agregas nuevos archivos Excel mientras la aplicación está corriendo
```

## .gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## Statistics

- Total Files: 21
- Total Characters: 225665
- Total Tokens: 0
``````

## docs/Flujo A - Doc tecnico.md

- Characters: 2871
- Tokens: 0

```markdown
📌 Especificación Técnica para Desarrollo – FLUJO A (Ajuste de Medida)
1️⃣ Descripción General
FLUJO A permite al usuario seleccionar materiales basados en criterios específicos de ajuste de medida. Si el usuario acepta el ajuste, el flujo filtra los materiales y salta directamente a FLUJO H. Si el usuario rechaza, salta a FLUJO B sin procesar datos.

2️⃣ Datos de Entrada
La información proviene de una tabla estructurada (ajuste_de_medida.xlsx), con las siguientes columnas clave:

Columna	Tipo	Descripción
DIÁMETRO	string	Diámetro del material
TIPO	string	Tipo de material
GRADO DE ACERO	string	Grado de acero
GRADO DE ACERO CUPLA	string	Grado de acero de la cupla
TIPO DE CUPLA	string	Tipo de cupla
4.CANTIDAD	float	Cantidad del material (opcional)
3️⃣ Flujo de Ejecución
Pregunta al usuario:

Si responde "NO" → Salta directamente a FLUJO B.
Si responde "SÍ" → Carga la tabla y aplica filtros.
Carga y Filtrado de Datos:

Carga la tabla ajuste_de_medida.xlsx y limpia valores.
El usuario selecciona valores en los siguientes filtros:
DIÁMETRO
TIPO
GRADO DE ACERO
GRADO DE ACERO CUPLA
TIPO DE CUPLA
Si el usuario no selecciona un valor, se usa "TODOS" como fallback.
Construcción de final_condition (máscara booleana de filtrado):

Inicializa final_condition con False para excluir todos los registros.
Para cada DIÁMETRO seleccionado, evalúa si los materiales cumplen con los criterios del usuario.
Incluye "TODOS" en cada filtro para garantizar que los valores no seleccionados no eliminen registros útiles.
Se combinan las condiciones (| lógico) para crear el filtro final.
Aplicación del Filtro:

python
Copy
Edit
final_df = df[final_condition]
Solo quedan los materiales que cumplen con los criterios del usuario.
Almacena los materiales filtrados en materiales_finales:

python
Copy
Edit
materiales_finales.append(("FLUJO A", final_df_renombrado))
Salto a FLUJO H (el flujo no sigue la secuencia normal):

Si el usuario ejecuta FLUJO A, no sigue a FLUJO B, sino directamente a FLUJO H.
4️⃣ Consideraciones Técnicas
✔ No modifica la estructura de la tabla, solo aplica filtros.
✔ Debe permitir múltiples selecciones en cada filtro.
✔ Evita pérdida de datos con "TODOS" en cada condición.
✔ Encapsular final_condition como lógica reutilizable para otros flujos.
✔ Optimizar el acceso a archivos si se requiere ejecución frecuente.

📌 Resumen Final
FLUJO A solo se ejecuta si el usuario dice "SÍ".
Carga una tabla de materiales y filtra datos según selección del usuario.
Almacena los materiales seleccionados y salta directamente a FLUJO H.
Si el usuario dice "NO", salta a FLUJO B sin procesar nada.
final_condition es el mecanismo que define qué materiales quedan en la selección final.
🚀 Resultado esperado: Un módulo optimizado que procesa materiales en base a filtros dinámicos y garantiza la continuidad del flujo sin interrumpir la secuencia de ejecución.
```

## docs/commentarios del proy.md

- Characters: 52736
- Tokens: 0

```markdown
engo varios códigos por separado que representan diferentes flujos para la selección de materiales en la intervención de un pozo petrolero: FLUJO A, FLUJO B, FLUJO C, FLUJO D, FLUJO E, FLUJO F, FLUJO G y FLUJO H. Cada uno de ellos inicia con una pregunta que, si el usuario responde “NO”, salta inmediatamente al siguiente flujo; y si el usuario responde “SÍ”, entonces ejecuta su lógica, imprime una lista de materiales y luego avanza al siguiente flujo.

Los flujos se llaman y se encadenan de la siguiente forma:

FLUJO A (Ajuste de medida)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO H.
Si el usuario responde NO , salta a FLUJO B.
FLUJO B (Tubo de saca)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO C.
Si el usuario responde NO , salta a FLUJO C.
FLUJO C (tubería de Baja)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO D.
Si el usuario responde NO , salta a FLUJO D.
FLUJO D (Profundiza)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO E.
Si el usuario responde NO , salta a FLUJO E.
FLUJO E (Baja varillas)
Si el usuario responde SÍ , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO G.
Luego de terminar FLUJO G , debe continuar a FLUJO H .
Si el usuario responde NO , salta a FLUJO F , y al terminar FLUJO F , avanza a FLUJO H.
FLUJO F (Abandona pozo)
Luego de terminar (sea cual sea la respuesta, si aplica), avanza a FLUJO H .
FLUJO G (Instalación BM)
Cuando termine este flujo, avanza a FLUJO H.
FLUJO H (Material de agregación)
No es condicional: se supone que, al llegar aquí, se ejecuta y finaliza.
El resultado deseado es un único script de Python que combina estos ocho flujos en el orden descrito y respeta las condiciones de salto (SÍ/NO). Cada flujo debe:

Preguntar al usuario si desea ejecutar ese flujo (excepto FLUJO H, que siempre se ejecuta al llegar).
Si responde SÍ: ejecute la lógica interna de ese flujo (por ejemplo, las preguntas o procesos que incluían), e imprima la lista de materiales correspondientes.
Terminar ese flujo y, en lugar de salirse del programa, encadenar inmediatamente con el siguiente flujo indicado.
Si responde NO: saltarse la ejecución de ese flujo (no imprime materiales) y avanzar al siguiente flujo, salvo en el caso de FLUJO A y FLUJO E, que ya tienen desvíos particulares a otros flujos.


EL CODIGO EJECUTADO EN JUPYTER ES: ESTA UN POCO DESPROLIJO, PERO BUENO AL MENOS FUNCIONA


import os

import pandas as pd

import ipywidgets as widgets

from IPython.display import display, clear_output

 

# Variable global para almacenar los DataFrames finales de cada flujo

materiales_finales = []

 

# Función para renombrar las columnas y dejar solo las 5 requeridas

def renombrar_columnas(df):

    df_renombrado = df.rename(

        columns={

            "1. Cód.SAP": "Cód.SAP",

            "2. MATERIAL": "MATERIAL",

            "3. Descripción": "Descripción",

            "5.CONDICIÓN": "CONDICIÓN"

        }

    )

    # Asegurarse de que queden las siguientes columnas

    columnas = ["Cód.SAP", "MATERIAL", "Descripción", "4.CANTIDAD", "CONDICIÓN"]

    columnas_presentes = [col for col in columnas if col in df_renombrado.columns]

    return df_renombrado[columnas_presentes]

 

# ===============================

# FLUJO A: Ajuste de medida

# ===============================

def flujo_A():

    clear_output()

    print("FLUJO A: Ajuste de medida")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¿Ajuste de medida?",

        value="seleccionar"

    )

   

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\ajuste de medida.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DIÁMETRO"] = df["DIÁMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DIÁMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DIÁMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

       

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay TIPO disponibles. Se usará 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

       

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay valores para {columna}. Se usará 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

       

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DIÁMETRO: {diam_value}")

       

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

       

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

       

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DIÁMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False] * len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False] * len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DIÁMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                # En lugar de mostrar inmediatamente, se almacena el DataFrame renombrado

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO A", final_df_renombrado))

                # print("Materiales del FLUJO A guardados.")  # Desactivado

               

                # Botón para continuar a FLUJO H (ya que en FLUJO A si se responde SI se salta directamente a H)

                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                def on_continue(b):

                    flujo_H()

                continue_button.on_click(on_continue)

                display(continue_button)

       

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccionó NO en FLUJO A. Saltando a FLUJO B...")  # Desactivado

                flujo_B()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO B: Tubo de saca

# ===============================

def flujo_B():

    clear_output()

    print("FLUJO B: Tubo de saca")

    folder_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales"

    filename_saca = "saca tubing.xlsx"

    file_path_saca = os.path.join(folder_path, filename_saca)

    global df_saca_tubing

    df_saca_tubing = None

 

    def load_saca_tubing_excel():

        global df_saca_tubing

        if not os.path.exists(file_path_saca):

            print(f"El archivo {file_path_saca} no se encontró.")

            return

        df_tmp = pd.read_excel(file_path_saca)

        df_tmp.columns = df_tmp.columns.str.strip()

        for c in df_tmp.columns:

            if df_tmp[c].dtype == object:

                df_tmp[c] = df_tmp[c].astype(str).str.strip()

        df_saca_tubing = df_tmp.copy()

        diametro_multi_picker.options = sorted(

            [d for d in df_saca_tubing['DIÁMETRO'].unique() if d.upper() != 'TODOS']

        )

 

    diametro_multi_picker = widgets.SelectMultiple(

        options=[],

        description='DIÁMETRO:',

        style={'description_width': 'initial'}

    )

    confirm_diameter_button = widgets.Button(

        description='Confirmar diámetros',

        button_style='info'

    )

    quantities_container = widgets.VBox()

    final_output = widgets.Output()

    show_table_button = widgets.Button(

        description='Mostrar tabla final',

        button_style='success'

    )

 

    def on_show_table_button_clicked(b):

        with final_output:

            clear_output()

            if df_saca_tubing is None:

                print("No hay datos cargados de saca tubing.")

                return

            selected_diameters = list(diametro_multi_picker.value)

            df_filtered = df_saca_tubing[

                (df_saca_tubing['DIÁMETRO'].isin(selected_diameters)) |

                (df_saca_tubing['DIÁMETRO'].str.upper() == 'TODOS')

            ].copy()

            for child in quantities_container.children:

                dia = child.description

                cantidad = child.value

                mask = (df_filtered['DIÁMETRO'] == dia)

                df_filtered.loc[mask, '4.CANTIDAD'] = cantidad

            df_filtered_renombrado = renombrar_columnas(df_filtered)

            materiales_finales.append(("FLUJO B", df_filtered_renombrado))

            print("Materiales del FLUJO B guardados.")

 

        # Cierra la interfaz de FLUJO B

        multi_select_container.close()

 

        # Muestra el botón para continuar al FLUJO C

        continue_button = widgets.Button(

            description="Continuar a FLUJO C",

            button_style="success"

        )

        def on_continue(b):

            clear_output()

            flujo_C()

        continue_button.on_click(on_continue)

        display(continue_button)

 

    show_table_button.on_click(on_show_table_button_clicked)

 

    def on_confirm_diameter_button_clicked(b):

        with final_output:

            clear_output()

        quantities_container.children = []

        for dia in diametro_multi_picker.value:

            qty_widget = widgets.IntText(

                value=0,

                description=dia,

                style={'description_width': 'initial'}

            )

            quantities_container.children += (qty_widget,)

 

    confirm_diameter_button.on_click(on_confirm_diameter_button_clicked)

 

    multi_select_container = widgets.VBox([

        diametro_multi_picker,

        confirm_diameter_button,

        quantities_container,

        show_table_button,

        final_output

    ])

 

    bajara_tubing_picker = widgets.Dropdown(

        options=["Seleccione opción", "SI", "NO"],

        value="Seleccione opción",

        description="¿saca Tubing?:"

    )

 

    def on_bajara_tubing_change(change):

        clear_output()

        if change['new'] == "SI":

            load_saca_tubing_excel()

            display(multi_select_container)

        elif change['new'] == "NO":

            print("No se saca tubing.")

            flujo_C()

 

    bajara_tubing_picker.observe(on_bajara_tubing_change, names='value')

 

    print("¿Saca Tubing?")

    display(bajara_tubing_picker)

 

# ===============================

# FLUJO C: Tubería de Baja

# ===============================

def flujo_C():

    clear_output()

    print("FLUJO C: Tubería de Baja")

    file_path_baja = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja tubing.xlsx"

    global df_baja_tubing

    df_baja_tubing = None

    output = widgets.Output()

    baja_tubing_widget = widgets.ToggleButtons(

        options=['SI', 'NO'],

        description='¿Baja Tubing?',

        disabled=False,

        value=None

    )

    display(baja_tubing_widget, output)

   

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_baja):

                print(f"El archivo no se encontró en la ruta:\n{file_path_baja}")

                return False

            try:

                df = pd.read_excel(file_path_baja)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DIÁMETRO CSG' in df.columns:

                    df['DIÁMETRO CSG'] = df['DIÁMETRO CSG'].replace('nan', '').fillna('')

                global df_baja_tubing

                df_baja_tubing = df.copy()

                print("Archivo cargado y limpiado con éxito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

   

    def show_diametro_selection():

        with output:

            print("\n--- Selección de DIÁMETRO ---")

            df = df_baja_tubing

            unique_diametros = sorted([x for x in df['DIÁMETRO'].unique() if x != "TODOS"])

            diametro_widget = widgets.SelectMultiple(

                options=unique_diametros,

                value=(),

                description="DIÁMETRO",

                layout=widgets.Layout(width='50%')

            )

            display(diametro_widget)

            button_diametro = widgets.Button(description="Siguiente - Selección DIÁMETRO")

            display(button_diametro)

           

            def on_diametro_button_clicked(_):

                selected = list(diametro_widget.value)

                selected_diametros = ["TODOS"] if not selected else selected

                show_tipo_accordion(selected_diametros)

            button_diametro.on_click(on_diametro_button_clicked)

   

    def show_tipo_accordion(selected_diametros):

        with output:

            print("\n--- Selección de TIPO para cada DIÁMETRO ---")

            df = df_baja_tubing

            tipo_widgets = {}

            children = []

            titles = []

            for d in selected_diametros:

                df_temp = df if d=="TODOS" else df[df['DIÁMETRO'] == d]

                unique_tipos = sorted([x for x in df_temp['TIPO'].unique() if x != "TODOS"])

                widget_t = widgets.SelectMultiple(

                    options=unique_tipos,

                    value=(),

                    description=f"TIPO ({d})",

                    layout=widgets.Layout(width='50%')

                )

                tipo_widgets[d] = widget_t

                children.append(widget_t)

                titles.append(f"DIÁMETRO: {d}")

            accordion = widgets.Accordion(children=children)

            for idx, title in enumerate(titles):

                accordion.set_title(idx, title)

            display(accordion)

            button_tipo = widgets.Button(description="Siguiente - Selección TIPO")

            display(button_tipo)

           

            def on_tipo_button_clicked(_):

                selected_tipos_dict = {}

                for d, widget_t in tipo_widgets.items():

                    st = list(widget_t.value)

                    if not st:

                        st = ["TODOS"]

                    selected_tipos_dict[d] = st

                show_diametro_csg_selection(selected_diametros, selected_tipos_dict)

            button_tipo.on_click(on_tipo_button_clicked)

   

    def show_diametro_csg_selection(selected_diametros, selected_tipos_dict):

        with output:

            print("\n--- Selección de DIÁMETRO CSG ---")

            df = df_baja_tubing

            union_tipos = set()

            for tlist in selected_tipos_dict.values():

                if tlist == ["TODOS"]:

                    union_tipos.add("TODOS")

                else:

                    union_tipos.update(tlist)

                    union_tipos.add("TODOS")

            diam_filter = ["TODOS"] if selected_diametros == ["TODOS"] else selected_diametros + ["TODOS"]

            df_filtered = df[df['DIÁMETRO'].isin(diam_filter) & df['TIPO'].isin(union_tipos)]

            unique_csg = sorted([x for x in df_filtered['DIÁMETRO CSG'].unique() if x != "TODOS"])

            if not unique_csg:

                print("Nota: Solo 'TODOS' disponible para DIÁMETRO CSG. Se procede automáticamente.")

                show_quantity_inputs(selected_diametros, selected_tipos_dict, ["TODOS"])

            else:

                csg_widget = widgets.Dropdown(

                    options=unique_csg,

                    value=unique_csg[0],

                    description="DIÁMETRO CSG",

                    layout=widgets.Layout(width='50%')

                )

                display(csg_widget)

                button_csg = widgets.Button(description="Siguiente - Selección DIÁMETRO CSG")

                display(button_csg)

               

                def on_csg_button_clicked(_):

                    selected_csg = csg_widget.value

                    selected_csg_filter = [selected_csg, "TODOS"] if selected_csg != "TODOS" else ["TODOS"]

                    show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter)

                button_csg.on_click(on_csg_button_clicked)

   

    def show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter):

        with output:

            print("\n--- Ingreso de Cantidades ---")

            df = df_baja_tubing

            quantity_widgets = {}

            qty_items = []

            for d in selected_diametros:

                for t in selected_tipos_dict[d]:

                    key = (d, t)

                    w = widgets.IntText(

                        value=0,

                        description=f"{d} - {t}:",

                        layout=widgets.Layout(width='400px')

                    )

                    quantity_widgets[key] = w

                    qty_items.append(w)

            quantity_box = widgets.VBox(qty_items)

            display(quantity_box)

            update_qty_button = widgets.Button(description="Aplicar Cantidades", button_style="success")

            display(update_qty_button)

           

            def on_update_qty(b2):

                for (d, t), qty_widget in quantity_widgets.items():

                    qty_value = qty_widget.value

                    if d == "TODOS":

                        continue

                    condition = (df["DIÁMETRO"].isin([d, "TODOS"]) & df["TIPO"].isin([t, "TODOS"]))

                    df.loc[condition & df["4.CANTIDAD"].isna(), "4.CANTIDAD"] = qty_value

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in selected_tipos_dict.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict:

                        cond = (df["DIÁMETRO"].isin([diam_value, "TODOS"]) & df["TIPO"].isin([tipo_val, "TODOS"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO C", final_df_renombrado))

                # print("Materiales del FLUJO C guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO D", button_style="success")

                def on_continue(b):

                    flujo_D()

                continue_button.on_click(on_continue)

                display(continue_button)

            update_qty_button.on_click(on_update_qty)

   

    def on_baja_tubing_change(change):

        if change['name'] == 'value' and change['new'] is not None:

            if change['new'] == 'SI':

                if load_excel():

                    show_diametro_selection()

            else:

                with output:

                    print("No se procede con Baja Tubing.")

                flujo_D()

    baja_tubing_widget.observe(on_baja_tubing_change, names='value')

   

# ===============================

# FLUJO D: Profundiza

# ===============================

def flujo_D():

    clear_output()

    print("FLUJO D: Profundiza")

    output = widgets.Output()

    file_path_prof = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\profundiza.xlsx"

    global df_prof

    df_prof = None

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_prof):

                print(f"El archivo no se encontró en la ruta:\n{file_path_prof}")

                return False

            try:

                df = pd.read_excel(file_path_prof)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DIÁMETRO CSG' in df.columns:

                    df['DIÁMETRO CSG'] = df['DIÁMETRO CSG'].replace('nan', '').fillna('')

                global df_prof

                df_prof = df.copy()

                print("Archivo cargado y limpiado con éxito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

    profundiza_widget = widgets.Dropdown(

        options=["seleccionar", "SI", "NO"],

        description="Profundizar:",

        value="seleccionar"

    )

    def on_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(output)

            if change['new'] == "SI":

                if load_excel():

                    if "DIÁMETRO" in df_prof.columns:

                        col_diametro = "DIÁMETRO"

                    elif "DIÁMETRO CSG" in df_prof.columns:

                        col_diametro = "DIÁMETRO CSG"

                    else:

                        with output:

                            print("La columna de DIÁMETRO no se encontró en el Excel.")

                        return

                    diametro_select = widgets.SelectMultiple(

                        options=df_prof[col_diametro].unique().tolist(),

                        description="DIÁMETRO",

                        rows=10

                    )

                    display(diametro_select)

                    confirm_button = widgets.Button(description="Confirmar selección")

                    output_area = widgets.Output()

                    def on_confirm(b):

                        with output_area:

                            clear_output()

                            selected_diametros = list(diametro_select.value)

                            if not selected_diametros:

                                print("No se seleccionaron diámetros.")

                                return

                            print("Ingrese la cantidad para cada DIÁMETRO seleccionado:")

                            numeric_widgets = {}

                            for d in selected_diametros:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1000000,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                            apply_button = widgets.Button(description="Aplicar cantidades")

                            def on_apply(b):

                                filtered_df = df_prof[df_prof[col_diametro].isin(selected_diametros)].copy()

                                for d in selected_diametros:

                                    cantidad = numeric_widgets[d].value

                                    filtered_df.loc[filtered_df[col_diametro] == d, "4.CANTIDAD"] = cantidad

                                final_df_renombrado = renombrar_columnas(filtered_df)

                                materiales_finales.append(("FLUJO D", final_df_renombrado))

                                # print("Materiales del FLUJO D guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO E", button_style="success")

                                def on_continue(b):

                                    flujo_E()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                            apply_button.on_click(on_apply)

                            display(apply_button)

                    confirm_button.on_click(on_confirm)

                    display(confirm_button, output_area)

            else:

                with output:

                    print("No se profundizará en la información.")

                flujo_E()

    profundiza_widget.observe(on_change)

    display(profundiza_widget)

    display(output)

 

# ===============================

# FLUJO E: Baja varillas

# ===============================

def flujo_E():

    clear_output()

    print("FLUJO E: Baja varillas")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¿Baja Varilla?",

        value="seleccionar"

    )

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja varillas.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DIÁMETRO"] = df["DIÁMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DIÁMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DIÁMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay TIPO disponibles. Se usará 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DIÁMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DIÁMETRO '{diam_value}', no hay valores para {columna}. Se usará 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DIÁMETRO: {diam_value}")

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DIÁMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DIÁMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO E", final_df_renombrado))

                # print("Materiales del FLUJO E guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO G", button_style="success")

                def on_continue(b):

                    flujo_G()

                continue_button.on_click(on_continue)

                display(continue_button)

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccionó NO en FLUJO E. Saltando a FLUJO F...")  # Desactivado

                flujo_F()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO F: Abandona pozo

# ===============================

def flujo_F():

    clear_output()

    print("FLUJO F: Abandona pozo")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\abandono-recupero.xlsx"

    global df_abandono

    df_abandono = None

    output = widgets.Output()

    question_widget = widgets.Dropdown(

        options=["NO", "SI"],

        value="NO",

        description="¿Abandono/recupero?:"

    )

    def filter_by_todos(df, column, selected_values):

        if "TODOS" in selected_values:

            return df

        else:

            allowed_values = list(selected_values) + ["TODOS"]

            return df[df[column].isin(allowed_values)]

    def on_question_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(question_widget, output)

            if change['new'] == "SI":

                with output:

                    # print("Cargando el Excel...")  # (Este print no está en la lista a desactivar, se mantiene)

                    if not os.path.exists(file_path):

                        print(f"No se encontró el archivo:\n{file_path}")

                        return

                    global df_abandono

                    try:

                        df_abandono = pd.read_excel(file_path)

                    except Exception as e:

                        print("Error al cargar el Excel:", e)

                        return

                    print("Archivo cargado exitosamente.")

                df_abandono.columns = df_abandono.columns.str.strip()

                for col in df_abandono.columns:

                    if df_abandono[col].dtype == object:

                        df_abandono[col] = df_abandono[col].astype(str).str.strip()

                if "DIÁMETRO" not in df_abandono.columns:

                    with output:

                        print("La columna 'DIÁMETRO' no existe en el Excel.")

                    return

                unique_diametros = df_abandono["DIÁMETRO"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros:

                    unique_diametros.insert(0, "TODOS")

                else:

                    unique_diametros.remove("TODOS")

                    unique_diametros.insert(0, "TODOS")

                if "DIÁMETRO CSG" not in df_abandono.columns:

                    with output:

                        print("La columna 'DIÁMETRO CSG' no existe en el Excel.")

                    return

                unique_diametros_csg = df_abandono["DIÁMETRO CSG"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros_csg:

                    unique_diametros_csg.insert(0, "TODOS")

                else:

                    unique_diametros_csg.remove("TODOS")

                    unique_diametros_csg.insert(0, "TODOS")

                diametro_multi = widgets.SelectMultiple(

                    options=unique_diametros,

                    value=["TODOS"],

                    description="DIÁMETRO:",

                    rows=6

                )

                diametro_csg_single = widgets.Dropdown(

                    options=unique_diametros_csg,

                    value="TODOS",

                    description="DIÁM CSG:"

                )

                confirm_button = widgets.Button(

                    description="Confirmar Filtros",

                    button_style="info"

                )

                next_output = widgets.Output()

                def on_confirm_filters(b):

                    with next_output:

                        clear_output()

                        selected_diametros = list(diametro_multi.value)

                        selected_diametro_csg = diametro_csg_single.value

                        filtered_df = df_abandono.copy()

                        filtered_df = filter_by_todos(filtered_df, "DIÁMETRO", selected_diametros)

                        filtered_df = filter_by_todos(filtered_df, "DIÁMETRO CSG", [selected_diametro_csg])

                        print("Filtrado Aplicado. A continuación, ingrese cantidades (solo para celdas vacías).")

                        numeric_widgets = {}

                        diametros_especificos = [d for d in selected_diametros if d != "TODOS"]

                        if diametros_especificos:

                            print("Ingrese la cantidad para cada DIÁMETRO seleccionado:")

                            for d in diametros_especificos:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1e9,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                        else:

                            print("No se seleccionaron diámetros específicos. No se solicitarán cantidades.")

                        apply_button = widgets.Button(

                            description="Aplicar Cantidades",

                            button_style="success"

                        )

                        final_output = widgets.Output()

                        def on_apply_quantities(btn):

                            with final_output:

                                clear_output()

                                if "4.CANTIDAD" not in df_abandono.columns:

                                    print("La columna '4.CANTIDAD' no existe en el Excel.")

                                    return

                                df_abandono["4.CANTIDAD"] = pd.to_numeric(df_abandono["4.CANTIDAD"], errors="coerce")

                                for d in diametros_especificos:

                                    qty = numeric_widgets[d].value

                                    mask_diam = (df_abandono["DIÁMETRO"] == d)

                                    mask_nan = df_abandono["4.CANTIDAD"].isna()

                                    df_abandono.loc[mask_diam & mask_nan, "4.CANTIDAD"] = qty

                                filtered_final = df_abandono.copy()

                                filtered_final = filter_by_todos(filtered_final, "DIÁMETRO", selected_diametros)

                                filtered_final = filter_by_todos(filtered_final, "DIÁMETRO CSG", [selected_diametro_csg])

                                print("Listado Final Filtrado:")

                                filtered_final_renombrado = renombrar_columnas(filtered_final)

                                materiales_finales.append(("FLUJO F", filtered_final_renombrado))

                                # print("Materiales del FLUJO F guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                                def on_continue(b):

                                    flujo_H()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                        apply_button.on_click(on_apply_quantities)

                        display(apply_button, final_output)

                confirm_button.on_click(on_confirm_filters)

                display(diametro_multi, diametro_csg_single, confirm_button, next_output)

            else:

                with output:

                    # print("No se realizará la acción. Saltando a FLUJO H...")  # Desactivado

                    pass

                flujo_H()

    question_widget.observe(on_question_change, names='value')

    display(question_widget, output)

 

 

# ===============================

# FLUJO G: Instalación BM

# ===============================

def flujo_G():

    clear_output()

    print("FLUJO G: Instalación BM")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\WO.xlsx"

    pregunta_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¿WO a BM?",

        value="seleccionar"

    )

    def mostrar_materiales(change):

        clear_output()

        display(pregunta_widget)

        if change['new'] == "SI":

            try:

                df = pd.read_excel(file_path)

                print("Lista de materiales:")

                df_renombrado = renombrar_columnas(df)

                materiales_finales.append(("FLUJO G", df_renombrado))

                # print("Materiales del FLUJO G guardados.")  # Desactivado

            except Exception as e:

                print("Error al cargar Excel:", e)

            continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

            def on_continue(b):

                flujo_H()

            continue_button.on_click(on_continue)

            display(continue_button)

        elif change['new'] == "NO":

            print("No se mostrarán los materiales.")

            flujo_H()

    pregunta_widget.observe(mostrar_materiales, names='value')

    display(pregunta_widget)

 

def flujo_H():

    clear_output()

    print("=== FLUJO H: Material de agregación ===")

    try:

        file_path_H = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\GENERAL(1).xlsx"

        df_H = pd.read_excel(file_path_H)

        df_H.columns = df_H.columns.str.strip()

        if "4.CANTIDAD" not in df_H.columns:

            df_H["4.CANTIDAD"] = 0

    except Exception as e:

        print("Error al cargar el Excel:", e)

        df_H = pd.DataFrame()

   

    pregunta_widget_H = widgets.RadioButtons(

        options=["Seleccionar", "SI", "NO"],

        description="¿Agregar más material?",

        value="Seleccionar"

    )

    output_container_H = widgets.Output()

 

    apply_selection_button_H = widgets.Button(description="Aplicar selección", button_style="info")

    apply_qty_button_H = widgets.Button(description="Asignar cantidades", button_style="success")

   

    final_list_button = widgets.Button(description="Mostrar Listado Final de Materiales", button_style="warning")

    final_button_container = widgets.VBox([final_list_button])

   

    def on_show_final_list(b):

        clear_output()

        print("Listado final de materiales de todos los flujos ejecutados:")

        for flow, df in materiales_finales:

            print(f"\n---- {flow} ----")

            display(df)

    final_list_button.on_click(on_show_final_list)

   

    if not df_H.empty and "2. MATERIAL" in df_H.columns:

        materiales = df_H["2. MATERIAL"].astype(str).unique().tolist()

    else:

        materiales = []

    materiales_widget_H = widgets.SelectMultiple(

        options=materiales,

        description="Materiales",

        layout=widgets.Layout(width='50%', height='150px')

    )

    qty_widgets_H = {}

   

    def on_apply_selection_H(b):

        with output_container_H:

            clear_output()

            seleccionados = list(materiales_widget_H.value)

            if not seleccionados:

                print("No se seleccionó ningún material.")

                return

            print("Materiales seleccionados:")

            for mat in seleccionados:

                print("-", mat)

            qty_widgets_H.clear()

            input_boxes = []

            for mat in seleccionados:

                qty_box = widgets.BoundedFloatText(

                    value=0,

                    min=0,

                    step=1,

                    description=f"Cant: {mat}",

                    layout=widgets.Layout(width='50%')

                )

                qty_widgets_H[mat] = qty_box

                input_boxes.append(qty_box)

            display(widgets.VBox(input_boxes))

            display(apply_qty_button_H)

   

    def on_apply_qty_H(b):

        with output_container_H:

            clear_output()

            if df_H.empty:

                print("El DataFrame está vacío o no se cargó correctamente.")

                return

            selected_materials = list(qty_widgets_H.keys())

            for mat, widget_box in qty_widgets_H.items():

                cant = widget_box.value

                df_H.loc[df_H["2. MATERIAL"].astype(str) == mat, "4.CANTIDAD"] = cant

            assigned_df = df_H[

                df_H["2. MATERIAL"].astype(str).isin(selected_materials) &

                (df_H["4.CANTIDAD"] > 0)

            ]

            if not assigned_df.empty:

                assigned_df_renombrado = renombrar_columnas(assigned_df)

                materiales_finales.append(("FLUJO H", assigned_df_renombrado))

                # print("Materiales del FLUJO H guardados.")  # Desactivado

            else:

                print("No se asignaron cantidades (o todas fueron 0).")

           

            display(final_button_container)

   

    def on_pregunta_change_H(change):

        with output_container_H:

            clear_output()

            if change['new'] == "SI":

                if df_H.empty:

                    print("El DataFrame no se cargó o está vacío.")

                    return

                print("Lista completa de materiales del Excel:\n")

                display(df_H)

                print("\nSeleccione los materiales que desea agregar:")

                display(materiales_widget_H)

                display(apply_selection_button_H)

            elif change['new'] == "NO":

                print("No se agregarán más materiales.")

                display(final_button_container)

   

    pregunta_widget_H.observe(on_pregunta_change_H, names='value')

    apply_selection_button_H.on_click(on_apply_selection_H)

    apply_qty_button_H.on_click(on_apply_qty_H)

   

    display(pregunta_widget_H)

    display(output_container_H)

   

    # print("FLUJO H finalizado. Fin del proceso.")  # Desactivado

 

 

# ===============================

# Función principal: inicia en FLUJO A

# ===============================

def main():

    flujo_A()

 

# Inicia el proceso

main()
```

## docs/Estructura del proyecto.md

- Characters: 6177
- Tokens: 0

```markdown
🔹 1. Introducción
Este documento detalla la arquitectura propuesta para la implementación de un sistema de flujos modulares en una aplicación basada en Python y Flask. El objetivo es permitir la ejecución de múltiples flujos de trabajo (Flujo A, B, C, etc.), en los cuales cada flujo es un módulo independiente que recibe entradas del usuario, filtra datos de archivos Excel, y proporciona salidas que pueden afectar a los siguientes flujos.

🔹 2. Análisis Inicial del Problema
El código original consistía en una serie de filtros aplicados secuencialmente sobre distintos archivos de datos. Cada flujo:

Preguntaba al usuario si debía ejecutarse.
Aplicaba filtros a un conjunto de datos en función de la respuesta.
Mostraba los materiales resultantes.
Determinaba el siguiente flujo a ejecutar.
📌 Conclusión: La lógica de cada flujo era principalmente un filtro condicional sobre un conjunto de datos basado en respuestas del usuario.

Problemas detectados en la implementación inicial
❌ Código monolítico y difícil de extender.
❌ Falta de modularidad: cada flujo estaba acoplado a la lógica general.
❌ No había un manejo centralizado del estado y flujo de datos.

🔹 3. Patrón de Diseño Elegido
Se adoptó una arquitectura basada en plugins combinada con un manejo centralizado del flujo utilizando Flask Sessions. Esto permite:

📌 Modularidad: Cada flujo es un plugin independiente que puede añadirse sin modificar la estructura general.
📌 Flexibilidad: El orden de ejecución se define externamente y no dentro de cada módulo.
📌 Escalabilidad: Es fácil agregar nuevos flujos sin afectar el sistema.
📌 Manejo de Estado: Se utiliza Flask Sessions para almacenar respuestas y materiales seleccionados.
🔹 Patrón de diseño:
Plugin-Based Architecture + State Management
Cada flujo actúa como un plugin independiente y el sistema maneja las transiciones y datos entre ellos.

🔹 4. Arquitectura Resultante
📂 Estructura del Proyecto

/app
  ├── main.py               # Punto de entrada de la aplicación
  ├── flujo_loader.py       # Carga y gestiona los flujos dinámicamente
  ├── plugins/              # Módulos independientes de cada flujo
  │   ├── __init__.py
  │   ├── flujo_a.py        # Flujo A
  │   ├── flujo_b.py        # Flujo B
  │   ├── flujo_c.py        # Flujo C
  │   ├── flujo_d.py        # Flujo D
  │   ├── flujo_e.py        # Flujo E
  │   ├── flujo_f.py        # Flujo F
  │   ├── flujo_g.py        # Flujo G
  │   ├── flujo_h.py        # Flujo H (siempre se ejecuta)
  ├── templates/            # HTML para la interfaz de usuario
  │   ├── base.html
  │   ├── index.html
  │   ├── flujo.html        # Página genérica para cada flujo
  │   ├── resultados.html   # Página de resultados finales
  ├── static/               # Archivos CSS y JS
  ├── data/                 # Archivos Excel
  ├── requirements.txt
  └── README.md
🔹 5. Manejo del Flujo de Ejecución
En lugar de definir el orden de los flujos dentro de cada módulo, se utiliza un diccionario de transición que maneja la lógica centralmente.

📌 Configuración de flujos en flujo_loader.py


SECUENCIA_FLUJOS = {
    "A": {"SI": "H", "NO": "B"},
    "B": {"SI": "C", "NO": "C"},
    "C": {"SI": "D", "NO": "D"},
    "D": {"SI": "E", "NO": "E"},
    "E": {"SI": "G", "NO": "F"},
    "F": {"SI": "H", "NO": "H"},
    "G": {"SI": "H", "NO": "H"},
    "H": None  # Último flujo
}
📌 Cómo funciona:

Cada flujo tiene una entrada (respuesta del usuario).
Se determina el siguiente flujo basado en la respuesta (SI o NO).
Los datos de cada flujo se almacenan en session para ser utilizados en flujos posteriores.
🔹 6. Ejemplo de Flujo Individual
Cada flujo es un módulo independiente en la carpeta plugins/.

📌 Ejemplo de plugins/flujo_a.py

python

from flask import render_template, request

nombre = "A"

def ejecutar():
    if request.method == "POST":
        respuesta = request.form.get("respuesta")
        materiales_seleccionados = ["Material X", "Material Y"] if respuesta == "SI" else []
        return respuesta, materiales_seleccionados

    return render_template("flujo.html", flujo=nombre)
📌 Explicación:

Cada flujo recibe una entrada (POST del usuario).
Si el usuario responde "SI", filtra materiales y los guarda.
Si el usuario responde "NO", se salta el procesamiento.
El sistema decide cuál es el siguiente flujo.
🔹 7. Manejo del Estado Global
Se utiliza Flask Sessions para mantener los datos entre flujos.

📌 Ejemplo de cómo se almacenan los datos en session

python

@app.route("/flujo/<nombre_flujo>", methods=["GET", "POST"])
def flujo(nombre_flujo):
    if nombre_flujo in flujos:
        respuesta, materiales, siguiente_flujo = ejecutar_flujo(nombre_flujo, session)

        # Guardar en sesión
        session[nombre_flujo] = {"respuesta": respuesta, "materiales": materiales}

        # Continuar al siguiente flujo o finalizar
        return redirect(url_for("flujo", nombre_flujo=siguiente_flujo)) if siguiente_flujo else redirect(url_for("resultados"))

    return redirect(url_for("index"))
📌 Beneficios del uso de session ✔ Permite almacenar datos persistentes sin base de datos.
✔ Mantiene la continuidad entre flujos.
✔ Hace que cada flujo sea independiente sin necesidad de modificar otros flujos.

🔹 8. Beneficios de la Arquitectura
Característica	Beneficio
Plugins Modulares	Se pueden agregar nuevos flujos sin modificar main.py.
Configuración Centralizada	El orden de ejecución se define en flujo_loader.py.
Manejo de Estado con session	Cada flujo puede acceder a respuestas y materiales previos.
Separación de Responsabilidades	main.py maneja la app, flujo_loader.py los flujos, y los plugins contienen la lógica específica.
Escalabilidad	Fácil de expandir sin modificar el código existente.
🔹 9. Conclusión
Se pasó de una estructura monolítica a una arquitectura basada en plugins donde:

Cada flujo es un módulo autónomo con entrada y salida.
El flujo de ejecución es gestionado dinámicamente.
Se utiliza session para almacenar respuestas y datos.
Los desarrolladores pueden agregar nuevos flujos sin modificar la estructura base.
Este modelo permite escalabilidad, modularidad y facilidad de mantenimiento, alineándose con buenas prácticas de arquitectura de software.
```

## README.md

- Characters: 1664
- Tokens: 0

````markdown
# Visualizador de Excel

Esta aplicación simple permite visualizar archivos Excel como tablas HTML en un navegador web.

## Requisitos

- Python 3.6 o superior
- pip (gestor de paquetes de Python)


# Configuración y ejecución en VS Code (Windows)
Requisitos previos

Python 3.6 o superior
pip (gestor de paquetes de Python)

Pasos para ejecutar la aplicación
1. Clonar el repositorio

```
git clone [URL_DEL_REPOSITORIO]
cd mi_app
```
2. Crear y activar un entorno virtual

 Crear entorno virtual
```
python -m venv venv
```

# Activar el entorno virtual

```
venv\Scripts\activate
```

4. Preparar los archivos Excel

Coloca tus archivos Excel (.xlsx o .xls) en la carpeta app/data/
Si la carpeta no existe, se creará automáticamente al iniciar la aplicación


#### 5. Iniciar la aplicación
```
python app/main.py
```

#### 6. Acceder a la aplicación

en el navegador
```
 http://127.0.0.1:5000
```
Se veran todos los archivos Excel cargados y podrás iniciar los flujos de trabajo

7. Desactivar el entorno virtual cuando termines
Copydeactivate
Solución de problemas comunes

Error "No module named...": Verifica que el entorno virtual esté activado y que todas las dependencias estén instaladas
Archivos Excel no visibles: Asegúrate de que estén en la carpeta correcta (app/data/) y tengan la extensión correcta (.xlsx o .xls)

3. Abre tu navegador y ve a `http://localhost:5000`

## Notas

- La aplicación mostrará todos los archivos Excel (.xlsx o .xls) encontrados en la carpeta `data`
- Cada archivo se convertirá en una tabla HTML
- Puedes recargar la página para actualizar los datos si agregas nuevos archivos Excel mientras la aplicación está corriendo
````

## .gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## Statistics

- Total Files: 22
- Total Characters: 298276
- Total Tokens: 0
