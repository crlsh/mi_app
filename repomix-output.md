This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-20 18:19:17

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
app
  plugins
    flujo_e.py
    flujo_a.py
    __init__.py
    flujo_d.py
    flujo_c.py
    flujo_g.py
    flujo_f.py
    flujo_b.py
    flujo_h.py
  flujo_loader.py
  .gitignore
  templates
    flujo.html
    resultados.html
    index.html
    excel_viewer.html
  main.py
requirements.txt
repomix-output.md
docs
  Flujo A - Doc tecnico.md
  commentarios del proy.md
  Estructura del proyecto.md
README.md
.gitignore
```

# Repository Files


## app/plugins/flujo_e.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_a.py

- Characters: 1853
- Tokens: 0

```python
import pandas as pd
import os

def ejecutar(respuesta):
    """
    Ejecuta el Flujo A (Ajuste de medida)
    
    Args:
        respuesta (str): "SI" o "NO" seg√∫n la respuesta del usuario
        
    Returns:
        DataFrame: DataFrame con los materiales seleccionados o vac√≠o
    """
    # Si la respuesta es NO, retornar DataFrame vac√≠o
    if respuesta == "NO":
        return pd.DataFrame()
        
    # Si la respuesta es SI, procesar el archivo Excel
    try:
        # Ruta del archivo Excel
        file_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                               "data", "ajuste_de_medida.xlsx")
        
        # Verificar si el archivo existe
        if not os.path.exists(file_path):
            print(f"El archivo {file_path} no existe")
            return pd.DataFrame()
            
        # Cargar el archivo Excel
        df = pd.read_excel(file_path)
        
        # Limpiar los datos
        df.columns = df.columns.str.strip()
        
        # Aqu√≠ ir√≠a la l√≥gica espec√≠fica del Flujo A
        # Por ahora, simplemente retornamos todo el DataFrame
        
        # Renombrar columnas seg√∫n requerimiento
        df_renombrado = df.rename(
            columns={
                "1. C√≥d.SAP": "C√≥d.SAP",
                "2. MATERIAL": "MATERIAL",
                "3. Descripci√≥n": "Descripci√≥n",
                "5.CONDICI√ìN": "CONDICI√ìN"
            }
        )
        
        # Asegurarse de que queden las columnas requeridas
        columnas = ["C√≥d.SAP", "MATERIAL", "Descripci√≥n", "4.CANTIDAD", "CONDICI√ìN"]
        columnas_presentes = [col for col in columnas if col in df_renombrado.columns]
        
        return df_renombrado[columnas_presentes]
        
    except Exception as e:
        print(f"Error en Flujo A: {e}")
        return pd.DataFrame()
```

## app/plugins/__init__.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_d.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_c.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_g.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_f.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_b.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_h.py

- Characters: 0
- Tokens: 0

```python

```

## app/flujo_loader.py

- Characters: 0
- Tokens: 0

```python

```

## app/.gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## app/templates/flujo.html

- Characters: 1116
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Flujo {{ flujo }}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
        form { display: inline-block; text-align: left; }
        label, select { display: block; margin-bottom: 10px; }
        .boton { padding: 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        .tabla { margin-top: 20px; width: 80%; border-collapse: collapse; }
        th, td { border: 1px solid black; padding: 8px; text-align: left; }
    </style>
</head>
<body>

<h1>Flujo {{ flujo }}</h1>

<form method="POST">
    <label>Di√°metro:</label>
    <select name="diametro">
        <option value="TODOS">Todos</option>
        <option value="10">10 mm</option>
        <option value="20">20 mm</option>
    </select>

    <label>Tipo:</label>
    <select name="tipo">
        <option value="TODOS">Todos</option>
        <option value="Acero">Acero</option>
        <option value="Aluminio">Aluminio</option>
    </select>

    <button type="submit" class="boton">Aplicar Filtros</button>
</form>

</body>
</html>
```

## app/templates/resultados.html

- Characters: 1411
- Tokens: 0

```html
<!-- templates/resultados.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Resultados Finales</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        button { 
            padding: 10px; 
            background-color: #4CAF50; 
            color: white; 
            border: none; 
            cursor: pointer; 
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .flujo-section {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Listado final de materiales de todos los flujos ejecutados</h1>
    
    {% for flujo, df in materiales %}
        <div class="flujo-section">
            <h2>{{ flujo }}</h2>
            {% if df.empty %}
                <p>No hay datos disponibles para este flujo.</p>
            {% else %}
                {{ df.to_html(index=False) | safe }}
            {% endif %}
        </div>
    {% endfor %}
    
    <a href="/"><button>Volver al inicio</button></a>
</body>
</html>
```

## app/templates/index.html

- Characters: 1878
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Visualizador de Excel</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 0;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .reload-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            border: none;
            cursor: pointer;
        }
        .reload-btn:hover {
            background-color: #45a049;
        }
        .start-flujo-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #007bff;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }
        .start-flujo-btn:hover {
            background-color: #0056b3;
        }
        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <h1>Visualizador de Excel</h1>
    
    <form action="/" method="get">
        <button type="submit" class="reload-btn">Recargar Datos</button>
    </form>
    
    <div class="container" id="main-content">
        <!-- El contenido se cargar√° aqu√≠ din√°micamente -->
        {% include 'excel_viewer.html' %}
    </div>
    
    {% if tablas %}
        <a href="{{ url_for('flujo', nombre_flujo='A') }}" class="start-flujo-btn">Iniciar Flujo de Selecci√≥n</a>
    {% endif %}
</body>
</html>
```

## app/templates/excel_viewer.html

- Characters: 1302
- Tokens: 0

```html
<!-- templates/components/excel_viewer.html -->
{% if tablas %}
    {% for nombre, tabla_html in tablas %}
        <div class="tabla-contenedor">
            <h2>{{ nombre }}</h2>
            {{ tabla_html | safe }}
        </div>
    {% endfor %}
{% else %}
    <div class="mensaje-vacio">
        <p>No se encontraron archivos Excel en la carpeta "data".</p>
        <p>Por favor, coloque sus archivos Excel en la carpeta "data" y recargue la p√°gina.</p>
    </div>
{% endif %}

<style>
    .tabla-contenedor {
        margin-bottom: 40px;
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h2 {
        color: #4CAF50;
        margin-top: 0;
    }
    .table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
    }
    .table th {
        background-color: #4CAF50;
        color: white;
        padding: 10px;
        text-align: left;
    }
    .table td {
        border: 1px solid #ddd;
        padding: 8px;
    }
    .table-striped tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    .mensaje-vacio {
        text-align: center;
        padding: 20px;
        background-color: #f8f9fa;
        border-radius: 5px;
        color: #6c757d;
    }
</style>
```

## requirements.txt

- Characters: 55
- Tokens: 0

```text
flask==2.3.3
openpyxl==3.1.2
pandas
xlrd==2.0.1
repomix
```

## repomix-output.md

- Characters: 224833
- Tokens: 0

``````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-20 14:53:00

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
app
  plugins
    flujo_e.py
    flujo_a.py
    __init__.py
    flujo_d.py
    flujo_c.py
    flujo_g.py
    flujo_f.py
    flujo_b.py
    flujo_h.py
  flujo_loader.py
  .gitignore
  templates
    flujo.html
    resultados.html
    index.html
  main.py
requirements.txt
repomix-output.md
docs
  Flujo A - Doc tecnico.md
  commentarios del proy.md
  Estructura del proyecto.md
README.md
.gitignore
```

# Repository Files


## app/plugins/flujo_e.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_a.py

- Characters: 1853
- Tokens: 0

```python
import pandas as pd
import os

def ejecutar(respuesta):
    """
    Ejecuta el Flujo A (Ajuste de medida)
    
    Args:
        respuesta (str): "SI" o "NO" seg√∫n la respuesta del usuario
        
    Returns:
        DataFrame: DataFrame con los materiales seleccionados o vac√≠o
    """
    # Si la respuesta es NO, retornar DataFrame vac√≠o
    if respuesta == "NO":
        return pd.DataFrame()
        
    # Si la respuesta es SI, procesar el archivo Excel
    try:
        # Ruta del archivo Excel
        file_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                               "data", "ajuste_de_medida.xlsx")
        
        # Verificar si el archivo existe
        if not os.path.exists(file_path):
            print(f"El archivo {file_path} no existe")
            return pd.DataFrame()
            
        # Cargar el archivo Excel
        df = pd.read_excel(file_path)
        
        # Limpiar los datos
        df.columns = df.columns.str.strip()
        
        # Aqu√≠ ir√≠a la l√≥gica espec√≠fica del Flujo A
        # Por ahora, simplemente retornamos todo el DataFrame
        
        # Renombrar columnas seg√∫n requerimiento
        df_renombrado = df.rename(
            columns={
                "1. C√≥d.SAP": "C√≥d.SAP",
                "2. MATERIAL": "MATERIAL",
                "3. Descripci√≥n": "Descripci√≥n",
                "5.CONDICI√ìN": "CONDICI√ìN"
            }
        )
        
        # Asegurarse de que queden las columnas requeridas
        columnas = ["C√≥d.SAP", "MATERIAL", "Descripci√≥n", "4.CANTIDAD", "CONDICI√ìN"]
        columnas_presentes = [col for col in columnas if col in df_renombrado.columns]
        
        return df_renombrado[columnas_presentes]
        
    except Exception as e:
        print(f"Error en Flujo A: {e}")
        return pd.DataFrame()
```

## app/plugins/__init__.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_d.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_c.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_g.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_f.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_b.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_h.py

- Characters: 0
- Tokens: 0

```python

```

## app/flujo_loader.py

- Characters: 0
- Tokens: 0

```python

```

## app/.gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## app/templates/flujo.html

- Characters: 1116
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Flujo {{ flujo }}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
        form { display: inline-block; text-align: left; }
        label, select { display: block; margin-bottom: 10px; }
        .boton { padding: 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        .tabla { margin-top: 20px; width: 80%; border-collapse: collapse; }
        th, td { border: 1px solid black; padding: 8px; text-align: left; }
    </style>
</head>
<body>

<h1>Flujo {{ flujo }}</h1>

<form method="POST">
    <label>Di√°metro:</label>
    <select name="diametro">
        <option value="TODOS">Todos</option>
        <option value="10">10 mm</option>
        <option value="20">20 mm</option>
    </select>

    <label>Tipo:</label>
    <select name="tipo">
        <option value="TODOS">Todos</option>
        <option value="Acero">Acero</option>
        <option value="Aluminio">Aluminio</option>
    </select>

    <button type="submit" class="boton">Aplicar Filtros</button>
</form>

</body>
</html>
```

## app/templates/resultados.html

- Characters: 1411
- Tokens: 0

```html
<!-- templates/resultados.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Resultados Finales</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        button { 
            padding: 10px; 
            background-color: #4CAF50; 
            color: white; 
            border: none; 
            cursor: pointer; 
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .flujo-section {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Listado final de materiales de todos los flujos ejecutados</h1>
    
    {% for flujo, df in materiales %}
        <div class="flujo-section">
            <h2>{{ flujo }}</h2>
            {% if df.empty %}
                <p>No hay datos disponibles para este flujo.</p>
            {% else %}
                {{ df.to_html(index=False) | safe }}
            {% endif %}
        </div>
    {% endfor %}
    
    <a href="/"><button>Volver al inicio</button></a>
</body>
</html>
```

## app/templates/index.html

- Characters: 2996
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Visualizador de Excel</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 0;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .tabla-contenedor {
            margin-bottom: 40px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #4CAF50;
            margin-top: 0;
        }
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        .table th {
            background-color: #4CAF50;
            color: white;
            padding: 10px;
            text-align: left;
        }
        .table td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        .table-striped tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .mensaje-vacio {
            text-align: center;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 5px;
            color: #6c757d;
        }
        .reload-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            border: none;
            cursor: pointer;
        }
        .reload-btn:hover {
            background-color: #45a049;
        }
        .start-flujo-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #007bff;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }
        .start-flujo-btn:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <h1>Visualizador de Excel</h1>
    
    <form action="/" method="get">
        <button type="submit" class="reload-btn">Recargar Datos</button>
    </form>
    
    {% if tablas %}
        {% for nombre, tabla_html in tablas %}
            <div class="tabla-contenedor">
                <h2>{{ nombre }}</h2>
                {{ tabla_html | safe }}
            </div>
        {% endfor %}
        <a href="{{ url_for('flujo', nombre_flujo='A') }}" class="start-flujo-btn">Iniciar Flujo de Selecci√≥n</a>
    {% else %}
        <div class="mensaje-vacio">
            <p>No se encontraron archivos Excel en la carpeta "data".</p>
            <p>Por favor, coloque sus archivos Excel en la carpeta "data" y recargue la p√°gina.</p>
        </div>
    {% endif %}
</body>
</html>
```

## requirements.txt

- Characters: 55
- Tokens: 0

```text
flask==2.3.3
openpyxl==3.1.2
pandas
xlrd==2.0.1
repomix
```

## repomix-output.md

- Characters: 150044
- Tokens: 0

`````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-19 17:54:36

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
app
  plugins
    flujo_e.py
    flujo_a.py
    __init__.py
    flujo_d.py
    flujo_c.py
    flujo_g.py
    flujo_f.py
    flujo_b.py
    flujo_h.py
  flujo_loader.py
  .gitignore
  templates
    flujo.html
    resultados.html
    index.html
  main.py
requirements.txt
repomix-output.md
docs
  Flujo A - Doc tecnico.md
  commentarios del proy.md
  Estructura del proyecto.md
README.md
.gitignore
```

# Repository Files


## app/plugins/flujo_e.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_a.py

- Characters: 1853
- Tokens: 0

```python
import pandas as pd
import os

def ejecutar(respuesta):
    """
    Ejecuta el Flujo A (Ajuste de medida)
    
    Args:
        respuesta (str): "SI" o "NO" seg√∫n la respuesta del usuario
        
    Returns:
        DataFrame: DataFrame con los materiales seleccionados o vac√≠o
    """
    # Si la respuesta es NO, retornar DataFrame vac√≠o
    if respuesta == "NO":
        return pd.DataFrame()
        
    # Si la respuesta es SI, procesar el archivo Excel
    try:
        # Ruta del archivo Excel
        file_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                               "data", "ajuste_de_medida.xlsx")
        
        # Verificar si el archivo existe
        if not os.path.exists(file_path):
            print(f"El archivo {file_path} no existe")
            return pd.DataFrame()
            
        # Cargar el archivo Excel
        df = pd.read_excel(file_path)
        
        # Limpiar los datos
        df.columns = df.columns.str.strip()
        
        # Aqu√≠ ir√≠a la l√≥gica espec√≠fica del Flujo A
        # Por ahora, simplemente retornamos todo el DataFrame
        
        # Renombrar columnas seg√∫n requerimiento
        df_renombrado = df.rename(
            columns={
                "1. C√≥d.SAP": "C√≥d.SAP",
                "2. MATERIAL": "MATERIAL",
                "3. Descripci√≥n": "Descripci√≥n",
                "5.CONDICI√ìN": "CONDICI√ìN"
            }
        )
        
        # Asegurarse de que queden las columnas requeridas
        columnas = ["C√≥d.SAP", "MATERIAL", "Descripci√≥n", "4.CANTIDAD", "CONDICI√ìN"]
        columnas_presentes = [col for col in columnas if col in df_renombrado.columns]
        
        return df_renombrado[columnas_presentes]
        
    except Exception as e:
        print(f"Error en Flujo A: {e}")
        return pd.DataFrame()
```

## app/plugins/__init__.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_d.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_c.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_g.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_f.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_b.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_h.py

- Characters: 0
- Tokens: 0

```python

```

## app/flujo_loader.py

- Characters: 0
- Tokens: 0

```python

```

## app/.gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## app/templates/flujo.html

- Characters: 1116
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Flujo {{ flujo }}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
        form { display: inline-block; text-align: left; }
        label, select { display: block; margin-bottom: 10px; }
        .boton { padding: 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        .tabla { margin-top: 20px; width: 80%; border-collapse: collapse; }
        th, td { border: 1px solid black; padding: 8px; text-align: left; }
    </style>
</head>
<body>

<h1>Flujo {{ flujo }}</h1>

<form method="POST">
    <label>Di√°metro:</label>
    <select name="diametro">
        <option value="TODOS">Todos</option>
        <option value="10">10 mm</option>
        <option value="20">20 mm</option>
    </select>

    <label>Tipo:</label>
    <select name="tipo">
        <option value="TODOS">Todos</option>
        <option value="Acero">Acero</option>
        <option value="Aluminio">Aluminio</option>
    </select>

    <button type="submit" class="boton">Aplicar Filtros</button>
</form>

</body>
</html>
```

## app/templates/resultados.html

- Characters: 1411
- Tokens: 0

```html
<!-- templates/resultados.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Resultados Finales</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        button { 
            padding: 10px; 
            background-color: #4CAF50; 
            color: white; 
            border: none; 
            cursor: pointer; 
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .flujo-section {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Listado final de materiales de todos los flujos ejecutados</h1>
    
    {% for flujo, df in materiales %}
        <div class="flujo-section">
            <h2>{{ flujo }}</h2>
            {% if df.empty %}
                <p>No hay datos disponibles para este flujo.</p>
            {% else %}
                {{ df.to_html(index=False) | safe }}
            {% endif %}
        </div>
    {% endfor %}
    
    <a href="/"><button>Volver al inicio</button></a>
</body>
</html>
```

## app/templates/index.html

- Characters: 2996
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Visualizador de Excel</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 0;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .tabla-contenedor {
            margin-bottom: 40px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #4CAF50;
            margin-top: 0;
        }
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        .table th {
            background-color: #4CAF50;
            color: white;
            padding: 10px;
            text-align: left;
        }
        .table td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        .table-striped tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .mensaje-vacio {
            text-align: center;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 5px;
            color: #6c757d;
        }
        .reload-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            border: none;
            cursor: pointer;
        }
        .reload-btn:hover {
            background-color: #45a049;
        }
        .start-flujo-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #007bff;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }
        .start-flujo-btn:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <h1>Visualizador de Excel</h1>
    
    <form action="/" method="get">
        <button type="submit" class="reload-btn">Recargar Datos</button>
    </form>
    
    {% if tablas %}
        {% for nombre, tabla_html in tablas %}
            <div class="tabla-contenedor">
                <h2>{{ nombre }}</h2>
                {{ tabla_html | safe }}
            </div>
        {% endfor %}
        <a href="{{ url_for('flujo', nombre_flujo='A') }}" class="start-flujo-btn">Iniciar Flujo de Selecci√≥n</a>
    {% else %}
        <div class="mensaje-vacio">
            <p>No se encontraron archivos Excel en la carpeta "data".</p>
            <p>Por favor, coloque sus archivos Excel en la carpeta "data" y recargue la p√°gina.</p>
        </div>
    {% endif %}
</body>
</html>
```

## requirements.txt

- Characters: 55
- Tokens: 0

```text
flask==2.3.3
openpyxl==3.1.2
pandas
xlrd==2.0.1
repomix
```

## repomix-output.md

- Characters: 75258
- Tokens: 0

````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-19 16:55:51

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
app
  plugins
    flujo_e.py
    flujo_a.py
    __init__.py
    flujo_d.py
    flujo_c.py
    flujo_g.py
    flujo_f.py
    flujo_b.py
    flujo_h.py
  flujo_loader.py
  .gitignore
  templates
    flujo.html
    resultados.html
    index.html
  main.py
requirements.txt
docs
  Flujo A - Doc tecnico.md
  commentarios del proy.md
  Estructura del proyecto.md
README.md
.gitignore
```

# Repository Files


## app/plugins/flujo_e.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_a.py

- Characters: 1853
- Tokens: 0

```python
import pandas as pd
import os

def ejecutar(respuesta):
    """
    Ejecuta el Flujo A (Ajuste de medida)
    
    Args:
        respuesta (str): "SI" o "NO" seg√∫n la respuesta del usuario
        
    Returns:
        DataFrame: DataFrame con los materiales seleccionados o vac√≠o
    """
    # Si la respuesta es NO, retornar DataFrame vac√≠o
    if respuesta == "NO":
        return pd.DataFrame()
        
    # Si la respuesta es SI, procesar el archivo Excel
    try:
        # Ruta del archivo Excel
        file_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                               "data", "ajuste_de_medida.xlsx")
        
        # Verificar si el archivo existe
        if not os.path.exists(file_path):
            print(f"El archivo {file_path} no existe")
            return pd.DataFrame()
            
        # Cargar el archivo Excel
        df = pd.read_excel(file_path)
        
        # Limpiar los datos
        df.columns = df.columns.str.strip()
        
        # Aqu√≠ ir√≠a la l√≥gica espec√≠fica del Flujo A
        # Por ahora, simplemente retornamos todo el DataFrame
        
        # Renombrar columnas seg√∫n requerimiento
        df_renombrado = df.rename(
            columns={
                "1. C√≥d.SAP": "C√≥d.SAP",
                "2. MATERIAL": "MATERIAL",
                "3. Descripci√≥n": "Descripci√≥n",
                "5.CONDICI√ìN": "CONDICI√ìN"
            }
        )
        
        # Asegurarse de que queden las columnas requeridas
        columnas = ["C√≥d.SAP", "MATERIAL", "Descripci√≥n", "4.CANTIDAD", "CONDICI√ìN"]
        columnas_presentes = [col for col in columnas if col in df_renombrado.columns]
        
        return df_renombrado[columnas_presentes]
        
    except Exception as e:
        print(f"Error en Flujo A: {e}")
        return pd.DataFrame()
```

## app/plugins/__init__.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_d.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_c.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_g.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_f.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_b.py

- Characters: 0
- Tokens: 0

```python

```

## app/plugins/flujo_h.py

- Characters: 0
- Tokens: 0

```python

```

## app/flujo_loader.py

- Characters: 0
- Tokens: 0

```python

```

## app/.gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## app/templates/flujo.html

- Characters: 1682
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Flujo A - Ajuste de Medida</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
        form { display: inline-block; text-align: left; }
        label, select { display: block; margin-bottom: 10px; }
        .boton { padding: 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        .tabla { margin-top: 20px; width: 80%; border-collapse: collapse; }
        th, td { border: 1px solid black; padding: 8px; text-align: left; }
    </style>
</head>
<body>

<h1>Flujo A - Ajuste de Medida</h1>

<form method="POST">
    <label>Di√°metro:</label>
    <select name="diametro">
        <option value="TODOS">Todos</option>
        <option value="10">10 mm</option>
        <option value="20">20 mm</option>
    </select>

    <label>Tipo:</label>
    <select name="tipo">
        <option value="TODOS">Todos</option>
        <option value="Acero">Acero</option>
        <option value="Aluminio">Aluminio</option>
    </select>

    <button type="submit" class="boton">Aplicar Filtros</button>
</form>

{% if materiales is not none %}
    <h2>Materiales Filtrados</h2>
    <table class="tabla">
        <tr>
            <th>Di√°metro</th>
            <th>Tipo</th>
            <th>Grado de Acero</th>
        </tr>
        {% for index, row in materiales.iterrows() %}
        <tr>
            <td>{{ row["DI√ÅMETRO"] }}</td>
            <td>{{ row["TIPO"] }}</td>
            <td>{{ row["GRADO DE ACERO"] }}</td>
        </tr>
        {% endfor %}
    </table>
    <a href="/flujo_h"><button class="boton">Continuar a Flujo H</button></a>
{% endif %}

</body>
</html>
```

## app/templates/resultados.html

- Characters: 1411
- Tokens: 0

```html
<!-- templates/resultados.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Resultados Finales</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        button { 
            padding: 10px; 
            background-color: #4CAF50; 
            color: white; 
            border: none; 
            cursor: pointer; 
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .flujo-section {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Listado final de materiales de todos los flujos ejecutados</h1>
    
    {% for flujo, df in materiales %}
        <div class="flujo-section">
            <h2>{{ flujo }}</h2>
            {% if df.empty %}
                <p>No hay datos disponibles para este flujo.</p>
            {% else %}
                {{ df.to_html(index=False) | safe }}
            {% endif %}
        </div>
    {% endfor %}
    
    <a href="/"><button>Volver al inicio</button></a>
</body>
</html>
```

## app/templates/index.html

- Characters: 2996
- Tokens: 0

```html
<!DOCTYPE html>
<html>
<head>
    <title>Visualizador de Excel</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 0;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .tabla-contenedor {
            margin-bottom: 40px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #4CAF50;
            margin-top: 0;
        }
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        .table th {
            background-color: #4CAF50;
            color: white;
            padding: 10px;
            text-align: left;
        }
        .table td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        .table-striped tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .mensaje-vacio {
            text-align: center;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 5px;
            color: #6c757d;
        }
        .reload-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            border: none;
            cursor: pointer;
        }
        .reload-btn:hover {
            background-color: #45a049;
        }
        .start-flujo-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #007bff;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }
        .start-flujo-btn:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <h1>Visualizador de Excel</h1>
    
    <form action="/" method="get">
        <button type="submit" class="reload-btn">Recargar Datos</button>
    </form>
    
    {% if tablas %}
        {% for nombre, tabla_html in tablas %}
            <div class="tabla-contenedor">
                <h2>{{ nombre }}</h2>
                {{ tabla_html | safe }}
            </div>
        {% endfor %}
        <a href="{{ url_for('flujo', nombre_flujo='A') }}" class="start-flujo-btn">Iniciar Flujo de Selecci√≥n</a>
    {% else %}
        <div class="mensaje-vacio">
            <p>No se encontraron archivos Excel en la carpeta "data".</p>
            <p>Por favor, coloque sus archivos Excel en la carpeta "data" y recargue la p√°gina.</p>
        </div>
    {% endif %}
</body>
</html>
```

## requirements.txt

- Characters: 55
- Tokens: 0

```text
flask==2.3.3
openpyxl==3.1.2
pandas
xlrd==2.0.1
repomix
```

## docs/Flujo A - Doc tecnico.md

- Characters: 2871
- Tokens: 0

```markdown
üìå Especificaci√≥n T√©cnica para Desarrollo ‚Äì FLUJO A (Ajuste de Medida)
1Ô∏è‚É£ Descripci√≥n General
FLUJO A permite al usuario seleccionar materiales basados en criterios espec√≠ficos de ajuste de medida. Si el usuario acepta el ajuste, el flujo filtra los materiales y salta directamente a FLUJO H. Si el usuario rechaza, salta a FLUJO B sin procesar datos.

2Ô∏è‚É£ Datos de Entrada
La informaci√≥n proviene de una tabla estructurada (ajuste_de_medida.xlsx), con las siguientes columnas clave:

Columna	Tipo	Descripci√≥n
DI√ÅMETRO	string	Di√°metro del material
TIPO	string	Tipo de material
GRADO DE ACERO	string	Grado de acero
GRADO DE ACERO CUPLA	string	Grado de acero de la cupla
TIPO DE CUPLA	string	Tipo de cupla
4.CANTIDAD	float	Cantidad del material (opcional)
3Ô∏è‚É£ Flujo de Ejecuci√≥n
Pregunta al usuario:

Si responde "NO" ‚Üí Salta directamente a FLUJO B.
Si responde "S√ç" ‚Üí Carga la tabla y aplica filtros.
Carga y Filtrado de Datos:

Carga la tabla ajuste_de_medida.xlsx y limpia valores.
El usuario selecciona valores en los siguientes filtros:
DI√ÅMETRO
TIPO
GRADO DE ACERO
GRADO DE ACERO CUPLA
TIPO DE CUPLA
Si el usuario no selecciona un valor, se usa "TODOS" como fallback.
Construcci√≥n de final_condition (m√°scara booleana de filtrado):

Inicializa final_condition con False para excluir todos los registros.
Para cada DI√ÅMETRO seleccionado, eval√∫a si los materiales cumplen con los criterios del usuario.
Incluye "TODOS" en cada filtro para garantizar que los valores no seleccionados no eliminen registros √∫tiles.
Se combinan las condiciones (| l√≥gico) para crear el filtro final.
Aplicaci√≥n del Filtro:

python
Copy
Edit
final_df = df[final_condition]
Solo quedan los materiales que cumplen con los criterios del usuario.
Almacena los materiales filtrados en materiales_finales:

python
Copy
Edit
materiales_finales.append(("FLUJO A", final_df_renombrado))
Salto a FLUJO H (el flujo no sigue la secuencia normal):

Si el usuario ejecuta FLUJO A, no sigue a FLUJO B, sino directamente a FLUJO H.
4Ô∏è‚É£ Consideraciones T√©cnicas
‚úî No modifica la estructura de la tabla, solo aplica filtros.
‚úî Debe permitir m√∫ltiples selecciones en cada filtro.
‚úî Evita p√©rdida de datos con "TODOS" en cada condici√≥n.
‚úî Encapsular final_condition como l√≥gica reutilizable para otros flujos.
‚úî Optimizar el acceso a archivos si se requiere ejecuci√≥n frecuente.

üìå Resumen Final
FLUJO A solo se ejecuta si el usuario dice "S√ç".
Carga una tabla de materiales y filtra datos seg√∫n selecci√≥n del usuario.
Almacena los materiales seleccionados y salta directamente a FLUJO H.
Si el usuario dice "NO", salta a FLUJO B sin procesar nada.
final_condition es el mecanismo que define qu√© materiales quedan en la selecci√≥n final.
üöÄ Resultado esperado: Un m√≥dulo optimizado que procesa materiales en base a filtros din√°micos y garantiza la continuidad del flujo sin interrumpir la secuencia de ejecuci√≥n.
```

## docs/commentarios del proy.md

- Characters: 52736
- Tokens: 0

```markdown
engo varios c√≥digos por separado que representan diferentes flujos para la selecci√≥n de materiales en la intervenci√≥n de un pozo petrolero: FLUJO A, FLUJO B, FLUJO C, FLUJO D, FLUJO E, FLUJO F, FLUJO G y FLUJO H. Cada uno de ellos inicia con una pregunta que, si el usuario responde ‚ÄúNO‚Äù, salta inmediatamente al siguiente flujo; y si el usuario responde ‚ÄúS√ç‚Äù, entonces ejecuta su l√≥gica, imprime una lista de materiales y luego avanza al siguiente flujo.

Los flujos se llaman y se encadenan de la siguiente forma:

FLUJO A (Ajuste de medida)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO H.
Si el usuario responde NO , salta a FLUJO B.
FLUJO B (Tubo de saca)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO C.
Si el usuario responde NO , salta a FLUJO C.
FLUJO C (tuber√≠a de Baja)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO D.
Si el usuario responde NO , salta a FLUJO D.
FLUJO D (Profundiza)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO E.
Si el usuario responde NO , salta a FLUJO E.
FLUJO E (Baja varillas)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO G.
Luego de terminar FLUJO G , debe continuar a FLUJO H .
Si el usuario responde NO , salta a FLUJO F , y al terminar FLUJO F , avanza a FLUJO H.
FLUJO F (Abandona pozo)
Luego de terminar (sea cual sea la respuesta, si aplica), avanza a FLUJO H .
FLUJO G (Instalaci√≥n BM)
Cuando termine este flujo, avanza a FLUJO H.
FLUJO H (Material de agregaci√≥n)
No es condicional: se supone que, al llegar aqu√≠, se ejecuta y finaliza.
El resultado deseado es un √∫nico script de Python que combina estos ocho flujos en el orden descrito y respeta las condiciones de salto (S√ç/NO). Cada flujo debe:

Preguntar al usuario si desea ejecutar ese flujo (excepto FLUJO H, que siempre se ejecuta al llegar).
Si responde S√ç: ejecute la l√≥gica interna de ese flujo (por ejemplo, las preguntas o procesos que inclu√≠an), e imprima la lista de materiales correspondientes.
Terminar ese flujo y, en lugar de salirse del programa, encadenar inmediatamente con el siguiente flujo indicado.
Si responde NO: saltarse la ejecuci√≥n de ese flujo (no imprime materiales) y avanzar al siguiente flujo, salvo en el caso de FLUJO A y FLUJO E, que ya tienen desv√≠os particulares a otros flujos.


EL CODIGO EJECUTADO EN JUPYTER ES: ESTA UN POCO DESPROLIJO, PERO BUENO AL MENOS FUNCIONA


import os

import pandas as pd

import ipywidgets as widgets

from IPython.display import display, clear_output

 

# Variable global para almacenar los DataFrames finales de cada flujo

materiales_finales = []

 

# Funci√≥n para renombrar las columnas y dejar solo las 5 requeridas

def renombrar_columnas(df):

    df_renombrado = df.rename(

        columns={

            "1. C√≥d.SAP": "C√≥d.SAP",

            "2. MATERIAL": "MATERIAL",

            "3. Descripci√≥n": "Descripci√≥n",

            "5.CONDICI√ìN": "CONDICI√ìN"

        }

    )

    # Asegurarse de que queden las siguientes columnas

    columnas = ["C√≥d.SAP", "MATERIAL", "Descripci√≥n", "4.CANTIDAD", "CONDICI√ìN"]

    columnas_presentes = [col for col in columnas if col in df_renombrado.columns]

    return df_renombrado[columnas_presentes]

 

# ===============================

# FLUJO A: Ajuste de medida

# ===============================

def flujo_A():

    clear_output()

    print("FLUJO A: Ajuste de medida")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¬øAjuste de medida?",

        value="seleccionar"

    )

   

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\ajuste de medida.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DI√ÅMETRO"] = df["DI√ÅMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DI√ÅMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DI√ÅMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

       

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay TIPO disponibles. Se usar√° 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

       

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay valores para {columna}. Se usar√° 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

       

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DI√ÅMETRO: {diam_value}")

       

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

       

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

       

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DI√ÅMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False] * len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False] * len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DI√ÅMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                # En lugar de mostrar inmediatamente, se almacena el DataFrame renombrado

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO A", final_df_renombrado))

                # print("Materiales del FLUJO A guardados.")  # Desactivado

               

                # Bot√≥n para continuar a FLUJO H (ya que en FLUJO A si se responde SI se salta directamente a H)

                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                def on_continue(b):

                    flujo_H()

                continue_button.on_click(on_continue)

                display(continue_button)

       

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccion√≥ NO en FLUJO A. Saltando a FLUJO B...")  # Desactivado

                flujo_B()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO B: Tubo de saca

# ===============================

def flujo_B():

    clear_output()

    print("FLUJO B: Tubo de saca")

    folder_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales"

    filename_saca = "saca tubing.xlsx"

    file_path_saca = os.path.join(folder_path, filename_saca)

    global df_saca_tubing

    df_saca_tubing = None

 

    def load_saca_tubing_excel():

        global df_saca_tubing

        if not os.path.exists(file_path_saca):

            print(f"El archivo {file_path_saca} no se encontr√≥.")

            return

        df_tmp = pd.read_excel(file_path_saca)

        df_tmp.columns = df_tmp.columns.str.strip()

        for c in df_tmp.columns:

            if df_tmp[c].dtype == object:

                df_tmp[c] = df_tmp[c].astype(str).str.strip()

        df_saca_tubing = df_tmp.copy()

        diametro_multi_picker.options = sorted(

            [d for d in df_saca_tubing['DI√ÅMETRO'].unique() if d.upper() != 'TODOS']

        )

 

    diametro_multi_picker = widgets.SelectMultiple(

        options=[],

        description='DI√ÅMETRO:',

        style={'description_width': 'initial'}

    )

    confirm_diameter_button = widgets.Button(

        description='Confirmar di√°metros',

        button_style='info'

    )

    quantities_container = widgets.VBox()

    final_output = widgets.Output()

    show_table_button = widgets.Button(

        description='Mostrar tabla final',

        button_style='success'

    )

 

    def on_show_table_button_clicked(b):

        with final_output:

            clear_output()

            if df_saca_tubing is None:

                print("No hay datos cargados de saca tubing.")

                return

            selected_diameters = list(diametro_multi_picker.value)

            df_filtered = df_saca_tubing[

                (df_saca_tubing['DI√ÅMETRO'].isin(selected_diameters)) |

                (df_saca_tubing['DI√ÅMETRO'].str.upper() == 'TODOS')

            ].copy()

            for child in quantities_container.children:

                dia = child.description

                cantidad = child.value

                mask = (df_filtered['DI√ÅMETRO'] == dia)

                df_filtered.loc[mask, '4.CANTIDAD'] = cantidad

            df_filtered_renombrado = renombrar_columnas(df_filtered)

            materiales_finales.append(("FLUJO B", df_filtered_renombrado))

            print("Materiales del FLUJO B guardados.")

 

        # Cierra la interfaz de FLUJO B

        multi_select_container.close()

 

        # Muestra el bot√≥n para continuar al FLUJO C

        continue_button = widgets.Button(

            description="Continuar a FLUJO C",

            button_style="success"

        )

        def on_continue(b):

            clear_output()

            flujo_C()

        continue_button.on_click(on_continue)

        display(continue_button)

 

    show_table_button.on_click(on_show_table_button_clicked)

 

    def on_confirm_diameter_button_clicked(b):

        with final_output:

            clear_output()

        quantities_container.children = []

        for dia in diametro_multi_picker.value:

            qty_widget = widgets.IntText(

                value=0,

                description=dia,

                style={'description_width': 'initial'}

            )

            quantities_container.children += (qty_widget,)

 

    confirm_diameter_button.on_click(on_confirm_diameter_button_clicked)

 

    multi_select_container = widgets.VBox([

        diametro_multi_picker,

        confirm_diameter_button,

        quantities_container,

        show_table_button,

        final_output

    ])

 

    bajara_tubing_picker = widgets.Dropdown(

        options=["Seleccione opci√≥n", "SI", "NO"],

        value="Seleccione opci√≥n",

        description="¬øsaca Tubing?:"

    )

 

    def on_bajara_tubing_change(change):

        clear_output()

        if change['new'] == "SI":

            load_saca_tubing_excel()

            display(multi_select_container)

        elif change['new'] == "NO":

            print("No se saca tubing.")

            flujo_C()

 

    bajara_tubing_picker.observe(on_bajara_tubing_change, names='value')

 

    print("¬øSaca Tubing?")

    display(bajara_tubing_picker)

 

# ===============================

# FLUJO C: Tuber√≠a de Baja

# ===============================

def flujo_C():

    clear_output()

    print("FLUJO C: Tuber√≠a de Baja")

    file_path_baja = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja tubing.xlsx"

    global df_baja_tubing

    df_baja_tubing = None

    output = widgets.Output()

    baja_tubing_widget = widgets.ToggleButtons(

        options=['SI', 'NO'],

        description='¬øBaja Tubing?',

        disabled=False,

        value=None

    )

    display(baja_tubing_widget, output)

   

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_baja):

                print(f"El archivo no se encontr√≥ en la ruta:\n{file_path_baja}")

                return False

            try:

                df = pd.read_excel(file_path_baja)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DI√ÅMETRO CSG' in df.columns:

                    df['DI√ÅMETRO CSG'] = df['DI√ÅMETRO CSG'].replace('nan', '').fillna('')

                global df_baja_tubing

                df_baja_tubing = df.copy()

                print("Archivo cargado y limpiado con √©xito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

   

    def show_diametro_selection():

        with output:

            print("\n--- Selecci√≥n de DI√ÅMETRO ---")

            df = df_baja_tubing

            unique_diametros = sorted([x for x in df['DI√ÅMETRO'].unique() if x != "TODOS"])

            diametro_widget = widgets.SelectMultiple(

                options=unique_diametros,

                value=(),

                description="DI√ÅMETRO",

                layout=widgets.Layout(width='50%')

            )

            display(diametro_widget)

            button_diametro = widgets.Button(description="Siguiente - Selecci√≥n DI√ÅMETRO")

            display(button_diametro)

           

            def on_diametro_button_clicked(_):

                selected = list(diametro_widget.value)

                selected_diametros = ["TODOS"] if not selected else selected

                show_tipo_accordion(selected_diametros)

            button_diametro.on_click(on_diametro_button_clicked)

   

    def show_tipo_accordion(selected_diametros):

        with output:

            print("\n--- Selecci√≥n de TIPO para cada DI√ÅMETRO ---")

            df = df_baja_tubing

            tipo_widgets = {}

            children = []

            titles = []

            for d in selected_diametros:

                df_temp = df if d=="TODOS" else df[df['DI√ÅMETRO'] == d]

                unique_tipos = sorted([x for x in df_temp['TIPO'].unique() if x != "TODOS"])

                widget_t = widgets.SelectMultiple(

                    options=unique_tipos,

                    value=(),

                    description=f"TIPO ({d})",

                    layout=widgets.Layout(width='50%')

                )

                tipo_widgets[d] = widget_t

                children.append(widget_t)

                titles.append(f"DI√ÅMETRO: {d}")

            accordion = widgets.Accordion(children=children)

            for idx, title in enumerate(titles):

                accordion.set_title(idx, title)

            display(accordion)

            button_tipo = widgets.Button(description="Siguiente - Selecci√≥n TIPO")

            display(button_tipo)

           

            def on_tipo_button_clicked(_):

                selected_tipos_dict = {}

                for d, widget_t in tipo_widgets.items():

                    st = list(widget_t.value)

                    if not st:

                        st = ["TODOS"]

                    selected_tipos_dict[d] = st

                show_diametro_csg_selection(selected_diametros, selected_tipos_dict)

            button_tipo.on_click(on_tipo_button_clicked)

   

    def show_diametro_csg_selection(selected_diametros, selected_tipos_dict):

        with output:

            print("\n--- Selecci√≥n de DI√ÅMETRO CSG ---")

            df = df_baja_tubing

            union_tipos = set()

            for tlist in selected_tipos_dict.values():

                if tlist == ["TODOS"]:

                    union_tipos.add("TODOS")

                else:

                    union_tipos.update(tlist)

                    union_tipos.add("TODOS")

            diam_filter = ["TODOS"] if selected_diametros == ["TODOS"] else selected_diametros + ["TODOS"]

            df_filtered = df[df['DI√ÅMETRO'].isin(diam_filter) & df['TIPO'].isin(union_tipos)]

            unique_csg = sorted([x for x in df_filtered['DI√ÅMETRO CSG'].unique() if x != "TODOS"])

            if not unique_csg:

                print("Nota: Solo 'TODOS' disponible para DI√ÅMETRO CSG. Se procede autom√°ticamente.")

                show_quantity_inputs(selected_diametros, selected_tipos_dict, ["TODOS"])

            else:

                csg_widget = widgets.Dropdown(

                    options=unique_csg,

                    value=unique_csg[0],

                    description="DI√ÅMETRO CSG",

                    layout=widgets.Layout(width='50%')

                )

                display(csg_widget)

                button_csg = widgets.Button(description="Siguiente - Selecci√≥n DI√ÅMETRO CSG")

                display(button_csg)

               

                def on_csg_button_clicked(_):

                    selected_csg = csg_widget.value

                    selected_csg_filter = [selected_csg, "TODOS"] if selected_csg != "TODOS" else ["TODOS"]

                    show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter)

                button_csg.on_click(on_csg_button_clicked)

   

    def show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter):

        with output:

            print("\n--- Ingreso de Cantidades ---")

            df = df_baja_tubing

            quantity_widgets = {}

            qty_items = []

            for d in selected_diametros:

                for t in selected_tipos_dict[d]:

                    key = (d, t)

                    w = widgets.IntText(

                        value=0,

                        description=f"{d} - {t}:",

                        layout=widgets.Layout(width='400px')

                    )

                    quantity_widgets[key] = w

                    qty_items.append(w)

            quantity_box = widgets.VBox(qty_items)

            display(quantity_box)

            update_qty_button = widgets.Button(description="Aplicar Cantidades", button_style="success")

            display(update_qty_button)

           

            def on_update_qty(b2):

                for (d, t), qty_widget in quantity_widgets.items():

                    qty_value = qty_widget.value

                    if d == "TODOS":

                        continue

                    condition = (df["DI√ÅMETRO"].isin([d, "TODOS"]) & df["TIPO"].isin([t, "TODOS"]))

                    df.loc[condition & df["4.CANTIDAD"].isna(), "4.CANTIDAD"] = qty_value

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in selected_tipos_dict.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict:

                        cond = (df["DI√ÅMETRO"].isin([diam_value, "TODOS"]) & df["TIPO"].isin([tipo_val, "TODOS"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO C", final_df_renombrado))

                # print("Materiales del FLUJO C guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO D", button_style="success")

                def on_continue(b):

                    flujo_D()

                continue_button.on_click(on_continue)

                display(continue_button)

            update_qty_button.on_click(on_update_qty)

   

    def on_baja_tubing_change(change):

        if change['name'] == 'value' and change['new'] is not None:

            if change['new'] == 'SI':

                if load_excel():

                    show_diametro_selection()

            else:

                with output:

                    print("No se procede con Baja Tubing.")

                flujo_D()

    baja_tubing_widget.observe(on_baja_tubing_change, names='value')

   

# ===============================

# FLUJO D: Profundiza

# ===============================

def flujo_D():

    clear_output()

    print("FLUJO D: Profundiza")

    output = widgets.Output()

    file_path_prof = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\profundiza.xlsx"

    global df_prof

    df_prof = None

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_prof):

                print(f"El archivo no se encontr√≥ en la ruta:\n{file_path_prof}")

                return False

            try:

                df = pd.read_excel(file_path_prof)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DI√ÅMETRO CSG' in df.columns:

                    df['DI√ÅMETRO CSG'] = df['DI√ÅMETRO CSG'].replace('nan', '').fillna('')

                global df_prof

                df_prof = df.copy()

                print("Archivo cargado y limpiado con √©xito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

    profundiza_widget = widgets.Dropdown(

        options=["seleccionar", "SI", "NO"],

        description="Profundizar:",

        value="seleccionar"

    )

    def on_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(output)

            if change['new'] == "SI":

                if load_excel():

                    if "DI√ÅMETRO" in df_prof.columns:

                        col_diametro = "DI√ÅMETRO"

                    elif "DI√ÅMETRO CSG" in df_prof.columns:

                        col_diametro = "DI√ÅMETRO CSG"

                    else:

                        with output:

                            print("La columna de DI√ÅMETRO no se encontr√≥ en el Excel.")

                        return

                    diametro_select = widgets.SelectMultiple(

                        options=df_prof[col_diametro].unique().tolist(),

                        description="DI√ÅMETRO",

                        rows=10

                    )

                    display(diametro_select)

                    confirm_button = widgets.Button(description="Confirmar selecci√≥n")

                    output_area = widgets.Output()

                    def on_confirm(b):

                        with output_area:

                            clear_output()

                            selected_diametros = list(diametro_select.value)

                            if not selected_diametros:

                                print("No se seleccionaron di√°metros.")

                                return

                            print("Ingrese la cantidad para cada DI√ÅMETRO seleccionado:")

                            numeric_widgets = {}

                            for d in selected_diametros:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1000000,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                            apply_button = widgets.Button(description="Aplicar cantidades")

                            def on_apply(b):

                                filtered_df = df_prof[df_prof[col_diametro].isin(selected_diametros)].copy()

                                for d in selected_diametros:

                                    cantidad = numeric_widgets[d].value

                                    filtered_df.loc[filtered_df[col_diametro] == d, "4.CANTIDAD"] = cantidad

                                final_df_renombrado = renombrar_columnas(filtered_df)

                                materiales_finales.append(("FLUJO D", final_df_renombrado))

                                # print("Materiales del FLUJO D guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO E", button_style="success")

                                def on_continue(b):

                                    flujo_E()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                            apply_button.on_click(on_apply)

                            display(apply_button)

                    confirm_button.on_click(on_confirm)

                    display(confirm_button, output_area)

            else:

                with output:

                    print("No se profundizar√° en la informaci√≥n.")

                flujo_E()

    profundiza_widget.observe(on_change)

    display(profundiza_widget)

    display(output)

 

# ===============================

# FLUJO E: Baja varillas

# ===============================

def flujo_E():

    clear_output()

    print("FLUJO E: Baja varillas")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¬øBaja Varilla?",

        value="seleccionar"

    )

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja varillas.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DI√ÅMETRO"] = df["DI√ÅMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DI√ÅMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DI√ÅMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay TIPO disponibles. Se usar√° 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay valores para {columna}. Se usar√° 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DI√ÅMETRO: {diam_value}")

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DI√ÅMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DI√ÅMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO E", final_df_renombrado))

                # print("Materiales del FLUJO E guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO G", button_style="success")

                def on_continue(b):

                    flujo_G()

                continue_button.on_click(on_continue)

                display(continue_button)

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccion√≥ NO en FLUJO E. Saltando a FLUJO F...")  # Desactivado

                flujo_F()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO F: Abandona pozo

# ===============================

def flujo_F():

    clear_output()

    print("FLUJO F: Abandona pozo")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\abandono-recupero.xlsx"

    global df_abandono

    df_abandono = None

    output = widgets.Output()

    question_widget = widgets.Dropdown(

        options=["NO", "SI"],

        value="NO",

        description="¬øAbandono/recupero?:"

    )

    def filter_by_todos(df, column, selected_values):

        if "TODOS" in selected_values:

            return df

        else:

            allowed_values = list(selected_values) + ["TODOS"]

            return df[df[column].isin(allowed_values)]

    def on_question_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(question_widget, output)

            if change['new'] == "SI":

                with output:

                    # print("Cargando el Excel...")  # (Este print no est√° en la lista a desactivar, se mantiene)

                    if not os.path.exists(file_path):

                        print(f"No se encontr√≥ el archivo:\n{file_path}")

                        return

                    global df_abandono

                    try:

                        df_abandono = pd.read_excel(file_path)

                    except Exception as e:

                        print("Error al cargar el Excel:", e)

                        return

                    print("Archivo cargado exitosamente.")

                df_abandono.columns = df_abandono.columns.str.strip()

                for col in df_abandono.columns:

                    if df_abandono[col].dtype == object:

                        df_abandono[col] = df_abandono[col].astype(str).str.strip()

                if "DI√ÅMETRO" not in df_abandono.columns:

                    with output:

                        print("La columna 'DI√ÅMETRO' no existe en el Excel.")

                    return

                unique_diametros = df_abandono["DI√ÅMETRO"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros:

                    unique_diametros.insert(0, "TODOS")

                else:

                    unique_diametros.remove("TODOS")

                    unique_diametros.insert(0, "TODOS")

                if "DI√ÅMETRO CSG" not in df_abandono.columns:

                    with output:

                        print("La columna 'DI√ÅMETRO CSG' no existe en el Excel.")

                    return

                unique_diametros_csg = df_abandono["DI√ÅMETRO CSG"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros_csg:

                    unique_diametros_csg.insert(0, "TODOS")

                else:

                    unique_diametros_csg.remove("TODOS")

                    unique_diametros_csg.insert(0, "TODOS")

                diametro_multi = widgets.SelectMultiple(

                    options=unique_diametros,

                    value=["TODOS"],

                    description="DI√ÅMETRO:",

                    rows=6

                )

                diametro_csg_single = widgets.Dropdown(

                    options=unique_diametros_csg,

                    value="TODOS",

                    description="DI√ÅM CSG:"

                )

                confirm_button = widgets.Button(

                    description="Confirmar Filtros",

                    button_style="info"

                )

                next_output = widgets.Output()

                def on_confirm_filters(b):

                    with next_output:

                        clear_output()

                        selected_diametros = list(diametro_multi.value)

                        selected_diametro_csg = diametro_csg_single.value

                        filtered_df = df_abandono.copy()

                        filtered_df = filter_by_todos(filtered_df, "DI√ÅMETRO", selected_diametros)

                        filtered_df = filter_by_todos(filtered_df, "DI√ÅMETRO CSG", [selected_diametro_csg])

                        print("Filtrado Aplicado. A continuaci√≥n, ingrese cantidades (solo para celdas vac√≠as).")

                        numeric_widgets = {}

                        diametros_especificos = [d for d in selected_diametros if d != "TODOS"]

                        if diametros_especificos:

                            print("Ingrese la cantidad para cada DI√ÅMETRO seleccionado:")

                            for d in diametros_especificos:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1e9,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                        else:

                            print("No se seleccionaron di√°metros espec√≠ficos. No se solicitar√°n cantidades.")

                        apply_button = widgets.Button(

                            description="Aplicar Cantidades",

                            button_style="success"

                        )

                        final_output = widgets.Output()

                        def on_apply_quantities(btn):

                            with final_output:

                                clear_output()

                                if "4.CANTIDAD" not in df_abandono.columns:

                                    print("La columna '4.CANTIDAD' no existe en el Excel.")

                                    return

                                df_abandono["4.CANTIDAD"] = pd.to_numeric(df_abandono["4.CANTIDAD"], errors="coerce")

                                for d in diametros_especificos:

                                    qty = numeric_widgets[d].value

                                    mask_diam = (df_abandono["DI√ÅMETRO"] == d)

                                    mask_nan = df_abandono["4.CANTIDAD"].isna()

                                    df_abandono.loc[mask_diam & mask_nan, "4.CANTIDAD"] = qty

                                filtered_final = df_abandono.copy()

                                filtered_final = filter_by_todos(filtered_final, "DI√ÅMETRO", selected_diametros)

                                filtered_final = filter_by_todos(filtered_final, "DI√ÅMETRO CSG", [selected_diametro_csg])

                                print("Listado Final Filtrado:")

                                filtered_final_renombrado = renombrar_columnas(filtered_final)

                                materiales_finales.append(("FLUJO F", filtered_final_renombrado))

                                # print("Materiales del FLUJO F guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                                def on_continue(b):

                                    flujo_H()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                        apply_button.on_click(on_apply_quantities)

                        display(apply_button, final_output)

                confirm_button.on_click(on_confirm_filters)

                display(diametro_multi, diametro_csg_single, confirm_button, next_output)

            else:

                with output:

                    # print("No se realizar√° la acci√≥n. Saltando a FLUJO H...")  # Desactivado

                    pass

                flujo_H()

    question_widget.observe(on_question_change, names='value')

    display(question_widget, output)

 

 

# ===============================

# FLUJO G: Instalaci√≥n BM

# ===============================

def flujo_G():

    clear_output()

    print("FLUJO G: Instalaci√≥n BM")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\WO.xlsx"

    pregunta_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¬øWO a BM?",

        value="seleccionar"

    )

    def mostrar_materiales(change):

        clear_output()

        display(pregunta_widget)

        if change['new'] == "SI":

            try:

                df = pd.read_excel(file_path)

                print("Lista de materiales:")

                df_renombrado = renombrar_columnas(df)

                materiales_finales.append(("FLUJO G", df_renombrado))

                # print("Materiales del FLUJO G guardados.")  # Desactivado

            except Exception as e:

                print("Error al cargar Excel:", e)

            continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

            def on_continue(b):

                flujo_H()

            continue_button.on_click(on_continue)

            display(continue_button)

        elif change['new'] == "NO":

            print("No se mostrar√°n los materiales.")

            flujo_H()

    pregunta_widget.observe(mostrar_materiales, names='value')

    display(pregunta_widget)

 

def flujo_H():

    clear_output()

    print("=== FLUJO H: Material de agregaci√≥n ===")

    try:

        file_path_H = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\GENERAL(1).xlsx"

        df_H = pd.read_excel(file_path_H)

        df_H.columns = df_H.columns.str.strip()

        if "4.CANTIDAD" not in df_H.columns:

            df_H["4.CANTIDAD"] = 0

    except Exception as e:

        print("Error al cargar el Excel:", e)

        df_H = pd.DataFrame()

   

    pregunta_widget_H = widgets.RadioButtons(

        options=["Seleccionar", "SI", "NO"],

        description="¬øAgregar m√°s material?",

        value="Seleccionar"

    )

    output_container_H = widgets.Output()

 

    apply_selection_button_H = widgets.Button(description="Aplicar selecci√≥n", button_style="info")

    apply_qty_button_H = widgets.Button(description="Asignar cantidades", button_style="success")

   

    final_list_button = widgets.Button(description="Mostrar Listado Final de Materiales", button_style="warning")

    final_button_container = widgets.VBox([final_list_button])

   

    def on_show_final_list(b):

        clear_output()

        print("Listado final de materiales de todos los flujos ejecutados:")

        for flow, df in materiales_finales:

            print(f"\n---- {flow} ----")

            display(df)

    final_list_button.on_click(on_show_final_list)

   

    if not df_H.empty and "2. MATERIAL" in df_H.columns:

        materiales = df_H["2. MATERIAL"].astype(str).unique().tolist()

    else:

        materiales = []

    materiales_widget_H = widgets.SelectMultiple(

        options=materiales,

        description="Materiales",

        layout=widgets.Layout(width='50%', height='150px')

    )

    qty_widgets_H = {}

   

    def on_apply_selection_H(b):

        with output_container_H:

            clear_output()

            seleccionados = list(materiales_widget_H.value)

            if not seleccionados:

                print("No se seleccion√≥ ning√∫n material.")

                return

            print("Materiales seleccionados:")

            for mat in seleccionados:

                print("-", mat)

            qty_widgets_H.clear()

            input_boxes = []

            for mat in seleccionados:

                qty_box = widgets.BoundedFloatText(

                    value=0,

                    min=0,

                    step=1,

                    description=f"Cant: {mat}",

                    layout=widgets.Layout(width='50%')

                )

                qty_widgets_H[mat] = qty_box

                input_boxes.append(qty_box)

            display(widgets.VBox(input_boxes))

            display(apply_qty_button_H)

   

    def on_apply_qty_H(b):

        with output_container_H:

            clear_output()

            if df_H.empty:

                print("El DataFrame est√° vac√≠o o no se carg√≥ correctamente.")

                return

            selected_materials = list(qty_widgets_H.keys())

            for mat, widget_box in qty_widgets_H.items():

                cant = widget_box.value

                df_H.loc[df_H["2. MATERIAL"].astype(str) == mat, "4.CANTIDAD"] = cant

            assigned_df = df_H[

                df_H["2. MATERIAL"].astype(str).isin(selected_materials) &

                (df_H["4.CANTIDAD"] > 0)

            ]

            if not assigned_df.empty:

                assigned_df_renombrado = renombrar_columnas(assigned_df)

                materiales_finales.append(("FLUJO H", assigned_df_renombrado))

                # print("Materiales del FLUJO H guardados.")  # Desactivado

            else:

                print("No se asignaron cantidades (o todas fueron 0).")

           

            display(final_button_container)

   

    def on_pregunta_change_H(change):

        with output_container_H:

            clear_output()

            if change['new'] == "SI":

                if df_H.empty:

                    print("El DataFrame no se carg√≥ o est√° vac√≠o.")

                    return

                print("Lista completa de materiales del Excel:\n")

                display(df_H)

                print("\nSeleccione los materiales que desea agregar:")

                display(materiales_widget_H)

                display(apply_selection_button_H)

            elif change['new'] == "NO":

                print("No se agregar√°n m√°s materiales.")

                display(final_button_container)

   

    pregunta_widget_H.observe(on_pregunta_change_H, names='value')

    apply_selection_button_H.on_click(on_apply_selection_H)

    apply_qty_button_H.on_click(on_apply_qty_H)

   

    display(pregunta_widget_H)

    display(output_container_H)

   

    # print("FLUJO H finalizado. Fin del proceso.")  # Desactivado

 

 

# ===============================

# Funci√≥n principal: inicia en FLUJO A

# ===============================

def main():

    flujo_A()

 

# Inicia el proceso

main()
```

## docs/Estructura del proyecto.md

- Characters: 6225
- Tokens: 0

```markdown
üîπ 1. Introducci√≥n
Este documento detalla la arquitectura propuesta para la implementaci√≥n de un sistema de flujos modulares en una aplicaci√≥n basada en Python y Flask. El objetivo es permitir la ejecuci√≥n de m√∫ltiples flujos de trabajo (Flujo A, B, C, etc.), en los cuales cada flujo es un m√≥dulo independiente que recibe entradas del usuario, filtra datos de archivos Excel, y proporciona salidas que pueden afectar a los siguientes flujos.

üîπ 2. An√°lisis Inicial del Problema
El c√≥digo original consist√≠a en una serie de filtros aplicados secuencialmente sobre distintos archivos de datos. Cada flujo:

Preguntaba al usuario si deb√≠a ejecutarse.
Aplicaba filtros a un conjunto de datos en funci√≥n de la respuesta.
Mostraba los materiales resultantes.
Determinaba el siguiente flujo a ejecutar.
üìå Conclusi√≥n: La l√≥gica de cada flujo era principalmente un filtro condicional sobre un conjunto de datos basado en respuestas del usuario.

Problemas detectados en la implementaci√≥n inicial
‚ùå C√≥digo monol√≠tico y dif√≠cil de extender.
‚ùå Falta de modularidad: cada flujo estaba acoplado a la l√≥gica general.
‚ùå No hab√≠a un manejo centralizado del estado y flujo de datos.

üîπ 3. Patr√≥n de Dise√±o Elegido
Se adopt√≥ una arquitectura basada en plugins combinada con un manejo centralizado del flujo utilizando Flask Sessions. Esto permite:

üìå Modularidad: Cada flujo es un plugin independiente que puede a√±adirse sin modificar la estructura general.
üìå Flexibilidad: El orden de ejecuci√≥n se define externamente y no dentro de cada m√≥dulo.
üìå Escalabilidad: Es f√°cil agregar nuevos flujos sin afectar el sistema.
üìå Manejo de Estado: Se utiliza Flask Sessions para almacenar respuestas y materiales seleccionados.
üîπ Patr√≥n de dise√±o:
Plugin-Based Architecture + State Management
Cada flujo act√∫a como un plugin independiente y el sistema maneja las transiciones y datos entre ellos.

üîπ 4. Arquitectura Resultante
üìÇ Estructura del Proyecto
bash
Copy
Edit
/app
  ‚îú‚îÄ‚îÄ main.py               # Punto de entrada de la aplicaci√≥n
  ‚îú‚îÄ‚îÄ flujo_loader.py       # Carga y gestiona los flujos din√°micamente
  ‚îú‚îÄ‚îÄ plugins/              # M√≥dulos independientes de cada flujo
  ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_a.py        # Flujo A
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_b.py        # Flujo B
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_c.py        # Flujo C
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_d.py        # Flujo D
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_e.py        # Flujo E
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_f.py        # Flujo F
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_g.py        # Flujo G
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_h.py        # Flujo H (siempre se ejecuta)
  ‚îú‚îÄ‚îÄ templates/            # HTML para la interfaz de usuario
  ‚îÇ   ‚îú‚îÄ‚îÄ base.html
  ‚îÇ   ‚îú‚îÄ‚îÄ index.html
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo.html        # P√°gina gen√©rica para cada flujo
  ‚îÇ   ‚îú‚îÄ‚îÄ resultados.html   # P√°gina de resultados finales
  ‚îú‚îÄ‚îÄ static/               # Archivos CSS y JS
  ‚îú‚îÄ‚îÄ data/                 # Archivos Excel
  ‚îú‚îÄ‚îÄ requirements.txt
  ‚îî‚îÄ‚îÄ README.md
üîπ 5. Manejo del Flujo de Ejecuci√≥n
En lugar de definir el orden de los flujos dentro de cada m√≥dulo, se utiliza un diccionario de transici√≥n que maneja la l√≥gica centralmente.

üìå Configuraci√≥n de flujos en flujo_loader.py

python
Copy
Edit
SECUENCIA_FLUJOS = {
    "A": {"SI": "H", "NO": "B"},
    "B": {"SI": "C", "NO": "C"},
    "C": {"SI": "D", "NO": "D"},
    "D": {"SI": "E", "NO": "E"},
    "E": {"SI": "G", "NO": "F"},
    "F": {"SI": "H", "NO": "H"},
    "G": {"SI": "H", "NO": "H"},
    "H": None  # √öltimo flujo
}
üìå C√≥mo funciona:

Cada flujo tiene una entrada (respuesta del usuario).
Se determina el siguiente flujo basado en la respuesta (SI o NO).
Los datos de cada flujo se almacenan en session para ser utilizados en flujos posteriores.
üîπ 6. Ejemplo de Flujo Individual
Cada flujo es un m√≥dulo independiente en la carpeta plugins/.

üìå Ejemplo de plugins/flujo_a.py

python
Copy
Edit
from flask import render_template, request

nombre = "A"

def ejecutar():
    if request.method == "POST":
        respuesta = request.form.get("respuesta")
        materiales_seleccionados = ["Material X", "Material Y"] if respuesta == "SI" else []
        return respuesta, materiales_seleccionados

    return render_template("flujo.html", flujo=nombre)
üìå Explicaci√≥n:

Cada flujo recibe una entrada (POST del usuario).
Si el usuario responde "SI", filtra materiales y los guarda.
Si el usuario responde "NO", se salta el procesamiento.
El sistema decide cu√°l es el siguiente flujo.
üîπ 7. Manejo del Estado Global
Se utiliza Flask Sessions para mantener los datos entre flujos.

üìå Ejemplo de c√≥mo se almacenan los datos en session

python
Copy
Edit
@app.route("/flujo/<nombre_flujo>", methods=["GET", "POST"])
def flujo(nombre_flujo):
    if nombre_flujo in flujos:
        respuesta, materiales, siguiente_flujo = ejecutar_flujo(nombre_flujo, session)

        # Guardar en sesi√≥n
        session[nombre_flujo] = {"respuesta": respuesta, "materiales": materiales}

        # Continuar al siguiente flujo o finalizar
        return redirect(url_for("flujo", nombre_flujo=siguiente_flujo)) if siguiente_flujo else redirect(url_for("resultados"))

    return redirect(url_for("index"))
üìå Beneficios del uso de session ‚úî Permite almacenar datos persistentes sin base de datos.
‚úî Mantiene la continuidad entre flujos.
‚úî Hace que cada flujo sea independiente sin necesidad de modificar otros flujos.

üîπ 8. Beneficios de la Arquitectura
Caracter√≠stica	Beneficio
Plugins Modulares	Se pueden agregar nuevos flujos sin modificar main.py.
Configuraci√≥n Centralizada	El orden de ejecuci√≥n se define en flujo_loader.py.
Manejo de Estado con session	Cada flujo puede acceder a respuestas y materiales previos.
Separaci√≥n de Responsabilidades	main.py maneja la app, flujo_loader.py los flujos, y los plugins contienen la l√≥gica espec√≠fica.
Escalabilidad	F√°cil de expandir sin modificar el c√≥digo existente.
üîπ 9. Conclusi√≥n
Se pas√≥ de una estructura monol√≠tica a una arquitectura basada en plugins donde:

Cada flujo es un m√≥dulo aut√≥nomo con entrada y salida.
El flujo de ejecuci√≥n es gestionado din√°micamente.
Se utiliza session para almacenar respuestas y datos.
Los desarrolladores pueden agregar nuevos flujos sin modificar la estructura base.
Este modelo permite escalabilidad, modularidad y facilidad de mantenimiento, aline√°ndose con buenas pr√°cticas de arquitectura de software.
```

## README.md

- Characters: 1903
- Tokens: 0

```markdown
# Visualizador de Excel

Esta aplicaci√≥n simple permite visualizar archivos Excel como tablas HTML en un navegador web.

## Requisitos

- Python 3.6 o superior
- pip (gestor de paquetes de Python)

## Instalaci√≥n

1. Clona o descarga este repositorio
2. Instala las dependencias:

# Configuraci√≥n y ejecuci√≥n en VS Code (Windows)
Requisitos previos

Python 3.6 o superior
pip (gestor de paquetes de Python)

Pasos para ejecutar la aplicaci√≥n
1. Clonar el repositorio
Copygit clone [URL_DEL_REPOSITORIO]
cd mi_app
2. Crear y activar un entorno virtual
Copy# Crear entorno virtual
python -m venv venv

# Activar el entorno virtual
venv\Scripts\activate
3. Instalar dependencias
Copy# Instalar todas las dependencias necesarias
pip install flask==2.3.3 openpyxl==3.1.2 pandas xlrd==2.0.1
4. Preparar los archivos Excel

Coloca tus archivos Excel (.xlsx o .xls) en la carpeta app/data/
Si la carpeta no existe, se crear√° autom√°ticamente al iniciar la aplicaci√≥n

5. Ejecutar la aplicaci√≥n
Copy# Navegar a la carpeta app
cd app

# Iniciar la aplicaci√≥n
python main.py
6. Acceder a la aplicaci√≥n

Abre tu navegador y navega a: http://127.0.0.1:5000
Ver√°s todos los archivos Excel cargados y podr√°s iniciar los flujos de trabajo

7. Desactivar el entorno virtual cuando termines
Copydeactivate
Soluci√≥n de problemas comunes

Error "No module named...": Verifica que el entorno virtual est√© activado y que todas las dependencias est√©n instaladas
Archivos Excel no visibles: Aseg√∫rate de que est√©n en la carpeta correcta (app/data/) y tengan la extensi√≥n correcta (.xlsx o .xls)

3. Abre tu navegador y ve a `http://localhost:5000`

## Notas

- La aplicaci√≥n mostrar√° todos los archivos Excel (.xlsx o .xls) encontrados en la carpeta `data`
- Cada archivo se convertir√° en una tabla HTML
- Puedes recargar la p√°gina para actualizar los datos si agregas nuevos archivos Excel mientras la aplicaci√≥n est√° corriendo
```

## .gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## Statistics

- Total Files: 20
- Total Characters: 77654
- Total Tokens: 0
````

## docs/Flujo A - Doc tecnico.md

- Characters: 2871
- Tokens: 0

```markdown
üìå Especificaci√≥n T√©cnica para Desarrollo ‚Äì FLUJO A (Ajuste de Medida)
1Ô∏è‚É£ Descripci√≥n General
FLUJO A permite al usuario seleccionar materiales basados en criterios espec√≠ficos de ajuste de medida. Si el usuario acepta el ajuste, el flujo filtra los materiales y salta directamente a FLUJO H. Si el usuario rechaza, salta a FLUJO B sin procesar datos.

2Ô∏è‚É£ Datos de Entrada
La informaci√≥n proviene de una tabla estructurada (ajuste_de_medida.xlsx), con las siguientes columnas clave:

Columna	Tipo	Descripci√≥n
DI√ÅMETRO	string	Di√°metro del material
TIPO	string	Tipo de material
GRADO DE ACERO	string	Grado de acero
GRADO DE ACERO CUPLA	string	Grado de acero de la cupla
TIPO DE CUPLA	string	Tipo de cupla
4.CANTIDAD	float	Cantidad del material (opcional)
3Ô∏è‚É£ Flujo de Ejecuci√≥n
Pregunta al usuario:

Si responde "NO" ‚Üí Salta directamente a FLUJO B.
Si responde "S√ç" ‚Üí Carga la tabla y aplica filtros.
Carga y Filtrado de Datos:

Carga la tabla ajuste_de_medida.xlsx y limpia valores.
El usuario selecciona valores en los siguientes filtros:
DI√ÅMETRO
TIPO
GRADO DE ACERO
GRADO DE ACERO CUPLA
TIPO DE CUPLA
Si el usuario no selecciona un valor, se usa "TODOS" como fallback.
Construcci√≥n de final_condition (m√°scara booleana de filtrado):

Inicializa final_condition con False para excluir todos los registros.
Para cada DI√ÅMETRO seleccionado, eval√∫a si los materiales cumplen con los criterios del usuario.
Incluye "TODOS" en cada filtro para garantizar que los valores no seleccionados no eliminen registros √∫tiles.
Se combinan las condiciones (| l√≥gico) para crear el filtro final.
Aplicaci√≥n del Filtro:

python
Copy
Edit
final_df = df[final_condition]
Solo quedan los materiales que cumplen con los criterios del usuario.
Almacena los materiales filtrados en materiales_finales:

python
Copy
Edit
materiales_finales.append(("FLUJO A", final_df_renombrado))
Salto a FLUJO H (el flujo no sigue la secuencia normal):

Si el usuario ejecuta FLUJO A, no sigue a FLUJO B, sino directamente a FLUJO H.
4Ô∏è‚É£ Consideraciones T√©cnicas
‚úî No modifica la estructura de la tabla, solo aplica filtros.
‚úî Debe permitir m√∫ltiples selecciones en cada filtro.
‚úî Evita p√©rdida de datos con "TODOS" en cada condici√≥n.
‚úî Encapsular final_condition como l√≥gica reutilizable para otros flujos.
‚úî Optimizar el acceso a archivos si se requiere ejecuci√≥n frecuente.

üìå Resumen Final
FLUJO A solo se ejecuta si el usuario dice "S√ç".
Carga una tabla de materiales y filtra datos seg√∫n selecci√≥n del usuario.
Almacena los materiales seleccionados y salta directamente a FLUJO H.
Si el usuario dice "NO", salta a FLUJO B sin procesar nada.
final_condition es el mecanismo que define qu√© materiales quedan en la selecci√≥n final.
üöÄ Resultado esperado: Un m√≥dulo optimizado que procesa materiales en base a filtros din√°micos y garantiza la continuidad del flujo sin interrumpir la secuencia de ejecuci√≥n.
```

## docs/commentarios del proy.md

- Characters: 52736
- Tokens: 0

```markdown
engo varios c√≥digos por separado que representan diferentes flujos para la selecci√≥n de materiales en la intervenci√≥n de un pozo petrolero: FLUJO A, FLUJO B, FLUJO C, FLUJO D, FLUJO E, FLUJO F, FLUJO G y FLUJO H. Cada uno de ellos inicia con una pregunta que, si el usuario responde ‚ÄúNO‚Äù, salta inmediatamente al siguiente flujo; y si el usuario responde ‚ÄúS√ç‚Äù, entonces ejecuta su l√≥gica, imprime una lista de materiales y luego avanza al siguiente flujo.

Los flujos se llaman y se encadenan de la siguiente forma:

FLUJO A (Ajuste de medida)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO H.
Si el usuario responde NO , salta a FLUJO B.
FLUJO B (Tubo de saca)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO C.
Si el usuario responde NO , salta a FLUJO C.
FLUJO C (tuber√≠a de Baja)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO D.
Si el usuario responde NO , salta a FLUJO D.
FLUJO D (Profundiza)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO E.
Si el usuario responde NO , salta a FLUJO E.
FLUJO E (Baja varillas)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO G.
Luego de terminar FLUJO G , debe continuar a FLUJO H .
Si el usuario responde NO , salta a FLUJO F , y al terminar FLUJO F , avanza a FLUJO H.
FLUJO F (Abandona pozo)
Luego de terminar (sea cual sea la respuesta, si aplica), avanza a FLUJO H .
FLUJO G (Instalaci√≥n BM)
Cuando termine este flujo, avanza a FLUJO H.
FLUJO H (Material de agregaci√≥n)
No es condicional: se supone que, al llegar aqu√≠, se ejecuta y finaliza.
El resultado deseado es un √∫nico script de Python que combina estos ocho flujos en el orden descrito y respeta las condiciones de salto (S√ç/NO). Cada flujo debe:

Preguntar al usuario si desea ejecutar ese flujo (excepto FLUJO H, que siempre se ejecuta al llegar).
Si responde S√ç: ejecute la l√≥gica interna de ese flujo (por ejemplo, las preguntas o procesos que inclu√≠an), e imprima la lista de materiales correspondientes.
Terminar ese flujo y, en lugar de salirse del programa, encadenar inmediatamente con el siguiente flujo indicado.
Si responde NO: saltarse la ejecuci√≥n de ese flujo (no imprime materiales) y avanzar al siguiente flujo, salvo en el caso de FLUJO A y FLUJO E, que ya tienen desv√≠os particulares a otros flujos.


EL CODIGO EJECUTADO EN JUPYTER ES: ESTA UN POCO DESPROLIJO, PERO BUENO AL MENOS FUNCIONA


import os

import pandas as pd

import ipywidgets as widgets

from IPython.display import display, clear_output

 

# Variable global para almacenar los DataFrames finales de cada flujo

materiales_finales = []

 

# Funci√≥n para renombrar las columnas y dejar solo las 5 requeridas

def renombrar_columnas(df):

    df_renombrado = df.rename(

        columns={

            "1. C√≥d.SAP": "C√≥d.SAP",

            "2. MATERIAL": "MATERIAL",

            "3. Descripci√≥n": "Descripci√≥n",

            "5.CONDICI√ìN": "CONDICI√ìN"

        }

    )

    # Asegurarse de que queden las siguientes columnas

    columnas = ["C√≥d.SAP", "MATERIAL", "Descripci√≥n", "4.CANTIDAD", "CONDICI√ìN"]

    columnas_presentes = [col for col in columnas if col in df_renombrado.columns]

    return df_renombrado[columnas_presentes]

 

# ===============================

# FLUJO A: Ajuste de medida

# ===============================

def flujo_A():

    clear_output()

    print("FLUJO A: Ajuste de medida")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¬øAjuste de medida?",

        value="seleccionar"

    )

   

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\ajuste de medida.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DI√ÅMETRO"] = df["DI√ÅMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DI√ÅMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DI√ÅMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

       

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay TIPO disponibles. Se usar√° 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

       

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay valores para {columna}. Se usar√° 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

       

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DI√ÅMETRO: {diam_value}")

       

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

       

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

       

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DI√ÅMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False] * len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False] * len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DI√ÅMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                # En lugar de mostrar inmediatamente, se almacena el DataFrame renombrado

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO A", final_df_renombrado))

                # print("Materiales del FLUJO A guardados.")  # Desactivado

               

                # Bot√≥n para continuar a FLUJO H (ya que en FLUJO A si se responde SI se salta directamente a H)

                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                def on_continue(b):

                    flujo_H()

                continue_button.on_click(on_continue)

                display(continue_button)

       

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccion√≥ NO en FLUJO A. Saltando a FLUJO B...")  # Desactivado

                flujo_B()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO B: Tubo de saca

# ===============================

def flujo_B():

    clear_output()

    print("FLUJO B: Tubo de saca")

    folder_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales"

    filename_saca = "saca tubing.xlsx"

    file_path_saca = os.path.join(folder_path, filename_saca)

    global df_saca_tubing

    df_saca_tubing = None

 

    def load_saca_tubing_excel():

        global df_saca_tubing

        if not os.path.exists(file_path_saca):

            print(f"El archivo {file_path_saca} no se encontr√≥.")

            return

        df_tmp = pd.read_excel(file_path_saca)

        df_tmp.columns = df_tmp.columns.str.strip()

        for c in df_tmp.columns:

            if df_tmp[c].dtype == object:

                df_tmp[c] = df_tmp[c].astype(str).str.strip()

        df_saca_tubing = df_tmp.copy()

        diametro_multi_picker.options = sorted(

            [d for d in df_saca_tubing['DI√ÅMETRO'].unique() if d.upper() != 'TODOS']

        )

 

    diametro_multi_picker = widgets.SelectMultiple(

        options=[],

        description='DI√ÅMETRO:',

        style={'description_width': 'initial'}

    )

    confirm_diameter_button = widgets.Button(

        description='Confirmar di√°metros',

        button_style='info'

    )

    quantities_container = widgets.VBox()

    final_output = widgets.Output()

    show_table_button = widgets.Button(

        description='Mostrar tabla final',

        button_style='success'

    )

 

    def on_show_table_button_clicked(b):

        with final_output:

            clear_output()

            if df_saca_tubing is None:

                print("No hay datos cargados de saca tubing.")

                return

            selected_diameters = list(diametro_multi_picker.value)

            df_filtered = df_saca_tubing[

                (df_saca_tubing['DI√ÅMETRO'].isin(selected_diameters)) |

                (df_saca_tubing['DI√ÅMETRO'].str.upper() == 'TODOS')

            ].copy()

            for child in quantities_container.children:

                dia = child.description

                cantidad = child.value

                mask = (df_filtered['DI√ÅMETRO'] == dia)

                df_filtered.loc[mask, '4.CANTIDAD'] = cantidad

            df_filtered_renombrado = renombrar_columnas(df_filtered)

            materiales_finales.append(("FLUJO B", df_filtered_renombrado))

            print("Materiales del FLUJO B guardados.")

 

        # Cierra la interfaz de FLUJO B

        multi_select_container.close()

 

        # Muestra el bot√≥n para continuar al FLUJO C

        continue_button = widgets.Button(

            description="Continuar a FLUJO C",

            button_style="success"

        )

        def on_continue(b):

            clear_output()

            flujo_C()

        continue_button.on_click(on_continue)

        display(continue_button)

 

    show_table_button.on_click(on_show_table_button_clicked)

 

    def on_confirm_diameter_button_clicked(b):

        with final_output:

            clear_output()

        quantities_container.children = []

        for dia in diametro_multi_picker.value:

            qty_widget = widgets.IntText(

                value=0,

                description=dia,

                style={'description_width': 'initial'}

            )

            quantities_container.children += (qty_widget,)

 

    confirm_diameter_button.on_click(on_confirm_diameter_button_clicked)

 

    multi_select_container = widgets.VBox([

        diametro_multi_picker,

        confirm_diameter_button,

        quantities_container,

        show_table_button,

        final_output

    ])

 

    bajara_tubing_picker = widgets.Dropdown(

        options=["Seleccione opci√≥n", "SI", "NO"],

        value="Seleccione opci√≥n",

        description="¬øsaca Tubing?:"

    )

 

    def on_bajara_tubing_change(change):

        clear_output()

        if change['new'] == "SI":

            load_saca_tubing_excel()

            display(multi_select_container)

        elif change['new'] == "NO":

            print("No se saca tubing.")

            flujo_C()

 

    bajara_tubing_picker.observe(on_bajara_tubing_change, names='value')

 

    print("¬øSaca Tubing?")

    display(bajara_tubing_picker)

 

# ===============================

# FLUJO C: Tuber√≠a de Baja

# ===============================

def flujo_C():

    clear_output()

    print("FLUJO C: Tuber√≠a de Baja")

    file_path_baja = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja tubing.xlsx"

    global df_baja_tubing

    df_baja_tubing = None

    output = widgets.Output()

    baja_tubing_widget = widgets.ToggleButtons(

        options=['SI', 'NO'],

        description='¬øBaja Tubing?',

        disabled=False,

        value=None

    )

    display(baja_tubing_widget, output)

   

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_baja):

                print(f"El archivo no se encontr√≥ en la ruta:\n{file_path_baja}")

                return False

            try:

                df = pd.read_excel(file_path_baja)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DI√ÅMETRO CSG' in df.columns:

                    df['DI√ÅMETRO CSG'] = df['DI√ÅMETRO CSG'].replace('nan', '').fillna('')

                global df_baja_tubing

                df_baja_tubing = df.copy()

                print("Archivo cargado y limpiado con √©xito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

   

    def show_diametro_selection():

        with output:

            print("\n--- Selecci√≥n de DI√ÅMETRO ---")

            df = df_baja_tubing

            unique_diametros = sorted([x for x in df['DI√ÅMETRO'].unique() if x != "TODOS"])

            diametro_widget = widgets.SelectMultiple(

                options=unique_diametros,

                value=(),

                description="DI√ÅMETRO",

                layout=widgets.Layout(width='50%')

            )

            display(diametro_widget)

            button_diametro = widgets.Button(description="Siguiente - Selecci√≥n DI√ÅMETRO")

            display(button_diametro)

           

            def on_diametro_button_clicked(_):

                selected = list(diametro_widget.value)

                selected_diametros = ["TODOS"] if not selected else selected

                show_tipo_accordion(selected_diametros)

            button_diametro.on_click(on_diametro_button_clicked)

   

    def show_tipo_accordion(selected_diametros):

        with output:

            print("\n--- Selecci√≥n de TIPO para cada DI√ÅMETRO ---")

            df = df_baja_tubing

            tipo_widgets = {}

            children = []

            titles = []

            for d in selected_diametros:

                df_temp = df if d=="TODOS" else df[df['DI√ÅMETRO'] == d]

                unique_tipos = sorted([x for x in df_temp['TIPO'].unique() if x != "TODOS"])

                widget_t = widgets.SelectMultiple(

                    options=unique_tipos,

                    value=(),

                    description=f"TIPO ({d})",

                    layout=widgets.Layout(width='50%')

                )

                tipo_widgets[d] = widget_t

                children.append(widget_t)

                titles.append(f"DI√ÅMETRO: {d}")

            accordion = widgets.Accordion(children=children)

            for idx, title in enumerate(titles):

                accordion.set_title(idx, title)

            display(accordion)

            button_tipo = widgets.Button(description="Siguiente - Selecci√≥n TIPO")

            display(button_tipo)

           

            def on_tipo_button_clicked(_):

                selected_tipos_dict = {}

                for d, widget_t in tipo_widgets.items():

                    st = list(widget_t.value)

                    if not st:

                        st = ["TODOS"]

                    selected_tipos_dict[d] = st

                show_diametro_csg_selection(selected_diametros, selected_tipos_dict)

            button_tipo.on_click(on_tipo_button_clicked)

   

    def show_diametro_csg_selection(selected_diametros, selected_tipos_dict):

        with output:

            print("\n--- Selecci√≥n de DI√ÅMETRO CSG ---")

            df = df_baja_tubing

            union_tipos = set()

            for tlist in selected_tipos_dict.values():

                if tlist == ["TODOS"]:

                    union_tipos.add("TODOS")

                else:

                    union_tipos.update(tlist)

                    union_tipos.add("TODOS")

            diam_filter = ["TODOS"] if selected_diametros == ["TODOS"] else selected_diametros + ["TODOS"]

            df_filtered = df[df['DI√ÅMETRO'].isin(diam_filter) & df['TIPO'].isin(union_tipos)]

            unique_csg = sorted([x for x in df_filtered['DI√ÅMETRO CSG'].unique() if x != "TODOS"])

            if not unique_csg:

                print("Nota: Solo 'TODOS' disponible para DI√ÅMETRO CSG. Se procede autom√°ticamente.")

                show_quantity_inputs(selected_diametros, selected_tipos_dict, ["TODOS"])

            else:

                csg_widget = widgets.Dropdown(

                    options=unique_csg,

                    value=unique_csg[0],

                    description="DI√ÅMETRO CSG",

                    layout=widgets.Layout(width='50%')

                )

                display(csg_widget)

                button_csg = widgets.Button(description="Siguiente - Selecci√≥n DI√ÅMETRO CSG")

                display(button_csg)

               

                def on_csg_button_clicked(_):

                    selected_csg = csg_widget.value

                    selected_csg_filter = [selected_csg, "TODOS"] if selected_csg != "TODOS" else ["TODOS"]

                    show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter)

                button_csg.on_click(on_csg_button_clicked)

   

    def show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter):

        with output:

            print("\n--- Ingreso de Cantidades ---")

            df = df_baja_tubing

            quantity_widgets = {}

            qty_items = []

            for d in selected_diametros:

                for t in selected_tipos_dict[d]:

                    key = (d, t)

                    w = widgets.IntText(

                        value=0,

                        description=f"{d} - {t}:",

                        layout=widgets.Layout(width='400px')

                    )

                    quantity_widgets[key] = w

                    qty_items.append(w)

            quantity_box = widgets.VBox(qty_items)

            display(quantity_box)

            update_qty_button = widgets.Button(description="Aplicar Cantidades", button_style="success")

            display(update_qty_button)

           

            def on_update_qty(b2):

                for (d, t), qty_widget in quantity_widgets.items():

                    qty_value = qty_widget.value

                    if d == "TODOS":

                        continue

                    condition = (df["DI√ÅMETRO"].isin([d, "TODOS"]) & df["TIPO"].isin([t, "TODOS"]))

                    df.loc[condition & df["4.CANTIDAD"].isna(), "4.CANTIDAD"] = qty_value

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in selected_tipos_dict.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict:

                        cond = (df["DI√ÅMETRO"].isin([diam_value, "TODOS"]) & df["TIPO"].isin([tipo_val, "TODOS"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO C", final_df_renombrado))

                # print("Materiales del FLUJO C guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO D", button_style="success")

                def on_continue(b):

                    flujo_D()

                continue_button.on_click(on_continue)

                display(continue_button)

            update_qty_button.on_click(on_update_qty)

   

    def on_baja_tubing_change(change):

        if change['name'] == 'value' and change['new'] is not None:

            if change['new'] == 'SI':

                if load_excel():

                    show_diametro_selection()

            else:

                with output:

                    print("No se procede con Baja Tubing.")

                flujo_D()

    baja_tubing_widget.observe(on_baja_tubing_change, names='value')

   

# ===============================

# FLUJO D: Profundiza

# ===============================

def flujo_D():

    clear_output()

    print("FLUJO D: Profundiza")

    output = widgets.Output()

    file_path_prof = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\profundiza.xlsx"

    global df_prof

    df_prof = None

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_prof):

                print(f"El archivo no se encontr√≥ en la ruta:\n{file_path_prof}")

                return False

            try:

                df = pd.read_excel(file_path_prof)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DI√ÅMETRO CSG' in df.columns:

                    df['DI√ÅMETRO CSG'] = df['DI√ÅMETRO CSG'].replace('nan', '').fillna('')

                global df_prof

                df_prof = df.copy()

                print("Archivo cargado y limpiado con √©xito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

    profundiza_widget = widgets.Dropdown(

        options=["seleccionar", "SI", "NO"],

        description="Profundizar:",

        value="seleccionar"

    )

    def on_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(output)

            if change['new'] == "SI":

                if load_excel():

                    if "DI√ÅMETRO" in df_prof.columns:

                        col_diametro = "DI√ÅMETRO"

                    elif "DI√ÅMETRO CSG" in df_prof.columns:

                        col_diametro = "DI√ÅMETRO CSG"

                    else:

                        with output:

                            print("La columna de DI√ÅMETRO no se encontr√≥ en el Excel.")

                        return

                    diametro_select = widgets.SelectMultiple(

                        options=df_prof[col_diametro].unique().tolist(),

                        description="DI√ÅMETRO",

                        rows=10

                    )

                    display(diametro_select)

                    confirm_button = widgets.Button(description="Confirmar selecci√≥n")

                    output_area = widgets.Output()

                    def on_confirm(b):

                        with output_area:

                            clear_output()

                            selected_diametros = list(diametro_select.value)

                            if not selected_diametros:

                                print("No se seleccionaron di√°metros.")

                                return

                            print("Ingrese la cantidad para cada DI√ÅMETRO seleccionado:")

                            numeric_widgets = {}

                            for d in selected_diametros:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1000000,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                            apply_button = widgets.Button(description="Aplicar cantidades")

                            def on_apply(b):

                                filtered_df = df_prof[df_prof[col_diametro].isin(selected_diametros)].copy()

                                for d in selected_diametros:

                                    cantidad = numeric_widgets[d].value

                                    filtered_df.loc[filtered_df[col_diametro] == d, "4.CANTIDAD"] = cantidad

                                final_df_renombrado = renombrar_columnas(filtered_df)

                                materiales_finales.append(("FLUJO D", final_df_renombrado))

                                # print("Materiales del FLUJO D guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO E", button_style="success")

                                def on_continue(b):

                                    flujo_E()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                            apply_button.on_click(on_apply)

                            display(apply_button)

                    confirm_button.on_click(on_confirm)

                    display(confirm_button, output_area)

            else:

                with output:

                    print("No se profundizar√° en la informaci√≥n.")

                flujo_E()

    profundiza_widget.observe(on_change)

    display(profundiza_widget)

    display(output)

 

# ===============================

# FLUJO E: Baja varillas

# ===============================

def flujo_E():

    clear_output()

    print("FLUJO E: Baja varillas")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¬øBaja Varilla?",

        value="seleccionar"

    )

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja varillas.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DI√ÅMETRO"] = df["DI√ÅMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DI√ÅMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DI√ÅMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay TIPO disponibles. Se usar√° 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay valores para {columna}. Se usar√° 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DI√ÅMETRO: {diam_value}")

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DI√ÅMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DI√ÅMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO E", final_df_renombrado))

                # print("Materiales del FLUJO E guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO G", button_style="success")

                def on_continue(b):

                    flujo_G()

                continue_button.on_click(on_continue)

                display(continue_button)

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccion√≥ NO en FLUJO E. Saltando a FLUJO F...")  # Desactivado

                flujo_F()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO F: Abandona pozo

# ===============================

def flujo_F():

    clear_output()

    print("FLUJO F: Abandona pozo")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\abandono-recupero.xlsx"

    global df_abandono

    df_abandono = None

    output = widgets.Output()

    question_widget = widgets.Dropdown(

        options=["NO", "SI"],

        value="NO",

        description="¬øAbandono/recupero?:"

    )

    def filter_by_todos(df, column, selected_values):

        if "TODOS" in selected_values:

            return df

        else:

            allowed_values = list(selected_values) + ["TODOS"]

            return df[df[column].isin(allowed_values)]

    def on_question_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(question_widget, output)

            if change['new'] == "SI":

                with output:

                    # print("Cargando el Excel...")  # (Este print no est√° en la lista a desactivar, se mantiene)

                    if not os.path.exists(file_path):

                        print(f"No se encontr√≥ el archivo:\n{file_path}")

                        return

                    global df_abandono

                    try:

                        df_abandono = pd.read_excel(file_path)

                    except Exception as e:

                        print("Error al cargar el Excel:", e)

                        return

                    print("Archivo cargado exitosamente.")

                df_abandono.columns = df_abandono.columns.str.strip()

                for col in df_abandono.columns:

                    if df_abandono[col].dtype == object:

                        df_abandono[col] = df_abandono[col].astype(str).str.strip()

                if "DI√ÅMETRO" not in df_abandono.columns:

                    with output:

                        print("La columna 'DI√ÅMETRO' no existe en el Excel.")

                    return

                unique_diametros = df_abandono["DI√ÅMETRO"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros:

                    unique_diametros.insert(0, "TODOS")

                else:

                    unique_diametros.remove("TODOS")

                    unique_diametros.insert(0, "TODOS")

                if "DI√ÅMETRO CSG" not in df_abandono.columns:

                    with output:

                        print("La columna 'DI√ÅMETRO CSG' no existe en el Excel.")

                    return

                unique_diametros_csg = df_abandono["DI√ÅMETRO CSG"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros_csg:

                    unique_diametros_csg.insert(0, "TODOS")

                else:

                    unique_diametros_csg.remove("TODOS")

                    unique_diametros_csg.insert(0, "TODOS")

                diametro_multi = widgets.SelectMultiple(

                    options=unique_diametros,

                    value=["TODOS"],

                    description="DI√ÅMETRO:",

                    rows=6

                )

                diametro_csg_single = widgets.Dropdown(

                    options=unique_diametros_csg,

                    value="TODOS",

                    description="DI√ÅM CSG:"

                )

                confirm_button = widgets.Button(

                    description="Confirmar Filtros",

                    button_style="info"

                )

                next_output = widgets.Output()

                def on_confirm_filters(b):

                    with next_output:

                        clear_output()

                        selected_diametros = list(diametro_multi.value)

                        selected_diametro_csg = diametro_csg_single.value

                        filtered_df = df_abandono.copy()

                        filtered_df = filter_by_todos(filtered_df, "DI√ÅMETRO", selected_diametros)

                        filtered_df = filter_by_todos(filtered_df, "DI√ÅMETRO CSG", [selected_diametro_csg])

                        print("Filtrado Aplicado. A continuaci√≥n, ingrese cantidades (solo para celdas vac√≠as).")

                        numeric_widgets = {}

                        diametros_especificos = [d for d in selected_diametros if d != "TODOS"]

                        if diametros_especificos:

                            print("Ingrese la cantidad para cada DI√ÅMETRO seleccionado:")

                            for d in diametros_especificos:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1e9,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                        else:

                            print("No se seleccionaron di√°metros espec√≠ficos. No se solicitar√°n cantidades.")

                        apply_button = widgets.Button(

                            description="Aplicar Cantidades",

                            button_style="success"

                        )

                        final_output = widgets.Output()

                        def on_apply_quantities(btn):

                            with final_output:

                                clear_output()

                                if "4.CANTIDAD" not in df_abandono.columns:

                                    print("La columna '4.CANTIDAD' no existe en el Excel.")

                                    return

                                df_abandono["4.CANTIDAD"] = pd.to_numeric(df_abandono["4.CANTIDAD"], errors="coerce")

                                for d in diametros_especificos:

                                    qty = numeric_widgets[d].value

                                    mask_diam = (df_abandono["DI√ÅMETRO"] == d)

                                    mask_nan = df_abandono["4.CANTIDAD"].isna()

                                    df_abandono.loc[mask_diam & mask_nan, "4.CANTIDAD"] = qty

                                filtered_final = df_abandono.copy()

                                filtered_final = filter_by_todos(filtered_final, "DI√ÅMETRO", selected_diametros)

                                filtered_final = filter_by_todos(filtered_final, "DI√ÅMETRO CSG", [selected_diametro_csg])

                                print("Listado Final Filtrado:")

                                filtered_final_renombrado = renombrar_columnas(filtered_final)

                                materiales_finales.append(("FLUJO F", filtered_final_renombrado))

                                # print("Materiales del FLUJO F guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                                def on_continue(b):

                                    flujo_H()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                        apply_button.on_click(on_apply_quantities)

                        display(apply_button, final_output)

                confirm_button.on_click(on_confirm_filters)

                display(diametro_multi, diametro_csg_single, confirm_button, next_output)

            else:

                with output:

                    # print("No se realizar√° la acci√≥n. Saltando a FLUJO H...")  # Desactivado

                    pass

                flujo_H()

    question_widget.observe(on_question_change, names='value')

    display(question_widget, output)

 

 

# ===============================

# FLUJO G: Instalaci√≥n BM

# ===============================

def flujo_G():

    clear_output()

    print("FLUJO G: Instalaci√≥n BM")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\WO.xlsx"

    pregunta_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¬øWO a BM?",

        value="seleccionar"

    )

    def mostrar_materiales(change):

        clear_output()

        display(pregunta_widget)

        if change['new'] == "SI":

            try:

                df = pd.read_excel(file_path)

                print("Lista de materiales:")

                df_renombrado = renombrar_columnas(df)

                materiales_finales.append(("FLUJO G", df_renombrado))

                # print("Materiales del FLUJO G guardados.")  # Desactivado

            except Exception as e:

                print("Error al cargar Excel:", e)

            continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

            def on_continue(b):

                flujo_H()

            continue_button.on_click(on_continue)

            display(continue_button)

        elif change['new'] == "NO":

            print("No se mostrar√°n los materiales.")

            flujo_H()

    pregunta_widget.observe(mostrar_materiales, names='value')

    display(pregunta_widget)

 

def flujo_H():

    clear_output()

    print("=== FLUJO H: Material de agregaci√≥n ===")

    try:

        file_path_H = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\GENERAL(1).xlsx"

        df_H = pd.read_excel(file_path_H)

        df_H.columns = df_H.columns.str.strip()

        if "4.CANTIDAD" not in df_H.columns:

            df_H["4.CANTIDAD"] = 0

    except Exception as e:

        print("Error al cargar el Excel:", e)

        df_H = pd.DataFrame()

   

    pregunta_widget_H = widgets.RadioButtons(

        options=["Seleccionar", "SI", "NO"],

        description="¬øAgregar m√°s material?",

        value="Seleccionar"

    )

    output_container_H = widgets.Output()

 

    apply_selection_button_H = widgets.Button(description="Aplicar selecci√≥n", button_style="info")

    apply_qty_button_H = widgets.Button(description="Asignar cantidades", button_style="success")

   

    final_list_button = widgets.Button(description="Mostrar Listado Final de Materiales", button_style="warning")

    final_button_container = widgets.VBox([final_list_button])

   

    def on_show_final_list(b):

        clear_output()

        print("Listado final de materiales de todos los flujos ejecutados:")

        for flow, df in materiales_finales:

            print(f"\n---- {flow} ----")

            display(df)

    final_list_button.on_click(on_show_final_list)

   

    if not df_H.empty and "2. MATERIAL" in df_H.columns:

        materiales = df_H["2. MATERIAL"].astype(str).unique().tolist()

    else:

        materiales = []

    materiales_widget_H = widgets.SelectMultiple(

        options=materiales,

        description="Materiales",

        layout=widgets.Layout(width='50%', height='150px')

    )

    qty_widgets_H = {}

   

    def on_apply_selection_H(b):

        with output_container_H:

            clear_output()

            seleccionados = list(materiales_widget_H.value)

            if not seleccionados:

                print("No se seleccion√≥ ning√∫n material.")

                return

            print("Materiales seleccionados:")

            for mat in seleccionados:

                print("-", mat)

            qty_widgets_H.clear()

            input_boxes = []

            for mat in seleccionados:

                qty_box = widgets.BoundedFloatText(

                    value=0,

                    min=0,

                    step=1,

                    description=f"Cant: {mat}",

                    layout=widgets.Layout(width='50%')

                )

                qty_widgets_H[mat] = qty_box

                input_boxes.append(qty_box)

            display(widgets.VBox(input_boxes))

            display(apply_qty_button_H)

   

    def on_apply_qty_H(b):

        with output_container_H:

            clear_output()

            if df_H.empty:

                print("El DataFrame est√° vac√≠o o no se carg√≥ correctamente.")

                return

            selected_materials = list(qty_widgets_H.keys())

            for mat, widget_box in qty_widgets_H.items():

                cant = widget_box.value

                df_H.loc[df_H["2. MATERIAL"].astype(str) == mat, "4.CANTIDAD"] = cant

            assigned_df = df_H[

                df_H["2. MATERIAL"].astype(str).isin(selected_materials) &

                (df_H["4.CANTIDAD"] > 0)

            ]

            if not assigned_df.empty:

                assigned_df_renombrado = renombrar_columnas(assigned_df)

                materiales_finales.append(("FLUJO H", assigned_df_renombrado))

                # print("Materiales del FLUJO H guardados.")  # Desactivado

            else:

                print("No se asignaron cantidades (o todas fueron 0).")

           

            display(final_button_container)

   

    def on_pregunta_change_H(change):

        with output_container_H:

            clear_output()

            if change['new'] == "SI":

                if df_H.empty:

                    print("El DataFrame no se carg√≥ o est√° vac√≠o.")

                    return

                print("Lista completa de materiales del Excel:\n")

                display(df_H)

                print("\nSeleccione los materiales que desea agregar:")

                display(materiales_widget_H)

                display(apply_selection_button_H)

            elif change['new'] == "NO":

                print("No se agregar√°n m√°s materiales.")

                display(final_button_container)

   

    pregunta_widget_H.observe(on_pregunta_change_H, names='value')

    apply_selection_button_H.on_click(on_apply_selection_H)

    apply_qty_button_H.on_click(on_apply_qty_H)

   

    display(pregunta_widget_H)

    display(output_container_H)

   

    # print("FLUJO H finalizado. Fin del proceso.")  # Desactivado

 

 

# ===============================

# Funci√≥n principal: inicia en FLUJO A

# ===============================

def main():

    flujo_A()

 

# Inicia el proceso

main()
```

## docs/Estructura del proyecto.md

- Characters: 6225
- Tokens: 0

```markdown
üîπ 1. Introducci√≥n
Este documento detalla la arquitectura propuesta para la implementaci√≥n de un sistema de flujos modulares en una aplicaci√≥n basada en Python y Flask. El objetivo es permitir la ejecuci√≥n de m√∫ltiples flujos de trabajo (Flujo A, B, C, etc.), en los cuales cada flujo es un m√≥dulo independiente que recibe entradas del usuario, filtra datos de archivos Excel, y proporciona salidas que pueden afectar a los siguientes flujos.

üîπ 2. An√°lisis Inicial del Problema
El c√≥digo original consist√≠a en una serie de filtros aplicados secuencialmente sobre distintos archivos de datos. Cada flujo:

Preguntaba al usuario si deb√≠a ejecutarse.
Aplicaba filtros a un conjunto de datos en funci√≥n de la respuesta.
Mostraba los materiales resultantes.
Determinaba el siguiente flujo a ejecutar.
üìå Conclusi√≥n: La l√≥gica de cada flujo era principalmente un filtro condicional sobre un conjunto de datos basado en respuestas del usuario.

Problemas detectados en la implementaci√≥n inicial
‚ùå C√≥digo monol√≠tico y dif√≠cil de extender.
‚ùå Falta de modularidad: cada flujo estaba acoplado a la l√≥gica general.
‚ùå No hab√≠a un manejo centralizado del estado y flujo de datos.

üîπ 3. Patr√≥n de Dise√±o Elegido
Se adopt√≥ una arquitectura basada en plugins combinada con un manejo centralizado del flujo utilizando Flask Sessions. Esto permite:

üìå Modularidad: Cada flujo es un plugin independiente que puede a√±adirse sin modificar la estructura general.
üìå Flexibilidad: El orden de ejecuci√≥n se define externamente y no dentro de cada m√≥dulo.
üìå Escalabilidad: Es f√°cil agregar nuevos flujos sin afectar el sistema.
üìå Manejo de Estado: Se utiliza Flask Sessions para almacenar respuestas y materiales seleccionados.
üîπ Patr√≥n de dise√±o:
Plugin-Based Architecture + State Management
Cada flujo act√∫a como un plugin independiente y el sistema maneja las transiciones y datos entre ellos.

üîπ 4. Arquitectura Resultante
üìÇ Estructura del Proyecto
bash
Copy
Edit
/app
  ‚îú‚îÄ‚îÄ main.py               # Punto de entrada de la aplicaci√≥n
  ‚îú‚îÄ‚îÄ flujo_loader.py       # Carga y gestiona los flujos din√°micamente
  ‚îú‚îÄ‚îÄ plugins/              # M√≥dulos independientes de cada flujo
  ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_a.py        # Flujo A
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_b.py        # Flujo B
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_c.py        # Flujo C
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_d.py        # Flujo D
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_e.py        # Flujo E
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_f.py        # Flujo F
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_g.py        # Flujo G
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_h.py        # Flujo H (siempre se ejecuta)
  ‚îú‚îÄ‚îÄ templates/            # HTML para la interfaz de usuario
  ‚îÇ   ‚îú‚îÄ‚îÄ base.html
  ‚îÇ   ‚îú‚îÄ‚îÄ index.html
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo.html        # P√°gina gen√©rica para cada flujo
  ‚îÇ   ‚îú‚îÄ‚îÄ resultados.html   # P√°gina de resultados finales
  ‚îú‚îÄ‚îÄ static/               # Archivos CSS y JS
  ‚îú‚îÄ‚îÄ data/                 # Archivos Excel
  ‚îú‚îÄ‚îÄ requirements.txt
  ‚îî‚îÄ‚îÄ README.md
üîπ 5. Manejo del Flujo de Ejecuci√≥n
En lugar de definir el orden de los flujos dentro de cada m√≥dulo, se utiliza un diccionario de transici√≥n que maneja la l√≥gica centralmente.

üìå Configuraci√≥n de flujos en flujo_loader.py

python
Copy
Edit
SECUENCIA_FLUJOS = {
    "A": {"SI": "H", "NO": "B"},
    "B": {"SI": "C", "NO": "C"},
    "C": {"SI": "D", "NO": "D"},
    "D": {"SI": "E", "NO": "E"},
    "E": {"SI": "G", "NO": "F"},
    "F": {"SI": "H", "NO": "H"},
    "G": {"SI": "H", "NO": "H"},
    "H": None  # √öltimo flujo
}
üìå C√≥mo funciona:

Cada flujo tiene una entrada (respuesta del usuario).
Se determina el siguiente flujo basado en la respuesta (SI o NO).
Los datos de cada flujo se almacenan en session para ser utilizados en flujos posteriores.
üîπ 6. Ejemplo de Flujo Individual
Cada flujo es un m√≥dulo independiente en la carpeta plugins/.

üìå Ejemplo de plugins/flujo_a.py

python
Copy
Edit
from flask import render_template, request

nombre = "A"

def ejecutar():
    if request.method == "POST":
        respuesta = request.form.get("respuesta")
        materiales_seleccionados = ["Material X", "Material Y"] if respuesta == "SI" else []
        return respuesta, materiales_seleccionados

    return render_template("flujo.html", flujo=nombre)
üìå Explicaci√≥n:

Cada flujo recibe una entrada (POST del usuario).
Si el usuario responde "SI", filtra materiales y los guarda.
Si el usuario responde "NO", se salta el procesamiento.
El sistema decide cu√°l es el siguiente flujo.
üîπ 7. Manejo del Estado Global
Se utiliza Flask Sessions para mantener los datos entre flujos.

üìå Ejemplo de c√≥mo se almacenan los datos en session

python
Copy
Edit
@app.route("/flujo/<nombre_flujo>", methods=["GET", "POST"])
def flujo(nombre_flujo):
    if nombre_flujo in flujos:
        respuesta, materiales, siguiente_flujo = ejecutar_flujo(nombre_flujo, session)

        # Guardar en sesi√≥n
        session[nombre_flujo] = {"respuesta": respuesta, "materiales": materiales}

        # Continuar al siguiente flujo o finalizar
        return redirect(url_for("flujo", nombre_flujo=siguiente_flujo)) if siguiente_flujo else redirect(url_for("resultados"))

    return redirect(url_for("index"))
üìå Beneficios del uso de session ‚úî Permite almacenar datos persistentes sin base de datos.
‚úî Mantiene la continuidad entre flujos.
‚úî Hace que cada flujo sea independiente sin necesidad de modificar otros flujos.

üîπ 8. Beneficios de la Arquitectura
Caracter√≠stica	Beneficio
Plugins Modulares	Se pueden agregar nuevos flujos sin modificar main.py.
Configuraci√≥n Centralizada	El orden de ejecuci√≥n se define en flujo_loader.py.
Manejo de Estado con session	Cada flujo puede acceder a respuestas y materiales previos.
Separaci√≥n de Responsabilidades	main.py maneja la app, flujo_loader.py los flujos, y los plugins contienen la l√≥gica espec√≠fica.
Escalabilidad	F√°cil de expandir sin modificar el c√≥digo existente.
üîπ 9. Conclusi√≥n
Se pas√≥ de una estructura monol√≠tica a una arquitectura basada en plugins donde:

Cada flujo es un m√≥dulo aut√≥nomo con entrada y salida.
El flujo de ejecuci√≥n es gestionado din√°micamente.
Se utiliza session para almacenar respuestas y datos.
Los desarrolladores pueden agregar nuevos flujos sin modificar la estructura base.
Este modelo permite escalabilidad, modularidad y facilidad de mantenimiento, aline√°ndose con buenas pr√°cticas de arquitectura de software.
```

## README.md

- Characters: 1903
- Tokens: 0

```markdown
# Visualizador de Excel

Esta aplicaci√≥n simple permite visualizar archivos Excel como tablas HTML en un navegador web.

## Requisitos

- Python 3.6 o superior
- pip (gestor de paquetes de Python)

## Instalaci√≥n

1. Clona o descarga este repositorio
2. Instala las dependencias:

# Configuraci√≥n y ejecuci√≥n en VS Code (Windows)
Requisitos previos

Python 3.6 o superior
pip (gestor de paquetes de Python)

Pasos para ejecutar la aplicaci√≥n
1. Clonar el repositorio
Copygit clone [URL_DEL_REPOSITORIO]
cd mi_app
2. Crear y activar un entorno virtual
Copy# Crear entorno virtual
python -m venv venv

# Activar el entorno virtual
venv\Scripts\activate
3. Instalar dependencias
Copy# Instalar todas las dependencias necesarias
pip install flask==2.3.3 openpyxl==3.1.2 pandas xlrd==2.0.1
4. Preparar los archivos Excel

Coloca tus archivos Excel (.xlsx o .xls) en la carpeta app/data/
Si la carpeta no existe, se crear√° autom√°ticamente al iniciar la aplicaci√≥n

5. Ejecutar la aplicaci√≥n
Copy# Navegar a la carpeta app
cd app

# Iniciar la aplicaci√≥n
python main.py
6. Acceder a la aplicaci√≥n

Abre tu navegador y navega a: http://127.0.0.1:5000
Ver√°s todos los archivos Excel cargados y podr√°s iniciar los flujos de trabajo

7. Desactivar el entorno virtual cuando termines
Copydeactivate
Soluci√≥n de problemas comunes

Error "No module named...": Verifica que el entorno virtual est√© activado y que todas las dependencias est√©n instaladas
Archivos Excel no visibles: Aseg√∫rate de que est√©n en la carpeta correcta (app/data/) y tengan la extensi√≥n correcta (.xlsx o .xls)

3. Abre tu navegador y ve a `http://localhost:5000`

## Notas

- La aplicaci√≥n mostrar√° todos los archivos Excel (.xlsx o .xls) encontrados en la carpeta `data`
- Cada archivo se convertir√° en una tabla HTML
- Puedes recargar la p√°gina para actualizar los datos si agregas nuevos archivos Excel mientras la aplicaci√≥n est√° corriendo
```

## .gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## Statistics

- Total Files: 21
- Total Characters: 150879
- Total Tokens: 0
`````

## docs/Flujo A - Doc tecnico.md

- Characters: 2871
- Tokens: 0

```markdown
üìå Especificaci√≥n T√©cnica para Desarrollo ‚Äì FLUJO A (Ajuste de Medida)
1Ô∏è‚É£ Descripci√≥n General
FLUJO A permite al usuario seleccionar materiales basados en criterios espec√≠ficos de ajuste de medida. Si el usuario acepta el ajuste, el flujo filtra los materiales y salta directamente a FLUJO H. Si el usuario rechaza, salta a FLUJO B sin procesar datos.

2Ô∏è‚É£ Datos de Entrada
La informaci√≥n proviene de una tabla estructurada (ajuste_de_medida.xlsx), con las siguientes columnas clave:

Columna	Tipo	Descripci√≥n
DI√ÅMETRO	string	Di√°metro del material
TIPO	string	Tipo de material
GRADO DE ACERO	string	Grado de acero
GRADO DE ACERO CUPLA	string	Grado de acero de la cupla
TIPO DE CUPLA	string	Tipo de cupla
4.CANTIDAD	float	Cantidad del material (opcional)
3Ô∏è‚É£ Flujo de Ejecuci√≥n
Pregunta al usuario:

Si responde "NO" ‚Üí Salta directamente a FLUJO B.
Si responde "S√ç" ‚Üí Carga la tabla y aplica filtros.
Carga y Filtrado de Datos:

Carga la tabla ajuste_de_medida.xlsx y limpia valores.
El usuario selecciona valores en los siguientes filtros:
DI√ÅMETRO
TIPO
GRADO DE ACERO
GRADO DE ACERO CUPLA
TIPO DE CUPLA
Si el usuario no selecciona un valor, se usa "TODOS" como fallback.
Construcci√≥n de final_condition (m√°scara booleana de filtrado):

Inicializa final_condition con False para excluir todos los registros.
Para cada DI√ÅMETRO seleccionado, eval√∫a si los materiales cumplen con los criterios del usuario.
Incluye "TODOS" en cada filtro para garantizar que los valores no seleccionados no eliminen registros √∫tiles.
Se combinan las condiciones (| l√≥gico) para crear el filtro final.
Aplicaci√≥n del Filtro:

python
Copy
Edit
final_df = df[final_condition]
Solo quedan los materiales que cumplen con los criterios del usuario.
Almacena los materiales filtrados en materiales_finales:

python
Copy
Edit
materiales_finales.append(("FLUJO A", final_df_renombrado))
Salto a FLUJO H (el flujo no sigue la secuencia normal):

Si el usuario ejecuta FLUJO A, no sigue a FLUJO B, sino directamente a FLUJO H.
4Ô∏è‚É£ Consideraciones T√©cnicas
‚úî No modifica la estructura de la tabla, solo aplica filtros.
‚úî Debe permitir m√∫ltiples selecciones en cada filtro.
‚úî Evita p√©rdida de datos con "TODOS" en cada condici√≥n.
‚úî Encapsular final_condition como l√≥gica reutilizable para otros flujos.
‚úî Optimizar el acceso a archivos si se requiere ejecuci√≥n frecuente.

üìå Resumen Final
FLUJO A solo se ejecuta si el usuario dice "S√ç".
Carga una tabla de materiales y filtra datos seg√∫n selecci√≥n del usuario.
Almacena los materiales seleccionados y salta directamente a FLUJO H.
Si el usuario dice "NO", salta a FLUJO B sin procesar nada.
final_condition es el mecanismo que define qu√© materiales quedan en la selecci√≥n final.
üöÄ Resultado esperado: Un m√≥dulo optimizado que procesa materiales en base a filtros din√°micos y garantiza la continuidad del flujo sin interrumpir la secuencia de ejecuci√≥n.
```

## docs/commentarios del proy.md

- Characters: 52736
- Tokens: 0

```markdown
engo varios c√≥digos por separado que representan diferentes flujos para la selecci√≥n de materiales en la intervenci√≥n de un pozo petrolero: FLUJO A, FLUJO B, FLUJO C, FLUJO D, FLUJO E, FLUJO F, FLUJO G y FLUJO H. Cada uno de ellos inicia con una pregunta que, si el usuario responde ‚ÄúNO‚Äù, salta inmediatamente al siguiente flujo; y si el usuario responde ‚ÄúS√ç‚Äù, entonces ejecuta su l√≥gica, imprime una lista de materiales y luego avanza al siguiente flujo.

Los flujos se llaman y se encadenan de la siguiente forma:

FLUJO A (Ajuste de medida)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO H.
Si el usuario responde NO , salta a FLUJO B.
FLUJO B (Tubo de saca)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO C.
Si el usuario responde NO , salta a FLUJO C.
FLUJO C (tuber√≠a de Baja)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO D.
Si el usuario responde NO , salta a FLUJO D.
FLUJO D (Profundiza)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO E.
Si el usuario responde NO , salta a FLUJO E.
FLUJO E (Baja varillas)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO G.
Luego de terminar FLUJO G , debe continuar a FLUJO H .
Si el usuario responde NO , salta a FLUJO F , y al terminar FLUJO F , avanza a FLUJO H.
FLUJO F (Abandona pozo)
Luego de terminar (sea cual sea la respuesta, si aplica), avanza a FLUJO H .
FLUJO G (Instalaci√≥n BM)
Cuando termine este flujo, avanza a FLUJO H.
FLUJO H (Material de agregaci√≥n)
No es condicional: se supone que, al llegar aqu√≠, se ejecuta y finaliza.
El resultado deseado es un √∫nico script de Python que combina estos ocho flujos en el orden descrito y respeta las condiciones de salto (S√ç/NO). Cada flujo debe:

Preguntar al usuario si desea ejecutar ese flujo (excepto FLUJO H, que siempre se ejecuta al llegar).
Si responde S√ç: ejecute la l√≥gica interna de ese flujo (por ejemplo, las preguntas o procesos que inclu√≠an), e imprima la lista de materiales correspondientes.
Terminar ese flujo y, en lugar de salirse del programa, encadenar inmediatamente con el siguiente flujo indicado.
Si responde NO: saltarse la ejecuci√≥n de ese flujo (no imprime materiales) y avanzar al siguiente flujo, salvo en el caso de FLUJO A y FLUJO E, que ya tienen desv√≠os particulares a otros flujos.


EL CODIGO EJECUTADO EN JUPYTER ES: ESTA UN POCO DESPROLIJO, PERO BUENO AL MENOS FUNCIONA


import os

import pandas as pd

import ipywidgets as widgets

from IPython.display import display, clear_output

 

# Variable global para almacenar los DataFrames finales de cada flujo

materiales_finales = []

 

# Funci√≥n para renombrar las columnas y dejar solo las 5 requeridas

def renombrar_columnas(df):

    df_renombrado = df.rename(

        columns={

            "1. C√≥d.SAP": "C√≥d.SAP",

            "2. MATERIAL": "MATERIAL",

            "3. Descripci√≥n": "Descripci√≥n",

            "5.CONDICI√ìN": "CONDICI√ìN"

        }

    )

    # Asegurarse de que queden las siguientes columnas

    columnas = ["C√≥d.SAP", "MATERIAL", "Descripci√≥n", "4.CANTIDAD", "CONDICI√ìN"]

    columnas_presentes = [col for col in columnas if col in df_renombrado.columns]

    return df_renombrado[columnas_presentes]

 

# ===============================

# FLUJO A: Ajuste de medida

# ===============================

def flujo_A():

    clear_output()

    print("FLUJO A: Ajuste de medida")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¬øAjuste de medida?",

        value="seleccionar"

    )

   

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\ajuste de medida.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DI√ÅMETRO"] = df["DI√ÅMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DI√ÅMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DI√ÅMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

       

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay TIPO disponibles. Se usar√° 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

       

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay valores para {columna}. Se usar√° 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

       

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DI√ÅMETRO: {diam_value}")

       

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

       

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

       

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DI√ÅMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False] * len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False] * len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DI√ÅMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                # En lugar de mostrar inmediatamente, se almacena el DataFrame renombrado

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO A", final_df_renombrado))

                # print("Materiales del FLUJO A guardados.")  # Desactivado

               

                # Bot√≥n para continuar a FLUJO H (ya que en FLUJO A si se responde SI se salta directamente a H)

                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                def on_continue(b):

                    flujo_H()

                continue_button.on_click(on_continue)

                display(continue_button)

       

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccion√≥ NO en FLUJO A. Saltando a FLUJO B...")  # Desactivado

                flujo_B()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO B: Tubo de saca

# ===============================

def flujo_B():

    clear_output()

    print("FLUJO B: Tubo de saca")

    folder_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales"

    filename_saca = "saca tubing.xlsx"

    file_path_saca = os.path.join(folder_path, filename_saca)

    global df_saca_tubing

    df_saca_tubing = None

 

    def load_saca_tubing_excel():

        global df_saca_tubing

        if not os.path.exists(file_path_saca):

            print(f"El archivo {file_path_saca} no se encontr√≥.")

            return

        df_tmp = pd.read_excel(file_path_saca)

        df_tmp.columns = df_tmp.columns.str.strip()

        for c in df_tmp.columns:

            if df_tmp[c].dtype == object:

                df_tmp[c] = df_tmp[c].astype(str).str.strip()

        df_saca_tubing = df_tmp.copy()

        diametro_multi_picker.options = sorted(

            [d for d in df_saca_tubing['DI√ÅMETRO'].unique() if d.upper() != 'TODOS']

        )

 

    diametro_multi_picker = widgets.SelectMultiple(

        options=[],

        description='DI√ÅMETRO:',

        style={'description_width': 'initial'}

    )

    confirm_diameter_button = widgets.Button(

        description='Confirmar di√°metros',

        button_style='info'

    )

    quantities_container = widgets.VBox()

    final_output = widgets.Output()

    show_table_button = widgets.Button(

        description='Mostrar tabla final',

        button_style='success'

    )

 

    def on_show_table_button_clicked(b):

        with final_output:

            clear_output()

            if df_saca_tubing is None:

                print("No hay datos cargados de saca tubing.")

                return

            selected_diameters = list(diametro_multi_picker.value)

            df_filtered = df_saca_tubing[

                (df_saca_tubing['DI√ÅMETRO'].isin(selected_diameters)) |

                (df_saca_tubing['DI√ÅMETRO'].str.upper() == 'TODOS')

            ].copy()

            for child in quantities_container.children:

                dia = child.description

                cantidad = child.value

                mask = (df_filtered['DI√ÅMETRO'] == dia)

                df_filtered.loc[mask, '4.CANTIDAD'] = cantidad

            df_filtered_renombrado = renombrar_columnas(df_filtered)

            materiales_finales.append(("FLUJO B", df_filtered_renombrado))

            print("Materiales del FLUJO B guardados.")

 

        # Cierra la interfaz de FLUJO B

        multi_select_container.close()

 

        # Muestra el bot√≥n para continuar al FLUJO C

        continue_button = widgets.Button(

            description="Continuar a FLUJO C",

            button_style="success"

        )

        def on_continue(b):

            clear_output()

            flujo_C()

        continue_button.on_click(on_continue)

        display(continue_button)

 

    show_table_button.on_click(on_show_table_button_clicked)

 

    def on_confirm_diameter_button_clicked(b):

        with final_output:

            clear_output()

        quantities_container.children = []

        for dia in diametro_multi_picker.value:

            qty_widget = widgets.IntText(

                value=0,

                description=dia,

                style={'description_width': 'initial'}

            )

            quantities_container.children += (qty_widget,)

 

    confirm_diameter_button.on_click(on_confirm_diameter_button_clicked)

 

    multi_select_container = widgets.VBox([

        diametro_multi_picker,

        confirm_diameter_button,

        quantities_container,

        show_table_button,

        final_output

    ])

 

    bajara_tubing_picker = widgets.Dropdown(

        options=["Seleccione opci√≥n", "SI", "NO"],

        value="Seleccione opci√≥n",

        description="¬øsaca Tubing?:"

    )

 

    def on_bajara_tubing_change(change):

        clear_output()

        if change['new'] == "SI":

            load_saca_tubing_excel()

            display(multi_select_container)

        elif change['new'] == "NO":

            print("No se saca tubing.")

            flujo_C()

 

    bajara_tubing_picker.observe(on_bajara_tubing_change, names='value')

 

    print("¬øSaca Tubing?")

    display(bajara_tubing_picker)

 

# ===============================

# FLUJO C: Tuber√≠a de Baja

# ===============================

def flujo_C():

    clear_output()

    print("FLUJO C: Tuber√≠a de Baja")

    file_path_baja = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja tubing.xlsx"

    global df_baja_tubing

    df_baja_tubing = None

    output = widgets.Output()

    baja_tubing_widget = widgets.ToggleButtons(

        options=['SI', 'NO'],

        description='¬øBaja Tubing?',

        disabled=False,

        value=None

    )

    display(baja_tubing_widget, output)

   

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_baja):

                print(f"El archivo no se encontr√≥ en la ruta:\n{file_path_baja}")

                return False

            try:

                df = pd.read_excel(file_path_baja)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DI√ÅMETRO CSG' in df.columns:

                    df['DI√ÅMETRO CSG'] = df['DI√ÅMETRO CSG'].replace('nan', '').fillna('')

                global df_baja_tubing

                df_baja_tubing = df.copy()

                print("Archivo cargado y limpiado con √©xito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

   

    def show_diametro_selection():

        with output:

            print("\n--- Selecci√≥n de DI√ÅMETRO ---")

            df = df_baja_tubing

            unique_diametros = sorted([x for x in df['DI√ÅMETRO'].unique() if x != "TODOS"])

            diametro_widget = widgets.SelectMultiple(

                options=unique_diametros,

                value=(),

                description="DI√ÅMETRO",

                layout=widgets.Layout(width='50%')

            )

            display(diametro_widget)

            button_diametro = widgets.Button(description="Siguiente - Selecci√≥n DI√ÅMETRO")

            display(button_diametro)

           

            def on_diametro_button_clicked(_):

                selected = list(diametro_widget.value)

                selected_diametros = ["TODOS"] if not selected else selected

                show_tipo_accordion(selected_diametros)

            button_diametro.on_click(on_diametro_button_clicked)

   

    def show_tipo_accordion(selected_diametros):

        with output:

            print("\n--- Selecci√≥n de TIPO para cada DI√ÅMETRO ---")

            df = df_baja_tubing

            tipo_widgets = {}

            children = []

            titles = []

            for d in selected_diametros:

                df_temp = df if d=="TODOS" else df[df['DI√ÅMETRO'] == d]

                unique_tipos = sorted([x for x in df_temp['TIPO'].unique() if x != "TODOS"])

                widget_t = widgets.SelectMultiple(

                    options=unique_tipos,

                    value=(),

                    description=f"TIPO ({d})",

                    layout=widgets.Layout(width='50%')

                )

                tipo_widgets[d] = widget_t

                children.append(widget_t)

                titles.append(f"DI√ÅMETRO: {d}")

            accordion = widgets.Accordion(children=children)

            for idx, title in enumerate(titles):

                accordion.set_title(idx, title)

            display(accordion)

            button_tipo = widgets.Button(description="Siguiente - Selecci√≥n TIPO")

            display(button_tipo)

           

            def on_tipo_button_clicked(_):

                selected_tipos_dict = {}

                for d, widget_t in tipo_widgets.items():

                    st = list(widget_t.value)

                    if not st:

                        st = ["TODOS"]

                    selected_tipos_dict[d] = st

                show_diametro_csg_selection(selected_diametros, selected_tipos_dict)

            button_tipo.on_click(on_tipo_button_clicked)

   

    def show_diametro_csg_selection(selected_diametros, selected_tipos_dict):

        with output:

            print("\n--- Selecci√≥n de DI√ÅMETRO CSG ---")

            df = df_baja_tubing

            union_tipos = set()

            for tlist in selected_tipos_dict.values():

                if tlist == ["TODOS"]:

                    union_tipos.add("TODOS")

                else:

                    union_tipos.update(tlist)

                    union_tipos.add("TODOS")

            diam_filter = ["TODOS"] if selected_diametros == ["TODOS"] else selected_diametros + ["TODOS"]

            df_filtered = df[df['DI√ÅMETRO'].isin(diam_filter) & df['TIPO'].isin(union_tipos)]

            unique_csg = sorted([x for x in df_filtered['DI√ÅMETRO CSG'].unique() if x != "TODOS"])

            if not unique_csg:

                print("Nota: Solo 'TODOS' disponible para DI√ÅMETRO CSG. Se procede autom√°ticamente.")

                show_quantity_inputs(selected_diametros, selected_tipos_dict, ["TODOS"])

            else:

                csg_widget = widgets.Dropdown(

                    options=unique_csg,

                    value=unique_csg[0],

                    description="DI√ÅMETRO CSG",

                    layout=widgets.Layout(width='50%')

                )

                display(csg_widget)

                button_csg = widgets.Button(description="Siguiente - Selecci√≥n DI√ÅMETRO CSG")

                display(button_csg)

               

                def on_csg_button_clicked(_):

                    selected_csg = csg_widget.value

                    selected_csg_filter = [selected_csg, "TODOS"] if selected_csg != "TODOS" else ["TODOS"]

                    show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter)

                button_csg.on_click(on_csg_button_clicked)

   

    def show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter):

        with output:

            print("\n--- Ingreso de Cantidades ---")

            df = df_baja_tubing

            quantity_widgets = {}

            qty_items = []

            for d in selected_diametros:

                for t in selected_tipos_dict[d]:

                    key = (d, t)

                    w = widgets.IntText(

                        value=0,

                        description=f"{d} - {t}:",

                        layout=widgets.Layout(width='400px')

                    )

                    quantity_widgets[key] = w

                    qty_items.append(w)

            quantity_box = widgets.VBox(qty_items)

            display(quantity_box)

            update_qty_button = widgets.Button(description="Aplicar Cantidades", button_style="success")

            display(update_qty_button)

           

            def on_update_qty(b2):

                for (d, t), qty_widget in quantity_widgets.items():

                    qty_value = qty_widget.value

                    if d == "TODOS":

                        continue

                    condition = (df["DI√ÅMETRO"].isin([d, "TODOS"]) & df["TIPO"].isin([t, "TODOS"]))

                    df.loc[condition & df["4.CANTIDAD"].isna(), "4.CANTIDAD"] = qty_value

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in selected_tipos_dict.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict:

                        cond = (df["DI√ÅMETRO"].isin([diam_value, "TODOS"]) & df["TIPO"].isin([tipo_val, "TODOS"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO C", final_df_renombrado))

                # print("Materiales del FLUJO C guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO D", button_style="success")

                def on_continue(b):

                    flujo_D()

                continue_button.on_click(on_continue)

                display(continue_button)

            update_qty_button.on_click(on_update_qty)

   

    def on_baja_tubing_change(change):

        if change['name'] == 'value' and change['new'] is not None:

            if change['new'] == 'SI':

                if load_excel():

                    show_diametro_selection()

            else:

                with output:

                    print("No se procede con Baja Tubing.")

                flujo_D()

    baja_tubing_widget.observe(on_baja_tubing_change, names='value')

   

# ===============================

# FLUJO D: Profundiza

# ===============================

def flujo_D():

    clear_output()

    print("FLUJO D: Profundiza")

    output = widgets.Output()

    file_path_prof = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\profundiza.xlsx"

    global df_prof

    df_prof = None

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_prof):

                print(f"El archivo no se encontr√≥ en la ruta:\n{file_path_prof}")

                return False

            try:

                df = pd.read_excel(file_path_prof)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DI√ÅMETRO CSG' in df.columns:

                    df['DI√ÅMETRO CSG'] = df['DI√ÅMETRO CSG'].replace('nan', '').fillna('')

                global df_prof

                df_prof = df.copy()

                print("Archivo cargado y limpiado con √©xito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

    profundiza_widget = widgets.Dropdown(

        options=["seleccionar", "SI", "NO"],

        description="Profundizar:",

        value="seleccionar"

    )

    def on_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(output)

            if change['new'] == "SI":

                if load_excel():

                    if "DI√ÅMETRO" in df_prof.columns:

                        col_diametro = "DI√ÅMETRO"

                    elif "DI√ÅMETRO CSG" in df_prof.columns:

                        col_diametro = "DI√ÅMETRO CSG"

                    else:

                        with output:

                            print("La columna de DI√ÅMETRO no se encontr√≥ en el Excel.")

                        return

                    diametro_select = widgets.SelectMultiple(

                        options=df_prof[col_diametro].unique().tolist(),

                        description="DI√ÅMETRO",

                        rows=10

                    )

                    display(diametro_select)

                    confirm_button = widgets.Button(description="Confirmar selecci√≥n")

                    output_area = widgets.Output()

                    def on_confirm(b):

                        with output_area:

                            clear_output()

                            selected_diametros = list(diametro_select.value)

                            if not selected_diametros:

                                print("No se seleccionaron di√°metros.")

                                return

                            print("Ingrese la cantidad para cada DI√ÅMETRO seleccionado:")

                            numeric_widgets = {}

                            for d in selected_diametros:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1000000,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                            apply_button = widgets.Button(description="Aplicar cantidades")

                            def on_apply(b):

                                filtered_df = df_prof[df_prof[col_diametro].isin(selected_diametros)].copy()

                                for d in selected_diametros:

                                    cantidad = numeric_widgets[d].value

                                    filtered_df.loc[filtered_df[col_diametro] == d, "4.CANTIDAD"] = cantidad

                                final_df_renombrado = renombrar_columnas(filtered_df)

                                materiales_finales.append(("FLUJO D", final_df_renombrado))

                                # print("Materiales del FLUJO D guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO E", button_style="success")

                                def on_continue(b):

                                    flujo_E()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                            apply_button.on_click(on_apply)

                            display(apply_button)

                    confirm_button.on_click(on_confirm)

                    display(confirm_button, output_area)

            else:

                with output:

                    print("No se profundizar√° en la informaci√≥n.")

                flujo_E()

    profundiza_widget.observe(on_change)

    display(profundiza_widget)

    display(output)

 

# ===============================

# FLUJO E: Baja varillas

# ===============================

def flujo_E():

    clear_output()

    print("FLUJO E: Baja varillas")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¬øBaja Varilla?",

        value="seleccionar"

    )

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja varillas.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DI√ÅMETRO"] = df["DI√ÅMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DI√ÅMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DI√ÅMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay TIPO disponibles. Se usar√° 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay valores para {columna}. Se usar√° 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DI√ÅMETRO: {diam_value}")

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DI√ÅMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DI√ÅMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO E", final_df_renombrado))

                # print("Materiales del FLUJO E guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO G", button_style="success")

                def on_continue(b):

                    flujo_G()

                continue_button.on_click(on_continue)

                display(continue_button)

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccion√≥ NO en FLUJO E. Saltando a FLUJO F...")  # Desactivado

                flujo_F()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO F: Abandona pozo

# ===============================

def flujo_F():

    clear_output()

    print("FLUJO F: Abandona pozo")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\abandono-recupero.xlsx"

    global df_abandono

    df_abandono = None

    output = widgets.Output()

    question_widget = widgets.Dropdown(

        options=["NO", "SI"],

        value="NO",

        description="¬øAbandono/recupero?:"

    )

    def filter_by_todos(df, column, selected_values):

        if "TODOS" in selected_values:

            return df

        else:

            allowed_values = list(selected_values) + ["TODOS"]

            return df[df[column].isin(allowed_values)]

    def on_question_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(question_widget, output)

            if change['new'] == "SI":

                with output:

                    # print("Cargando el Excel...")  # (Este print no est√° en la lista a desactivar, se mantiene)

                    if not os.path.exists(file_path):

                        print(f"No se encontr√≥ el archivo:\n{file_path}")

                        return

                    global df_abandono

                    try:

                        df_abandono = pd.read_excel(file_path)

                    except Exception as e:

                        print("Error al cargar el Excel:", e)

                        return

                    print("Archivo cargado exitosamente.")

                df_abandono.columns = df_abandono.columns.str.strip()

                for col in df_abandono.columns:

                    if df_abandono[col].dtype == object:

                        df_abandono[col] = df_abandono[col].astype(str).str.strip()

                if "DI√ÅMETRO" not in df_abandono.columns:

                    with output:

                        print("La columna 'DI√ÅMETRO' no existe en el Excel.")

                    return

                unique_diametros = df_abandono["DI√ÅMETRO"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros:

                    unique_diametros.insert(0, "TODOS")

                else:

                    unique_diametros.remove("TODOS")

                    unique_diametros.insert(0, "TODOS")

                if "DI√ÅMETRO CSG" not in df_abandono.columns:

                    with output:

                        print("La columna 'DI√ÅMETRO CSG' no existe en el Excel.")

                    return

                unique_diametros_csg = df_abandono["DI√ÅMETRO CSG"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros_csg:

                    unique_diametros_csg.insert(0, "TODOS")

                else:

                    unique_diametros_csg.remove("TODOS")

                    unique_diametros_csg.insert(0, "TODOS")

                diametro_multi = widgets.SelectMultiple(

                    options=unique_diametros,

                    value=["TODOS"],

                    description="DI√ÅMETRO:",

                    rows=6

                )

                diametro_csg_single = widgets.Dropdown(

                    options=unique_diametros_csg,

                    value="TODOS",

                    description="DI√ÅM CSG:"

                )

                confirm_button = widgets.Button(

                    description="Confirmar Filtros",

                    button_style="info"

                )

                next_output = widgets.Output()

                def on_confirm_filters(b):

                    with next_output:

                        clear_output()

                        selected_diametros = list(diametro_multi.value)

                        selected_diametro_csg = diametro_csg_single.value

                        filtered_df = df_abandono.copy()

                        filtered_df = filter_by_todos(filtered_df, "DI√ÅMETRO", selected_diametros)

                        filtered_df = filter_by_todos(filtered_df, "DI√ÅMETRO CSG", [selected_diametro_csg])

                        print("Filtrado Aplicado. A continuaci√≥n, ingrese cantidades (solo para celdas vac√≠as).")

                        numeric_widgets = {}

                        diametros_especificos = [d for d in selected_diametros if d != "TODOS"]

                        if diametros_especificos:

                            print("Ingrese la cantidad para cada DI√ÅMETRO seleccionado:")

                            for d in diametros_especificos:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1e9,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                        else:

                            print("No se seleccionaron di√°metros espec√≠ficos. No se solicitar√°n cantidades.")

                        apply_button = widgets.Button(

                            description="Aplicar Cantidades",

                            button_style="success"

                        )

                        final_output = widgets.Output()

                        def on_apply_quantities(btn):

                            with final_output:

                                clear_output()

                                if "4.CANTIDAD" not in df_abandono.columns:

                                    print("La columna '4.CANTIDAD' no existe en el Excel.")

                                    return

                                df_abandono["4.CANTIDAD"] = pd.to_numeric(df_abandono["4.CANTIDAD"], errors="coerce")

                                for d in diametros_especificos:

                                    qty = numeric_widgets[d].value

                                    mask_diam = (df_abandono["DI√ÅMETRO"] == d)

                                    mask_nan = df_abandono["4.CANTIDAD"].isna()

                                    df_abandono.loc[mask_diam & mask_nan, "4.CANTIDAD"] = qty

                                filtered_final = df_abandono.copy()

                                filtered_final = filter_by_todos(filtered_final, "DI√ÅMETRO", selected_diametros)

                                filtered_final = filter_by_todos(filtered_final, "DI√ÅMETRO CSG", [selected_diametro_csg])

                                print("Listado Final Filtrado:")

                                filtered_final_renombrado = renombrar_columnas(filtered_final)

                                materiales_finales.append(("FLUJO F", filtered_final_renombrado))

                                # print("Materiales del FLUJO F guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                                def on_continue(b):

                                    flujo_H()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                        apply_button.on_click(on_apply_quantities)

                        display(apply_button, final_output)

                confirm_button.on_click(on_confirm_filters)

                display(diametro_multi, diametro_csg_single, confirm_button, next_output)

            else:

                with output:

                    # print("No se realizar√° la acci√≥n. Saltando a FLUJO H...")  # Desactivado

                    pass

                flujo_H()

    question_widget.observe(on_question_change, names='value')

    display(question_widget, output)

 

 

# ===============================

# FLUJO G: Instalaci√≥n BM

# ===============================

def flujo_G():

    clear_output()

    print("FLUJO G: Instalaci√≥n BM")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\WO.xlsx"

    pregunta_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¬øWO a BM?",

        value="seleccionar"

    )

    def mostrar_materiales(change):

        clear_output()

        display(pregunta_widget)

        if change['new'] == "SI":

            try:

                df = pd.read_excel(file_path)

                print("Lista de materiales:")

                df_renombrado = renombrar_columnas(df)

                materiales_finales.append(("FLUJO G", df_renombrado))

                # print("Materiales del FLUJO G guardados.")  # Desactivado

            except Exception as e:

                print("Error al cargar Excel:", e)

            continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

            def on_continue(b):

                flujo_H()

            continue_button.on_click(on_continue)

            display(continue_button)

        elif change['new'] == "NO":

            print("No se mostrar√°n los materiales.")

            flujo_H()

    pregunta_widget.observe(mostrar_materiales, names='value')

    display(pregunta_widget)

 

def flujo_H():

    clear_output()

    print("=== FLUJO H: Material de agregaci√≥n ===")

    try:

        file_path_H = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\GENERAL(1).xlsx"

        df_H = pd.read_excel(file_path_H)

        df_H.columns = df_H.columns.str.strip()

        if "4.CANTIDAD" not in df_H.columns:

            df_H["4.CANTIDAD"] = 0

    except Exception as e:

        print("Error al cargar el Excel:", e)

        df_H = pd.DataFrame()

   

    pregunta_widget_H = widgets.RadioButtons(

        options=["Seleccionar", "SI", "NO"],

        description="¬øAgregar m√°s material?",

        value="Seleccionar"

    )

    output_container_H = widgets.Output()

 

    apply_selection_button_H = widgets.Button(description="Aplicar selecci√≥n", button_style="info")

    apply_qty_button_H = widgets.Button(description="Asignar cantidades", button_style="success")

   

    final_list_button = widgets.Button(description="Mostrar Listado Final de Materiales", button_style="warning")

    final_button_container = widgets.VBox([final_list_button])

   

    def on_show_final_list(b):

        clear_output()

        print("Listado final de materiales de todos los flujos ejecutados:")

        for flow, df in materiales_finales:

            print(f"\n---- {flow} ----")

            display(df)

    final_list_button.on_click(on_show_final_list)

   

    if not df_H.empty and "2. MATERIAL" in df_H.columns:

        materiales = df_H["2. MATERIAL"].astype(str).unique().tolist()

    else:

        materiales = []

    materiales_widget_H = widgets.SelectMultiple(

        options=materiales,

        description="Materiales",

        layout=widgets.Layout(width='50%', height='150px')

    )

    qty_widgets_H = {}

   

    def on_apply_selection_H(b):

        with output_container_H:

            clear_output()

            seleccionados = list(materiales_widget_H.value)

            if not seleccionados:

                print("No se seleccion√≥ ning√∫n material.")

                return

            print("Materiales seleccionados:")

            for mat in seleccionados:

                print("-", mat)

            qty_widgets_H.clear()

            input_boxes = []

            for mat in seleccionados:

                qty_box = widgets.BoundedFloatText(

                    value=0,

                    min=0,

                    step=1,

                    description=f"Cant: {mat}",

                    layout=widgets.Layout(width='50%')

                )

                qty_widgets_H[mat] = qty_box

                input_boxes.append(qty_box)

            display(widgets.VBox(input_boxes))

            display(apply_qty_button_H)

   

    def on_apply_qty_H(b):

        with output_container_H:

            clear_output()

            if df_H.empty:

                print("El DataFrame est√° vac√≠o o no se carg√≥ correctamente.")

                return

            selected_materials = list(qty_widgets_H.keys())

            for mat, widget_box in qty_widgets_H.items():

                cant = widget_box.value

                df_H.loc[df_H["2. MATERIAL"].astype(str) == mat, "4.CANTIDAD"] = cant

            assigned_df = df_H[

                df_H["2. MATERIAL"].astype(str).isin(selected_materials) &

                (df_H["4.CANTIDAD"] > 0)

            ]

            if not assigned_df.empty:

                assigned_df_renombrado = renombrar_columnas(assigned_df)

                materiales_finales.append(("FLUJO H", assigned_df_renombrado))

                # print("Materiales del FLUJO H guardados.")  # Desactivado

            else:

                print("No se asignaron cantidades (o todas fueron 0).")

           

            display(final_button_container)

   

    def on_pregunta_change_H(change):

        with output_container_H:

            clear_output()

            if change['new'] == "SI":

                if df_H.empty:

                    print("El DataFrame no se carg√≥ o est√° vac√≠o.")

                    return

                print("Lista completa de materiales del Excel:\n")

                display(df_H)

                print("\nSeleccione los materiales que desea agregar:")

                display(materiales_widget_H)

                display(apply_selection_button_H)

            elif change['new'] == "NO":

                print("No se agregar√°n m√°s materiales.")

                display(final_button_container)

   

    pregunta_widget_H.observe(on_pregunta_change_H, names='value')

    apply_selection_button_H.on_click(on_apply_selection_H)

    apply_qty_button_H.on_click(on_apply_qty_H)

   

    display(pregunta_widget_H)

    display(output_container_H)

   

    # print("FLUJO H finalizado. Fin del proceso.")  # Desactivado

 

 

# ===============================

# Funci√≥n principal: inicia en FLUJO A

# ===============================

def main():

    flujo_A()

 

# Inicia el proceso

main()
```

## docs/Estructura del proyecto.md

- Characters: 6225
- Tokens: 0

```markdown
üîπ 1. Introducci√≥n
Este documento detalla la arquitectura propuesta para la implementaci√≥n de un sistema de flujos modulares en una aplicaci√≥n basada en Python y Flask. El objetivo es permitir la ejecuci√≥n de m√∫ltiples flujos de trabajo (Flujo A, B, C, etc.), en los cuales cada flujo es un m√≥dulo independiente que recibe entradas del usuario, filtra datos de archivos Excel, y proporciona salidas que pueden afectar a los siguientes flujos.

üîπ 2. An√°lisis Inicial del Problema
El c√≥digo original consist√≠a en una serie de filtros aplicados secuencialmente sobre distintos archivos de datos. Cada flujo:

Preguntaba al usuario si deb√≠a ejecutarse.
Aplicaba filtros a un conjunto de datos en funci√≥n de la respuesta.
Mostraba los materiales resultantes.
Determinaba el siguiente flujo a ejecutar.
üìå Conclusi√≥n: La l√≥gica de cada flujo era principalmente un filtro condicional sobre un conjunto de datos basado en respuestas del usuario.

Problemas detectados en la implementaci√≥n inicial
‚ùå C√≥digo monol√≠tico y dif√≠cil de extender.
‚ùå Falta de modularidad: cada flujo estaba acoplado a la l√≥gica general.
‚ùå No hab√≠a un manejo centralizado del estado y flujo de datos.

üîπ 3. Patr√≥n de Dise√±o Elegido
Se adopt√≥ una arquitectura basada en plugins combinada con un manejo centralizado del flujo utilizando Flask Sessions. Esto permite:

üìå Modularidad: Cada flujo es un plugin independiente que puede a√±adirse sin modificar la estructura general.
üìå Flexibilidad: El orden de ejecuci√≥n se define externamente y no dentro de cada m√≥dulo.
üìå Escalabilidad: Es f√°cil agregar nuevos flujos sin afectar el sistema.
üìå Manejo de Estado: Se utiliza Flask Sessions para almacenar respuestas y materiales seleccionados.
üîπ Patr√≥n de dise√±o:
Plugin-Based Architecture + State Management
Cada flujo act√∫a como un plugin independiente y el sistema maneja las transiciones y datos entre ellos.

üîπ 4. Arquitectura Resultante
üìÇ Estructura del Proyecto
bash
Copy
Edit
/app
  ‚îú‚îÄ‚îÄ main.py               # Punto de entrada de la aplicaci√≥n
  ‚îú‚îÄ‚îÄ flujo_loader.py       # Carga y gestiona los flujos din√°micamente
  ‚îú‚îÄ‚îÄ plugins/              # M√≥dulos independientes de cada flujo
  ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_a.py        # Flujo A
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_b.py        # Flujo B
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_c.py        # Flujo C
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_d.py        # Flujo D
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_e.py        # Flujo E
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_f.py        # Flujo F
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_g.py        # Flujo G
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_h.py        # Flujo H (siempre se ejecuta)
  ‚îú‚îÄ‚îÄ templates/            # HTML para la interfaz de usuario
  ‚îÇ   ‚îú‚îÄ‚îÄ base.html
  ‚îÇ   ‚îú‚îÄ‚îÄ index.html
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo.html        # P√°gina gen√©rica para cada flujo
  ‚îÇ   ‚îú‚îÄ‚îÄ resultados.html   # P√°gina de resultados finales
  ‚îú‚îÄ‚îÄ static/               # Archivos CSS y JS
  ‚îú‚îÄ‚îÄ data/                 # Archivos Excel
  ‚îú‚îÄ‚îÄ requirements.txt
  ‚îî‚îÄ‚îÄ README.md
üîπ 5. Manejo del Flujo de Ejecuci√≥n
En lugar de definir el orden de los flujos dentro de cada m√≥dulo, se utiliza un diccionario de transici√≥n que maneja la l√≥gica centralmente.

üìå Configuraci√≥n de flujos en flujo_loader.py

python
Copy
Edit
SECUENCIA_FLUJOS = {
    "A": {"SI": "H", "NO": "B"},
    "B": {"SI": "C", "NO": "C"},
    "C": {"SI": "D", "NO": "D"},
    "D": {"SI": "E", "NO": "E"},
    "E": {"SI": "G", "NO": "F"},
    "F": {"SI": "H", "NO": "H"},
    "G": {"SI": "H", "NO": "H"},
    "H": None  # √öltimo flujo
}
üìå C√≥mo funciona:

Cada flujo tiene una entrada (respuesta del usuario).
Se determina el siguiente flujo basado en la respuesta (SI o NO).
Los datos de cada flujo se almacenan en session para ser utilizados en flujos posteriores.
üîπ 6. Ejemplo de Flujo Individual
Cada flujo es un m√≥dulo independiente en la carpeta plugins/.

üìå Ejemplo de plugins/flujo_a.py

python
Copy
Edit
from flask import render_template, request

nombre = "A"

def ejecutar():
    if request.method == "POST":
        respuesta = request.form.get("respuesta")
        materiales_seleccionados = ["Material X", "Material Y"] if respuesta == "SI" else []
        return respuesta, materiales_seleccionados

    return render_template("flujo.html", flujo=nombre)
üìå Explicaci√≥n:

Cada flujo recibe una entrada (POST del usuario).
Si el usuario responde "SI", filtra materiales y los guarda.
Si el usuario responde "NO", se salta el procesamiento.
El sistema decide cu√°l es el siguiente flujo.
üîπ 7. Manejo del Estado Global
Se utiliza Flask Sessions para mantener los datos entre flujos.

üìå Ejemplo de c√≥mo se almacenan los datos en session

python
Copy
Edit
@app.route("/flujo/<nombre_flujo>", methods=["GET", "POST"])
def flujo(nombre_flujo):
    if nombre_flujo in flujos:
        respuesta, materiales, siguiente_flujo = ejecutar_flujo(nombre_flujo, session)

        # Guardar en sesi√≥n
        session[nombre_flujo] = {"respuesta": respuesta, "materiales": materiales}

        # Continuar al siguiente flujo o finalizar
        return redirect(url_for("flujo", nombre_flujo=siguiente_flujo)) if siguiente_flujo else redirect(url_for("resultados"))

    return redirect(url_for("index"))
üìå Beneficios del uso de session ‚úî Permite almacenar datos persistentes sin base de datos.
‚úî Mantiene la continuidad entre flujos.
‚úî Hace que cada flujo sea independiente sin necesidad de modificar otros flujos.

üîπ 8. Beneficios de la Arquitectura
Caracter√≠stica	Beneficio
Plugins Modulares	Se pueden agregar nuevos flujos sin modificar main.py.
Configuraci√≥n Centralizada	El orden de ejecuci√≥n se define en flujo_loader.py.
Manejo de Estado con session	Cada flujo puede acceder a respuestas y materiales previos.
Separaci√≥n de Responsabilidades	main.py maneja la app, flujo_loader.py los flujos, y los plugins contienen la l√≥gica espec√≠fica.
Escalabilidad	F√°cil de expandir sin modificar el c√≥digo existente.
üîπ 9. Conclusi√≥n
Se pas√≥ de una estructura monol√≠tica a una arquitectura basada en plugins donde:

Cada flujo es un m√≥dulo aut√≥nomo con entrada y salida.
El flujo de ejecuci√≥n es gestionado din√°micamente.
Se utiliza session para almacenar respuestas y datos.
Los desarrolladores pueden agregar nuevos flujos sin modificar la estructura base.
Este modelo permite escalabilidad, modularidad y facilidad de mantenimiento, aline√°ndose con buenas pr√°cticas de arquitectura de software.
```

## README.md

- Characters: 1903
- Tokens: 0

```markdown
# Visualizador de Excel

Esta aplicaci√≥n simple permite visualizar archivos Excel como tablas HTML en un navegador web.

## Requisitos

- Python 3.6 o superior
- pip (gestor de paquetes de Python)

## Instalaci√≥n

1. Clona o descarga este repositorio
2. Instala las dependencias:

# Configuraci√≥n y ejecuci√≥n en VS Code (Windows)
Requisitos previos

Python 3.6 o superior
pip (gestor de paquetes de Python)

Pasos para ejecutar la aplicaci√≥n
1. Clonar el repositorio
Copygit clone [URL_DEL_REPOSITORIO]
cd mi_app
2. Crear y activar un entorno virtual
Copy# Crear entorno virtual
python -m venv venv

# Activar el entorno virtual
venv\Scripts\activate
3. Instalar dependencias
Copy# Instalar todas las dependencias necesarias
pip install flask==2.3.3 openpyxl==3.1.2 pandas xlrd==2.0.1
4. Preparar los archivos Excel

Coloca tus archivos Excel (.xlsx o .xls) en la carpeta app/data/
Si la carpeta no existe, se crear√° autom√°ticamente al iniciar la aplicaci√≥n

5. Ejecutar la aplicaci√≥n
Copy# Navegar a la carpeta app
cd app

# Iniciar la aplicaci√≥n
python main.py
6. Acceder a la aplicaci√≥n

Abre tu navegador y navega a: http://127.0.0.1:5000
Ver√°s todos los archivos Excel cargados y podr√°s iniciar los flujos de trabajo

7. Desactivar el entorno virtual cuando termines
Copydeactivate
Soluci√≥n de problemas comunes

Error "No module named...": Verifica que el entorno virtual est√© activado y que todas las dependencias est√©n instaladas
Archivos Excel no visibles: Aseg√∫rate de que est√©n en la carpeta correcta (app/data/) y tengan la extensi√≥n correcta (.xlsx o .xls)

3. Abre tu navegador y ve a `http://localhost:5000`

## Notas

- La aplicaci√≥n mostrar√° todos los archivos Excel (.xlsx o .xls) encontrados en la carpeta `data`
- Cada archivo se convertir√° en una tabla HTML
- Puedes recargar la p√°gina para actualizar los datos si agregas nuevos archivos Excel mientras la aplicaci√≥n est√° corriendo
```

## .gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## Statistics

- Total Files: 21
- Total Characters: 225665
- Total Tokens: 0
``````

## docs/Flujo A - Doc tecnico.md

- Characters: 2871
- Tokens: 0

```markdown
üìå Especificaci√≥n T√©cnica para Desarrollo ‚Äì FLUJO A (Ajuste de Medida)
1Ô∏è‚É£ Descripci√≥n General
FLUJO A permite al usuario seleccionar materiales basados en criterios espec√≠ficos de ajuste de medida. Si el usuario acepta el ajuste, el flujo filtra los materiales y salta directamente a FLUJO H. Si el usuario rechaza, salta a FLUJO B sin procesar datos.

2Ô∏è‚É£ Datos de Entrada
La informaci√≥n proviene de una tabla estructurada (ajuste_de_medida.xlsx), con las siguientes columnas clave:

Columna	Tipo	Descripci√≥n
DI√ÅMETRO	string	Di√°metro del material
TIPO	string	Tipo de material
GRADO DE ACERO	string	Grado de acero
GRADO DE ACERO CUPLA	string	Grado de acero de la cupla
TIPO DE CUPLA	string	Tipo de cupla
4.CANTIDAD	float	Cantidad del material (opcional)
3Ô∏è‚É£ Flujo de Ejecuci√≥n
Pregunta al usuario:

Si responde "NO" ‚Üí Salta directamente a FLUJO B.
Si responde "S√ç" ‚Üí Carga la tabla y aplica filtros.
Carga y Filtrado de Datos:

Carga la tabla ajuste_de_medida.xlsx y limpia valores.
El usuario selecciona valores en los siguientes filtros:
DI√ÅMETRO
TIPO
GRADO DE ACERO
GRADO DE ACERO CUPLA
TIPO DE CUPLA
Si el usuario no selecciona un valor, se usa "TODOS" como fallback.
Construcci√≥n de final_condition (m√°scara booleana de filtrado):

Inicializa final_condition con False para excluir todos los registros.
Para cada DI√ÅMETRO seleccionado, eval√∫a si los materiales cumplen con los criterios del usuario.
Incluye "TODOS" en cada filtro para garantizar que los valores no seleccionados no eliminen registros √∫tiles.
Se combinan las condiciones (| l√≥gico) para crear el filtro final.
Aplicaci√≥n del Filtro:

python
Copy
Edit
final_df = df[final_condition]
Solo quedan los materiales que cumplen con los criterios del usuario.
Almacena los materiales filtrados en materiales_finales:

python
Copy
Edit
materiales_finales.append(("FLUJO A", final_df_renombrado))
Salto a FLUJO H (el flujo no sigue la secuencia normal):

Si el usuario ejecuta FLUJO A, no sigue a FLUJO B, sino directamente a FLUJO H.
4Ô∏è‚É£ Consideraciones T√©cnicas
‚úî No modifica la estructura de la tabla, solo aplica filtros.
‚úî Debe permitir m√∫ltiples selecciones en cada filtro.
‚úî Evita p√©rdida de datos con "TODOS" en cada condici√≥n.
‚úî Encapsular final_condition como l√≥gica reutilizable para otros flujos.
‚úî Optimizar el acceso a archivos si se requiere ejecuci√≥n frecuente.

üìå Resumen Final
FLUJO A solo se ejecuta si el usuario dice "S√ç".
Carga una tabla de materiales y filtra datos seg√∫n selecci√≥n del usuario.
Almacena los materiales seleccionados y salta directamente a FLUJO H.
Si el usuario dice "NO", salta a FLUJO B sin procesar nada.
final_condition es el mecanismo que define qu√© materiales quedan en la selecci√≥n final.
üöÄ Resultado esperado: Un m√≥dulo optimizado que procesa materiales en base a filtros din√°micos y garantiza la continuidad del flujo sin interrumpir la secuencia de ejecuci√≥n.
```

## docs/commentarios del proy.md

- Characters: 52736
- Tokens: 0

```markdown
engo varios c√≥digos por separado que representan diferentes flujos para la selecci√≥n de materiales en la intervenci√≥n de un pozo petrolero: FLUJO A, FLUJO B, FLUJO C, FLUJO D, FLUJO E, FLUJO F, FLUJO G y FLUJO H. Cada uno de ellos inicia con una pregunta que, si el usuario responde ‚ÄúNO‚Äù, salta inmediatamente al siguiente flujo; y si el usuario responde ‚ÄúS√ç‚Äù, entonces ejecuta su l√≥gica, imprime una lista de materiales y luego avanza al siguiente flujo.

Los flujos se llaman y se encadenan de la siguiente forma:

FLUJO A (Ajuste de medida)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO H.
Si el usuario responde NO , salta a FLUJO B.
FLUJO B (Tubo de saca)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO C.
Si el usuario responde NO , salta a FLUJO C.
FLUJO C (tuber√≠a de Baja)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO D.
Si el usuario responde NO , salta a FLUJO D.
FLUJO D (Profundiza)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO E.
Si el usuario responde NO , salta a FLUJO E.
FLUJO E (Baja varillas)
Si el usuario responde S√ç , se ejecuta el flujo, se imprimen los materiales, y al terminar salta a FLUJO G.
Luego de terminar FLUJO G , debe continuar a FLUJO H .
Si el usuario responde NO , salta a FLUJO F , y al terminar FLUJO F , avanza a FLUJO H.
FLUJO F (Abandona pozo)
Luego de terminar (sea cual sea la respuesta, si aplica), avanza a FLUJO H .
FLUJO G (Instalaci√≥n BM)
Cuando termine este flujo, avanza a FLUJO H.
FLUJO H (Material de agregaci√≥n)
No es condicional: se supone que, al llegar aqu√≠, se ejecuta y finaliza.
El resultado deseado es un √∫nico script de Python que combina estos ocho flujos en el orden descrito y respeta las condiciones de salto (S√ç/NO). Cada flujo debe:

Preguntar al usuario si desea ejecutar ese flujo (excepto FLUJO H, que siempre se ejecuta al llegar).
Si responde S√ç: ejecute la l√≥gica interna de ese flujo (por ejemplo, las preguntas o procesos que inclu√≠an), e imprima la lista de materiales correspondientes.
Terminar ese flujo y, en lugar de salirse del programa, encadenar inmediatamente con el siguiente flujo indicado.
Si responde NO: saltarse la ejecuci√≥n de ese flujo (no imprime materiales) y avanzar al siguiente flujo, salvo en el caso de FLUJO A y FLUJO E, que ya tienen desv√≠os particulares a otros flujos.


EL CODIGO EJECUTADO EN JUPYTER ES: ESTA UN POCO DESPROLIJO, PERO BUENO AL MENOS FUNCIONA


import os

import pandas as pd

import ipywidgets as widgets

from IPython.display import display, clear_output

 

# Variable global para almacenar los DataFrames finales de cada flujo

materiales_finales = []

 

# Funci√≥n para renombrar las columnas y dejar solo las 5 requeridas

def renombrar_columnas(df):

    df_renombrado = df.rename(

        columns={

            "1. C√≥d.SAP": "C√≥d.SAP",

            "2. MATERIAL": "MATERIAL",

            "3. Descripci√≥n": "Descripci√≥n",

            "5.CONDICI√ìN": "CONDICI√ìN"

        }

    )

    # Asegurarse de que queden las siguientes columnas

    columnas = ["C√≥d.SAP", "MATERIAL", "Descripci√≥n", "4.CANTIDAD", "CONDICI√ìN"]

    columnas_presentes = [col for col in columnas if col in df_renombrado.columns]

    return df_renombrado[columnas_presentes]

 

# ===============================

# FLUJO A: Ajuste de medida

# ===============================

def flujo_A():

    clear_output()

    print("FLUJO A: Ajuste de medida")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¬øAjuste de medida?",

        value="seleccionar"

    )

   

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\ajuste de medida.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DI√ÅMETRO"] = df["DI√ÅMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DI√ÅMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DI√ÅMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

       

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay TIPO disponibles. Se usar√° 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

       

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay valores para {columna}. Se usar√° 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

       

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DI√ÅMETRO: {diam_value}")

       

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

       

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

       

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DI√ÅMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False] * len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False] * len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DI√ÅMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                # En lugar de mostrar inmediatamente, se almacena el DataFrame renombrado

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO A", final_df_renombrado))

                # print("Materiales del FLUJO A guardados.")  # Desactivado

               

                # Bot√≥n para continuar a FLUJO H (ya que en FLUJO A si se responde SI se salta directamente a H)

                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                def on_continue(b):

                    flujo_H()

                continue_button.on_click(on_continue)

                display(continue_button)

       

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccion√≥ NO en FLUJO A. Saltando a FLUJO B...")  # Desactivado

                flujo_B()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO B: Tubo de saca

# ===============================

def flujo_B():

    clear_output()

    print("FLUJO B: Tubo de saca")

    folder_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales"

    filename_saca = "saca tubing.xlsx"

    file_path_saca = os.path.join(folder_path, filename_saca)

    global df_saca_tubing

    df_saca_tubing = None

 

    def load_saca_tubing_excel():

        global df_saca_tubing

        if not os.path.exists(file_path_saca):

            print(f"El archivo {file_path_saca} no se encontr√≥.")

            return

        df_tmp = pd.read_excel(file_path_saca)

        df_tmp.columns = df_tmp.columns.str.strip()

        for c in df_tmp.columns:

            if df_tmp[c].dtype == object:

                df_tmp[c] = df_tmp[c].astype(str).str.strip()

        df_saca_tubing = df_tmp.copy()

        diametro_multi_picker.options = sorted(

            [d for d in df_saca_tubing['DI√ÅMETRO'].unique() if d.upper() != 'TODOS']

        )

 

    diametro_multi_picker = widgets.SelectMultiple(

        options=[],

        description='DI√ÅMETRO:',

        style={'description_width': 'initial'}

    )

    confirm_diameter_button = widgets.Button(

        description='Confirmar di√°metros',

        button_style='info'

    )

    quantities_container = widgets.VBox()

    final_output = widgets.Output()

    show_table_button = widgets.Button(

        description='Mostrar tabla final',

        button_style='success'

    )

 

    def on_show_table_button_clicked(b):

        with final_output:

            clear_output()

            if df_saca_tubing is None:

                print("No hay datos cargados de saca tubing.")

                return

            selected_diameters = list(diametro_multi_picker.value)

            df_filtered = df_saca_tubing[

                (df_saca_tubing['DI√ÅMETRO'].isin(selected_diameters)) |

                (df_saca_tubing['DI√ÅMETRO'].str.upper() == 'TODOS')

            ].copy()

            for child in quantities_container.children:

                dia = child.description

                cantidad = child.value

                mask = (df_filtered['DI√ÅMETRO'] == dia)

                df_filtered.loc[mask, '4.CANTIDAD'] = cantidad

            df_filtered_renombrado = renombrar_columnas(df_filtered)

            materiales_finales.append(("FLUJO B", df_filtered_renombrado))

            print("Materiales del FLUJO B guardados.")

 

        # Cierra la interfaz de FLUJO B

        multi_select_container.close()

 

        # Muestra el bot√≥n para continuar al FLUJO C

        continue_button = widgets.Button(

            description="Continuar a FLUJO C",

            button_style="success"

        )

        def on_continue(b):

            clear_output()

            flujo_C()

        continue_button.on_click(on_continue)

        display(continue_button)

 

    show_table_button.on_click(on_show_table_button_clicked)

 

    def on_confirm_diameter_button_clicked(b):

        with final_output:

            clear_output()

        quantities_container.children = []

        for dia in diametro_multi_picker.value:

            qty_widget = widgets.IntText(

                value=0,

                description=dia,

                style={'description_width': 'initial'}

            )

            quantities_container.children += (qty_widget,)

 

    confirm_diameter_button.on_click(on_confirm_diameter_button_clicked)

 

    multi_select_container = widgets.VBox([

        diametro_multi_picker,

        confirm_diameter_button,

        quantities_container,

        show_table_button,

        final_output

    ])

 

    bajara_tubing_picker = widgets.Dropdown(

        options=["Seleccione opci√≥n", "SI", "NO"],

        value="Seleccione opci√≥n",

        description="¬øsaca Tubing?:"

    )

 

    def on_bajara_tubing_change(change):

        clear_output()

        if change['new'] == "SI":

            load_saca_tubing_excel()

            display(multi_select_container)

        elif change['new'] == "NO":

            print("No se saca tubing.")

            flujo_C()

 

    bajara_tubing_picker.observe(on_bajara_tubing_change, names='value')

 

    print("¬øSaca Tubing?")

    display(bajara_tubing_picker)

 

# ===============================

# FLUJO C: Tuber√≠a de Baja

# ===============================

def flujo_C():

    clear_output()

    print("FLUJO C: Tuber√≠a de Baja")

    file_path_baja = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja tubing.xlsx"

    global df_baja_tubing

    df_baja_tubing = None

    output = widgets.Output()

    baja_tubing_widget = widgets.ToggleButtons(

        options=['SI', 'NO'],

        description='¬øBaja Tubing?',

        disabled=False,

        value=None

    )

    display(baja_tubing_widget, output)

   

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_baja):

                print(f"El archivo no se encontr√≥ en la ruta:\n{file_path_baja}")

                return False

            try:

                df = pd.read_excel(file_path_baja)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DI√ÅMETRO CSG' in df.columns:

                    df['DI√ÅMETRO CSG'] = df['DI√ÅMETRO CSG'].replace('nan', '').fillna('')

                global df_baja_tubing

                df_baja_tubing = df.copy()

                print("Archivo cargado y limpiado con √©xito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

   

    def show_diametro_selection():

        with output:

            print("\n--- Selecci√≥n de DI√ÅMETRO ---")

            df = df_baja_tubing

            unique_diametros = sorted([x for x in df['DI√ÅMETRO'].unique() if x != "TODOS"])

            diametro_widget = widgets.SelectMultiple(

                options=unique_diametros,

                value=(),

                description="DI√ÅMETRO",

                layout=widgets.Layout(width='50%')

            )

            display(diametro_widget)

            button_diametro = widgets.Button(description="Siguiente - Selecci√≥n DI√ÅMETRO")

            display(button_diametro)

           

            def on_diametro_button_clicked(_):

                selected = list(diametro_widget.value)

                selected_diametros = ["TODOS"] if not selected else selected

                show_tipo_accordion(selected_diametros)

            button_diametro.on_click(on_diametro_button_clicked)

   

    def show_tipo_accordion(selected_diametros):

        with output:

            print("\n--- Selecci√≥n de TIPO para cada DI√ÅMETRO ---")

            df = df_baja_tubing

            tipo_widgets = {}

            children = []

            titles = []

            for d in selected_diametros:

                df_temp = df if d=="TODOS" else df[df['DI√ÅMETRO'] == d]

                unique_tipos = sorted([x for x in df_temp['TIPO'].unique() if x != "TODOS"])

                widget_t = widgets.SelectMultiple(

                    options=unique_tipos,

                    value=(),

                    description=f"TIPO ({d})",

                    layout=widgets.Layout(width='50%')

                )

                tipo_widgets[d] = widget_t

                children.append(widget_t)

                titles.append(f"DI√ÅMETRO: {d}")

            accordion = widgets.Accordion(children=children)

            for idx, title in enumerate(titles):

                accordion.set_title(idx, title)

            display(accordion)

            button_tipo = widgets.Button(description="Siguiente - Selecci√≥n TIPO")

            display(button_tipo)

           

            def on_tipo_button_clicked(_):

                selected_tipos_dict = {}

                for d, widget_t in tipo_widgets.items():

                    st = list(widget_t.value)

                    if not st:

                        st = ["TODOS"]

                    selected_tipos_dict[d] = st

                show_diametro_csg_selection(selected_diametros, selected_tipos_dict)

            button_tipo.on_click(on_tipo_button_clicked)

   

    def show_diametro_csg_selection(selected_diametros, selected_tipos_dict):

        with output:

            print("\n--- Selecci√≥n de DI√ÅMETRO CSG ---")

            df = df_baja_tubing

            union_tipos = set()

            for tlist in selected_tipos_dict.values():

                if tlist == ["TODOS"]:

                    union_tipos.add("TODOS")

                else:

                    union_tipos.update(tlist)

                    union_tipos.add("TODOS")

            diam_filter = ["TODOS"] if selected_diametros == ["TODOS"] else selected_diametros + ["TODOS"]

            df_filtered = df[df['DI√ÅMETRO'].isin(diam_filter) & df['TIPO'].isin(union_tipos)]

            unique_csg = sorted([x for x in df_filtered['DI√ÅMETRO CSG'].unique() if x != "TODOS"])

            if not unique_csg:

                print("Nota: Solo 'TODOS' disponible para DI√ÅMETRO CSG. Se procede autom√°ticamente.")

                show_quantity_inputs(selected_diametros, selected_tipos_dict, ["TODOS"])

            else:

                csg_widget = widgets.Dropdown(

                    options=unique_csg,

                    value=unique_csg[0],

                    description="DI√ÅMETRO CSG",

                    layout=widgets.Layout(width='50%')

                )

                display(csg_widget)

                button_csg = widgets.Button(description="Siguiente - Selecci√≥n DI√ÅMETRO CSG")

                display(button_csg)

               

                def on_csg_button_clicked(_):

                    selected_csg = csg_widget.value

                    selected_csg_filter = [selected_csg, "TODOS"] if selected_csg != "TODOS" else ["TODOS"]

                    show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter)

                button_csg.on_click(on_csg_button_clicked)

   

    def show_quantity_inputs(selected_diametros, selected_tipos_dict, selected_csg_filter):

        with output:

            print("\n--- Ingreso de Cantidades ---")

            df = df_baja_tubing

            quantity_widgets = {}

            qty_items = []

            for d in selected_diametros:

                for t in selected_tipos_dict[d]:

                    key = (d, t)

                    w = widgets.IntText(

                        value=0,

                        description=f"{d} - {t}:",

                        layout=widgets.Layout(width='400px')

                    )

                    quantity_widgets[key] = w

                    qty_items.append(w)

            quantity_box = widgets.VBox(qty_items)

            display(quantity_box)

            update_qty_button = widgets.Button(description="Aplicar Cantidades", button_style="success")

            display(update_qty_button)

           

            def on_update_qty(b2):

                for (d, t), qty_widget in quantity_widgets.items():

                    qty_value = qty_widget.value

                    if d == "TODOS":

                        continue

                    condition = (df["DI√ÅMETRO"].isin([d, "TODOS"]) & df["TIPO"].isin([t, "TODOS"]))

                    df.loc[condition & df["4.CANTIDAD"].isna(), "4.CANTIDAD"] = qty_value

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in selected_tipos_dict.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict:

                        cond = (df["DI√ÅMETRO"].isin([diam_value, "TODOS"]) & df["TIPO"].isin([tipo_val, "TODOS"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO C", final_df_renombrado))

                # print("Materiales del FLUJO C guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO D", button_style="success")

                def on_continue(b):

                    flujo_D()

                continue_button.on_click(on_continue)

                display(continue_button)

            update_qty_button.on_click(on_update_qty)

   

    def on_baja_tubing_change(change):

        if change['name'] == 'value' and change['new'] is not None:

            if change['new'] == 'SI':

                if load_excel():

                    show_diametro_selection()

            else:

                with output:

                    print("No se procede con Baja Tubing.")

                flujo_D()

    baja_tubing_widget.observe(on_baja_tubing_change, names='value')

   

# ===============================

# FLUJO D: Profundiza

# ===============================

def flujo_D():

    clear_output()

    print("FLUJO D: Profundiza")

    output = widgets.Output()

    file_path_prof = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\profundiza.xlsx"

    global df_prof

    df_prof = None

    def load_excel():

        with output:

            print("\n--- Carga del Excel ---")

            if not os.path.exists(file_path_prof):

                print(f"El archivo no se encontr√≥ en la ruta:\n{file_path_prof}")

                return False

            try:

                df = pd.read_excel(file_path_prof)

                df.columns = df.columns.str.strip()

                for col in df.columns:

                    if df[col].dtype == object:

                        df[col] = df[col].astype(str).str.strip()

                if 'TIPO' in df.columns:

                    df['TIPO'] = df['TIPO'].replace('nan', '').fillna('')

                if 'DI√ÅMETRO CSG' in df.columns:

                    df['DI√ÅMETRO CSG'] = df['DI√ÅMETRO CSG'].replace('nan', '').fillna('')

                global df_prof

                df_prof = df.copy()

                print("Archivo cargado y limpiado con √©xito.")

                return True

            except Exception as e:

                print("Error al cargar el Excel:", e)

                return False

    profundiza_widget = widgets.Dropdown(

        options=["seleccionar", "SI", "NO"],

        description="Profundizar:",

        value="seleccionar"

    )

    def on_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(output)

            if change['new'] == "SI":

                if load_excel():

                    if "DI√ÅMETRO" in df_prof.columns:

                        col_diametro = "DI√ÅMETRO"

                    elif "DI√ÅMETRO CSG" in df_prof.columns:

                        col_diametro = "DI√ÅMETRO CSG"

                    else:

                        with output:

                            print("La columna de DI√ÅMETRO no se encontr√≥ en el Excel.")

                        return

                    diametro_select = widgets.SelectMultiple(

                        options=df_prof[col_diametro].unique().tolist(),

                        description="DI√ÅMETRO",

                        rows=10

                    )

                    display(diametro_select)

                    confirm_button = widgets.Button(description="Confirmar selecci√≥n")

                    output_area = widgets.Output()

                    def on_confirm(b):

                        with output_area:

                            clear_output()

                            selected_diametros = list(diametro_select.value)

                            if not selected_diametros:

                                print("No se seleccionaron di√°metros.")

                                return

                            print("Ingrese la cantidad para cada DI√ÅMETRO seleccionado:")

                            numeric_widgets = {}

                            for d in selected_diametros:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1000000,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                            apply_button = widgets.Button(description="Aplicar cantidades")

                            def on_apply(b):

                                filtered_df = df_prof[df_prof[col_diametro].isin(selected_diametros)].copy()

                                for d in selected_diametros:

                                    cantidad = numeric_widgets[d].value

                                    filtered_df.loc[filtered_df[col_diametro] == d, "4.CANTIDAD"] = cantidad

                                final_df_renombrado = renombrar_columnas(filtered_df)

                                materiales_finales.append(("FLUJO D", final_df_renombrado))

                                # print("Materiales del FLUJO D guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO E", button_style="success")

                                def on_continue(b):

                                    flujo_E()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                            apply_button.on_click(on_apply)

                            display(apply_button)

                    confirm_button.on_click(on_confirm)

                    display(confirm_button, output_area)

            else:

                with output:

                    print("No se profundizar√° en la informaci√≥n.")

                flujo_E()

    profundiza_widget.observe(on_change)

    display(profundiza_widget)

    display(output)

 

# ===============================

# FLUJO E: Baja varillas

# ===============================

def flujo_E():

    clear_output()

    print("FLUJO E: Baja varillas")

    varilla_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¬øBaja Varilla?",

        value="seleccionar"

    )

    def load_excel_and_create_filters():

        clear_output()

        # print("Cargando archivo Excel...")  # Desactivado

        try:

            file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\baja varillas.xlsx"

            df = pd.read_excel(file_path)

            df.columns = df.columns.str.strip()

            df["DI√ÅMETRO"] = df["DI√ÅMETRO"].astype(str).str.strip()

            # print("Excel cargado correctamente.\n")  # Desactivado

        except Exception as e:

            print("Error al cargar el archivo Excel:", e)

            return

 

        all_diams = sorted([x for x in df["DI√ÅMETRO"].dropna().unique() if x.upper() != "TODOS"])

        diam_widget = widgets.SelectMultiple(

            options=all_diams,

            value=(),

            description="DI√ÅMETRO",

            layout=widgets.Layout(width="50%")

        )

        accordion = widgets.Accordion(children=[])

        accordion_widgets = {}

        def crear_select_multiple_tipo(diam_value):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_tipos = sorted([x for x in subset["TIPO"].dropna().unique() if x.upper() != "TODOS"])

            if not unique_tipos:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay TIPO disponibles. Se usar√° 'TODOS'.")

                return widgets.SelectMultiple(options=[], value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

            else:

                return widgets.SelectMultiple(options=unique_tipos, value=(), description=f"TIPO ({diam_value})", layout=widgets.Layout(width="90%"))

        def crear_dropdown_unico(diam_value, columna, desc):

            subset = df[df["DI√ÅMETRO"] == diam_value]

            unique_vals = sorted([x for x in subset[columna].dropna().unique() if str(x).upper() != "TODOS"])

            if not unique_vals:

                print(f"[Info] Para DI√ÅMETRO '{diam_value}', no hay valores para {columna}. Se usar√° 'TODOS'.")

                return widgets.Dropdown(options=["Seleccionar"], value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

            else:

                return widgets.Dropdown(options=["Seleccionar"] + unique_vals, value="Seleccionar", description=desc, layout=widgets.Layout(width="70%"))

        def update_accordion(*args):

            selected_diams = diam_widget.value

            accordion.children = []

            accordion_widgets.clear()

            if not selected_diams:

                return

            children_list = []

            for diam_value in selected_diams:

                w_tipo = crear_select_multiple_tipo(diam_value)

                w_acero = crear_dropdown_unico(diam_value, "GRADO DE ACERO", "GRADO ACERO")

                w_acero_cup = crear_dropdown_unico(diam_value, "GRADO DE ACERO CUPLA", "ACERO CUPLA")

                w_tipo_cup = crear_dropdown_unico(diam_value, "TIPO DE CUPLA", "TIPO CUPLA")

                box = widgets.VBox([w_tipo, w_acero, w_acero_cup, w_tipo_cup])

                children_list.append(box)

                accordion_widgets[diam_value] = {"tipo": w_tipo, "acero": w_acero, "acero_cup": w_acero_cup, "tipo_cup": w_tipo_cup}

            accordion.children = children_list

            for i, diam_value in enumerate(selected_diams):

                accordion.set_title(i, f"DI√ÅMETRO: {diam_value}")

        diam_widget.observe(update_accordion, names="value")

        update_accordion()

        output_filters = widgets.Output()

        apply_filters_button = widgets.Button(description="Aplicar Filtros", button_style="info")

        def on_apply_filters(b):

            with output_filters:

                clear_output()

                selected_diams = diam_widget.value

                if not selected_diams:

                    selected_diams = ["TODOS"]

                all_filters = {}

                for diam_value in selected_diams:

                    if diam_value == "TODOS":

                        tipo_list = ["TODOS"]

                        acero_list = ["TODOS"]

                        acero_cup_list = ["TODOS"]

                        tipo_cup_list = ["TODOS"]

                    else:

                        w = accordion_widgets[diam_value]

                        tipo_sel = list(w["tipo"].value)

                        if not tipo_sel:

                            tipo_sel = ["TODOS"]

                        else:

                            tipo_sel.append("TODOS")

                        ac = w["acero"].value

                        acero_list = ["TODOS"] if ac == "Seleccionar" else [ac, "TODOS"]

                        ac_cup = w["acero_cup"].value

                        acero_cup_list = ["TODOS"] if ac_cup == "Seleccionar" else [ac_cup, "TODOS"]

                        t_cup = w["tipo_cup"].value

                        tipo_cup_list = ["TODOS"] if t_cup == "Seleccionar" else [t_cup, "TODOS"]

                        all_filters[diam_value] = {"tipo_list": tipo_sel, "acero_list": acero_list, "acero_cup_list": acero_cup_list, "tipo_cup_list": tipo_cup_list}

                # print("=== Filtros recopilados ===")  # Desactivado

                # for diam_value, fdict in all_filters.items():

                #     print(f"DI√ÅMETRO: {diam_value}")

                #     print("   TIPO:", fdict["tipo_list"])

                #     print("   GRADO ACERO:", fdict["acero_list"])

                #     print("   ACERO CUPLA:", fdict["acero_cup_list"])

                #     print("   TIPO CUPLA:", fdict["tipo_cup_list"])

                final_condition = pd.Series([False]*len(df))

                for diam_value, fdict in all_filters.items():

                    temp_cond_diam = pd.Series([False]*len(df))

                    for tipo_val in fdict["tipo_list"]:

                        cond = (df["DI√ÅMETRO"].isin([diam_value, "TODOS"]) &

                                df["TIPO"].isin([tipo_val, "TODOS"]) &

                                df["GRADO DE ACERO"].isin(fdict["acero_list"]) &

                                df["GRADO DE ACERO CUPLA"].isin(fdict["acero_cup_list"]) &

                                df["TIPO DE CUPLA"].isin(fdict["tipo_cup_list"]))

                        temp_cond_diam = temp_cond_diam | cond

                    final_condition = final_condition | temp_cond_diam

                final_df = df[final_condition]

                final_df_renombrado = renombrar_columnas(final_df)

                materiales_finales.append(("FLUJO E", final_df_renombrado))

                # print("Materiales del FLUJO E guardados.")  # Desactivado

                continue_button = widgets.Button(description="Continuar a FLUJO G", button_style="success")

                def on_continue(b):

                    flujo_G()

                continue_button.on_click(on_continue)

                display(continue_button)

        apply_filters_button.on_click(on_apply_filters)

        display(widgets.VBox([diam_widget, accordion, apply_filters_button, output_filters]))

   

    def on_varilla_change(change):

        if change['name'] == 'value':

            if change['new'] == "SI":

                load_excel_and_create_filters()

            elif change['new'] == "NO":

                clear_output()

                # print("Se seleccion√≥ NO en FLUJO E. Saltando a FLUJO F...")  # Desactivado

                flujo_F()

    varilla_widget.observe(on_varilla_change, names="value")

    display(varilla_widget)

 

# ===============================

# FLUJO F: Abandona pozo

# ===============================

def flujo_F():

    clear_output()

    print("FLUJO F: Abandona pozo")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\abandono-recupero.xlsx"

    global df_abandono

    df_abandono = None

    output = widgets.Output()

    question_widget = widgets.Dropdown(

        options=["NO", "SI"],

        value="NO",

        description="¬øAbandono/recupero?:"

    )

    def filter_by_todos(df, column, selected_values):

        if "TODOS" in selected_values:

            return df

        else:

            allowed_values = list(selected_values) + ["TODOS"]

            return df[df[column].isin(allowed_values)]

    def on_question_change(change):

        if change['type'] == 'change' and change['name'] == 'value':

            clear_output()

            display(question_widget, output)

            if change['new'] == "SI":

                with output:

                    # print("Cargando el Excel...")  # (Este print no est√° en la lista a desactivar, se mantiene)

                    if not os.path.exists(file_path):

                        print(f"No se encontr√≥ el archivo:\n{file_path}")

                        return

                    global df_abandono

                    try:

                        df_abandono = pd.read_excel(file_path)

                    except Exception as e:

                        print("Error al cargar el Excel:", e)

                        return

                    print("Archivo cargado exitosamente.")

                df_abandono.columns = df_abandono.columns.str.strip()

                for col in df_abandono.columns:

                    if df_abandono[col].dtype == object:

                        df_abandono[col] = df_abandono[col].astype(str).str.strip()

                if "DI√ÅMETRO" not in df_abandono.columns:

                    with output:

                        print("La columna 'DI√ÅMETRO' no existe en el Excel.")

                    return

                unique_diametros = df_abandono["DI√ÅMETRO"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros:

                    unique_diametros.insert(0, "TODOS")

                else:

                    unique_diametros.remove("TODOS")

                    unique_diametros.insert(0, "TODOS")

                if "DI√ÅMETRO CSG" not in df_abandono.columns:

                    with output:

                        print("La columna 'DI√ÅMETRO CSG' no existe en el Excel.")

                    return

                unique_diametros_csg = df_abandono["DI√ÅMETRO CSG"].dropna().unique().tolist()

                if "TODOS" not in unique_diametros_csg:

                    unique_diametros_csg.insert(0, "TODOS")

                else:

                    unique_diametros_csg.remove("TODOS")

                    unique_diametros_csg.insert(0, "TODOS")

                diametro_multi = widgets.SelectMultiple(

                    options=unique_diametros,

                    value=["TODOS"],

                    description="DI√ÅMETRO:",

                    rows=6

                )

                diametro_csg_single = widgets.Dropdown(

                    options=unique_diametros_csg,

                    value="TODOS",

                    description="DI√ÅM CSG:"

                )

                confirm_button = widgets.Button(

                    description="Confirmar Filtros",

                    button_style="info"

                )

                next_output = widgets.Output()

                def on_confirm_filters(b):

                    with next_output:

                        clear_output()

                        selected_diametros = list(diametro_multi.value)

                        selected_diametro_csg = diametro_csg_single.value

                        filtered_df = df_abandono.copy()

                        filtered_df = filter_by_todos(filtered_df, "DI√ÅMETRO", selected_diametros)

                        filtered_df = filter_by_todos(filtered_df, "DI√ÅMETRO CSG", [selected_diametro_csg])

                        print("Filtrado Aplicado. A continuaci√≥n, ingrese cantidades (solo para celdas vac√≠as).")

                        numeric_widgets = {}

                        diametros_especificos = [d for d in selected_diametros if d != "TODOS"]

                        if diametros_especificos:

                            print("Ingrese la cantidad para cada DI√ÅMETRO seleccionado:")

                            for d in diametros_especificos:

                                numeric_widgets[d] = widgets.BoundedFloatText(

                                    value=0,

                                    min=0,

                                    max=1e9,

                                    step=1,

                                    description=f"{d}:"

                                )

                                display(numeric_widgets[d])

                        else:

                            print("No se seleccionaron di√°metros espec√≠ficos. No se solicitar√°n cantidades.")

                        apply_button = widgets.Button(

                            description="Aplicar Cantidades",

                            button_style="success"

                        )

                        final_output = widgets.Output()

                        def on_apply_quantities(btn):

                            with final_output:

                                clear_output()

                                if "4.CANTIDAD" not in df_abandono.columns:

                                    print("La columna '4.CANTIDAD' no existe en el Excel.")

                                    return

                                df_abandono["4.CANTIDAD"] = pd.to_numeric(df_abandono["4.CANTIDAD"], errors="coerce")

                                for d in diametros_especificos:

                                    qty = numeric_widgets[d].value

                                    mask_diam = (df_abandono["DI√ÅMETRO"] == d)

                                    mask_nan = df_abandono["4.CANTIDAD"].isna()

                                    df_abandono.loc[mask_diam & mask_nan, "4.CANTIDAD"] = qty

                                filtered_final = df_abandono.copy()

                                filtered_final = filter_by_todos(filtered_final, "DI√ÅMETRO", selected_diametros)

                                filtered_final = filter_by_todos(filtered_final, "DI√ÅMETRO CSG", [selected_diametro_csg])

                                print("Listado Final Filtrado:")

                                filtered_final_renombrado = renombrar_columnas(filtered_final)

                                materiales_finales.append(("FLUJO F", filtered_final_renombrado))

                                # print("Materiales del FLUJO F guardados.")  # Desactivado

                                continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

                                def on_continue(b):

                                    flujo_H()

                                continue_button.on_click(on_continue)

                                display(continue_button)

                        apply_button.on_click(on_apply_quantities)

                        display(apply_button, final_output)

                confirm_button.on_click(on_confirm_filters)

                display(diametro_multi, diametro_csg_single, confirm_button, next_output)

            else:

                with output:

                    # print("No se realizar√° la acci√≥n. Saltando a FLUJO H...")  # Desactivado

                    pass

                flujo_H()

    question_widget.observe(on_question_change, names='value')

    display(question_widget, output)

 

 

# ===============================

# FLUJO G: Instalaci√≥n BM

# ===============================

def flujo_G():

    clear_output()

    print("FLUJO G: Instalaci√≥n BM")

    file_path = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\WO.xlsx"

    pregunta_widget = widgets.RadioButtons(

        options=["seleccionar", "SI", "NO"],

        description="¬øWO a BM?",

        value="seleccionar"

    )

    def mostrar_materiales(change):

        clear_output()

        display(pregunta_widget)

        if change['new'] == "SI":

            try:

                df = pd.read_excel(file_path)

                print("Lista de materiales:")

                df_renombrado = renombrar_columnas(df)

                materiales_finales.append(("FLUJO G", df_renombrado))

                # print("Materiales del FLUJO G guardados.")  # Desactivado

            except Exception as e:

                print("Error al cargar Excel:", e)

            continue_button = widgets.Button(description="Continuar a FLUJO H", button_style="success")

            def on_continue(b):

                flujo_H()

            continue_button.on_click(on_continue)

            display(continue_button)

        elif change['new'] == "NO":

            print("No se mostrar√°n los materiales.")

            flujo_H()

    pregunta_widget.observe(mostrar_materiales, names='value')

    display(pregunta_widget)

 

def flujo_H():

    clear_output()

    print("=== FLUJO H: Material de agregaci√≥n ===")

    try:

        file_path_H = r"C:\Users\ry16123\OneDrive - YPF\Escritorio\power BI\GUADAL- POWER BI\Inteligencia Artificial\materiales\GENERAL(1).xlsx"

        df_H = pd.read_excel(file_path_H)

        df_H.columns = df_H.columns.str.strip()

        if "4.CANTIDAD" not in df_H.columns:

            df_H["4.CANTIDAD"] = 0

    except Exception as e:

        print("Error al cargar el Excel:", e)

        df_H = pd.DataFrame()

   

    pregunta_widget_H = widgets.RadioButtons(

        options=["Seleccionar", "SI", "NO"],

        description="¬øAgregar m√°s material?",

        value="Seleccionar"

    )

    output_container_H = widgets.Output()

 

    apply_selection_button_H = widgets.Button(description="Aplicar selecci√≥n", button_style="info")

    apply_qty_button_H = widgets.Button(description="Asignar cantidades", button_style="success")

   

    final_list_button = widgets.Button(description="Mostrar Listado Final de Materiales", button_style="warning")

    final_button_container = widgets.VBox([final_list_button])

   

    def on_show_final_list(b):

        clear_output()

        print("Listado final de materiales de todos los flujos ejecutados:")

        for flow, df in materiales_finales:

            print(f"\n---- {flow} ----")

            display(df)

    final_list_button.on_click(on_show_final_list)

   

    if not df_H.empty and "2. MATERIAL" in df_H.columns:

        materiales = df_H["2. MATERIAL"].astype(str).unique().tolist()

    else:

        materiales = []

    materiales_widget_H = widgets.SelectMultiple(

        options=materiales,

        description="Materiales",

        layout=widgets.Layout(width='50%', height='150px')

    )

    qty_widgets_H = {}

   

    def on_apply_selection_H(b):

        with output_container_H:

            clear_output()

            seleccionados = list(materiales_widget_H.value)

            if not seleccionados:

                print("No se seleccion√≥ ning√∫n material.")

                return

            print("Materiales seleccionados:")

            for mat in seleccionados:

                print("-", mat)

            qty_widgets_H.clear()

            input_boxes = []

            for mat in seleccionados:

                qty_box = widgets.BoundedFloatText(

                    value=0,

                    min=0,

                    step=1,

                    description=f"Cant: {mat}",

                    layout=widgets.Layout(width='50%')

                )

                qty_widgets_H[mat] = qty_box

                input_boxes.append(qty_box)

            display(widgets.VBox(input_boxes))

            display(apply_qty_button_H)

   

    def on_apply_qty_H(b):

        with output_container_H:

            clear_output()

            if df_H.empty:

                print("El DataFrame est√° vac√≠o o no se carg√≥ correctamente.")

                return

            selected_materials = list(qty_widgets_H.keys())

            for mat, widget_box in qty_widgets_H.items():

                cant = widget_box.value

                df_H.loc[df_H["2. MATERIAL"].astype(str) == mat, "4.CANTIDAD"] = cant

            assigned_df = df_H[

                df_H["2. MATERIAL"].astype(str).isin(selected_materials) &

                (df_H["4.CANTIDAD"] > 0)

            ]

            if not assigned_df.empty:

                assigned_df_renombrado = renombrar_columnas(assigned_df)

                materiales_finales.append(("FLUJO H", assigned_df_renombrado))

                # print("Materiales del FLUJO H guardados.")  # Desactivado

            else:

                print("No se asignaron cantidades (o todas fueron 0).")

           

            display(final_button_container)

   

    def on_pregunta_change_H(change):

        with output_container_H:

            clear_output()

            if change['new'] == "SI":

                if df_H.empty:

                    print("El DataFrame no se carg√≥ o est√° vac√≠o.")

                    return

                print("Lista completa de materiales del Excel:\n")

                display(df_H)

                print("\nSeleccione los materiales que desea agregar:")

                display(materiales_widget_H)

                display(apply_selection_button_H)

            elif change['new'] == "NO":

                print("No se agregar√°n m√°s materiales.")

                display(final_button_container)

   

    pregunta_widget_H.observe(on_pregunta_change_H, names='value')

    apply_selection_button_H.on_click(on_apply_selection_H)

    apply_qty_button_H.on_click(on_apply_qty_H)

   

    display(pregunta_widget_H)

    display(output_container_H)

   

    # print("FLUJO H finalizado. Fin del proceso.")  # Desactivado

 

 

# ===============================

# Funci√≥n principal: inicia en FLUJO A

# ===============================

def main():

    flujo_A()

 

# Inicia el proceso

main()
```

## docs/Estructura del proyecto.md

- Characters: 6177
- Tokens: 0

```markdown
üîπ 1. Introducci√≥n
Este documento detalla la arquitectura propuesta para la implementaci√≥n de un sistema de flujos modulares en una aplicaci√≥n basada en Python y Flask. El objetivo es permitir la ejecuci√≥n de m√∫ltiples flujos de trabajo (Flujo A, B, C, etc.), en los cuales cada flujo es un m√≥dulo independiente que recibe entradas del usuario, filtra datos de archivos Excel, y proporciona salidas que pueden afectar a los siguientes flujos.

üîπ 2. An√°lisis Inicial del Problema
El c√≥digo original consist√≠a en una serie de filtros aplicados secuencialmente sobre distintos archivos de datos. Cada flujo:

Preguntaba al usuario si deb√≠a ejecutarse.
Aplicaba filtros a un conjunto de datos en funci√≥n de la respuesta.
Mostraba los materiales resultantes.
Determinaba el siguiente flujo a ejecutar.
üìå Conclusi√≥n: La l√≥gica de cada flujo era principalmente un filtro condicional sobre un conjunto de datos basado en respuestas del usuario.

Problemas detectados en la implementaci√≥n inicial
‚ùå C√≥digo monol√≠tico y dif√≠cil de extender.
‚ùå Falta de modularidad: cada flujo estaba acoplado a la l√≥gica general.
‚ùå No hab√≠a un manejo centralizado del estado y flujo de datos.

üîπ 3. Patr√≥n de Dise√±o Elegido
Se adopt√≥ una arquitectura basada en plugins combinada con un manejo centralizado del flujo utilizando Flask Sessions. Esto permite:

üìå Modularidad: Cada flujo es un plugin independiente que puede a√±adirse sin modificar la estructura general.
üìå Flexibilidad: El orden de ejecuci√≥n se define externamente y no dentro de cada m√≥dulo.
üìå Escalabilidad: Es f√°cil agregar nuevos flujos sin afectar el sistema.
üìå Manejo de Estado: Se utiliza Flask Sessions para almacenar respuestas y materiales seleccionados.
üîπ Patr√≥n de dise√±o:
Plugin-Based Architecture + State Management
Cada flujo act√∫a como un plugin independiente y el sistema maneja las transiciones y datos entre ellos.

üîπ 4. Arquitectura Resultante
üìÇ Estructura del Proyecto

/app
  ‚îú‚îÄ‚îÄ main.py               # Punto de entrada de la aplicaci√≥n
  ‚îú‚îÄ‚îÄ flujo_loader.py       # Carga y gestiona los flujos din√°micamente
  ‚îú‚îÄ‚îÄ plugins/              # M√≥dulos independientes de cada flujo
  ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_a.py        # Flujo A
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_b.py        # Flujo B
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_c.py        # Flujo C
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_d.py        # Flujo D
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_e.py        # Flujo E
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_f.py        # Flujo F
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_g.py        # Flujo G
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo_h.py        # Flujo H (siempre se ejecuta)
  ‚îú‚îÄ‚îÄ templates/            # HTML para la interfaz de usuario
  ‚îÇ   ‚îú‚îÄ‚îÄ base.html
  ‚îÇ   ‚îú‚îÄ‚îÄ index.html
  ‚îÇ   ‚îú‚îÄ‚îÄ flujo.html        # P√°gina gen√©rica para cada flujo
  ‚îÇ   ‚îú‚îÄ‚îÄ resultados.html   # P√°gina de resultados finales
  ‚îú‚îÄ‚îÄ static/               # Archivos CSS y JS
  ‚îú‚îÄ‚îÄ data/                 # Archivos Excel
  ‚îú‚îÄ‚îÄ requirements.txt
  ‚îî‚îÄ‚îÄ README.md
üîπ 5. Manejo del Flujo de Ejecuci√≥n
En lugar de definir el orden de los flujos dentro de cada m√≥dulo, se utiliza un diccionario de transici√≥n que maneja la l√≥gica centralmente.

üìå Configuraci√≥n de flujos en flujo_loader.py


SECUENCIA_FLUJOS = {
    "A": {"SI": "H", "NO": "B"},
    "B": {"SI": "C", "NO": "C"},
    "C": {"SI": "D", "NO": "D"},
    "D": {"SI": "E", "NO": "E"},
    "E": {"SI": "G", "NO": "F"},
    "F": {"SI": "H", "NO": "H"},
    "G": {"SI": "H", "NO": "H"},
    "H": None  # √öltimo flujo
}
üìå C√≥mo funciona:

Cada flujo tiene una entrada (respuesta del usuario).
Se determina el siguiente flujo basado en la respuesta (SI o NO).
Los datos de cada flujo se almacenan en session para ser utilizados en flujos posteriores.
üîπ 6. Ejemplo de Flujo Individual
Cada flujo es un m√≥dulo independiente en la carpeta plugins/.

üìå Ejemplo de plugins/flujo_a.py

python

from flask import render_template, request

nombre = "A"

def ejecutar():
    if request.method == "POST":
        respuesta = request.form.get("respuesta")
        materiales_seleccionados = ["Material X", "Material Y"] if respuesta == "SI" else []
        return respuesta, materiales_seleccionados

    return render_template("flujo.html", flujo=nombre)
üìå Explicaci√≥n:

Cada flujo recibe una entrada (POST del usuario).
Si el usuario responde "SI", filtra materiales y los guarda.
Si el usuario responde "NO", se salta el procesamiento.
El sistema decide cu√°l es el siguiente flujo.
üîπ 7. Manejo del Estado Global
Se utiliza Flask Sessions para mantener los datos entre flujos.

üìå Ejemplo de c√≥mo se almacenan los datos en session

python

@app.route("/flujo/<nombre_flujo>", methods=["GET", "POST"])
def flujo(nombre_flujo):
    if nombre_flujo in flujos:
        respuesta, materiales, siguiente_flujo = ejecutar_flujo(nombre_flujo, session)

        # Guardar en sesi√≥n
        session[nombre_flujo] = {"respuesta": respuesta, "materiales": materiales}

        # Continuar al siguiente flujo o finalizar
        return redirect(url_for("flujo", nombre_flujo=siguiente_flujo)) if siguiente_flujo else redirect(url_for("resultados"))

    return redirect(url_for("index"))
üìå Beneficios del uso de session ‚úî Permite almacenar datos persistentes sin base de datos.
‚úî Mantiene la continuidad entre flujos.
‚úî Hace que cada flujo sea independiente sin necesidad de modificar otros flujos.

üîπ 8. Beneficios de la Arquitectura
Caracter√≠stica	Beneficio
Plugins Modulares	Se pueden agregar nuevos flujos sin modificar main.py.
Configuraci√≥n Centralizada	El orden de ejecuci√≥n se define en flujo_loader.py.
Manejo de Estado con session	Cada flujo puede acceder a respuestas y materiales previos.
Separaci√≥n de Responsabilidades	main.py maneja la app, flujo_loader.py los flujos, y los plugins contienen la l√≥gica espec√≠fica.
Escalabilidad	F√°cil de expandir sin modificar el c√≥digo existente.
üîπ 9. Conclusi√≥n
Se pas√≥ de una estructura monol√≠tica a una arquitectura basada en plugins donde:

Cada flujo es un m√≥dulo aut√≥nomo con entrada y salida.
El flujo de ejecuci√≥n es gestionado din√°micamente.
Se utiliza session para almacenar respuestas y datos.
Los desarrolladores pueden agregar nuevos flujos sin modificar la estructura base.
Este modelo permite escalabilidad, modularidad y facilidad de mantenimiento, aline√°ndose con buenas pr√°cticas de arquitectura de software.
```

## README.md

- Characters: 1664
- Tokens: 0

````markdown
# Visualizador de Excel

Esta aplicaci√≥n simple permite visualizar archivos Excel como tablas HTML en un navegador web.

## Requisitos

- Python 3.6 o superior
- pip (gestor de paquetes de Python)


# Configuraci√≥n y ejecuci√≥n en VS Code (Windows)
Requisitos previos

Python 3.6 o superior
pip (gestor de paquetes de Python)

Pasos para ejecutar la aplicaci√≥n
1. Clonar el repositorio

```
git clone [URL_DEL_REPOSITORIO]
cd mi_app
```
2. Crear y activar un entorno virtual

 Crear entorno virtual
```
python -m venv venv
```

# Activar el entorno virtual

```
venv\Scripts\activate
```

4. Preparar los archivos Excel

Coloca tus archivos Excel (.xlsx o .xls) en la carpeta app/data/
Si la carpeta no existe, se crear√° autom√°ticamente al iniciar la aplicaci√≥n


#### 5. Iniciar la aplicaci√≥n
```
python app/main.py
```

#### 6. Acceder a la aplicaci√≥n

en el navegador
```
 http://127.0.0.1:5000
```
Se veran todos los archivos Excel cargados y podr√°s iniciar los flujos de trabajo

7. Desactivar el entorno virtual cuando termines
Copydeactivate
Soluci√≥n de problemas comunes

Error "No module named...": Verifica que el entorno virtual est√© activado y que todas las dependencias est√©n instaladas
Archivos Excel no visibles: Aseg√∫rate de que est√©n en la carpeta correcta (app/data/) y tengan la extensi√≥n correcta (.xlsx o .xls)

3. Abre tu navegador y ve a `http://localhost:5000`

## Notas

- La aplicaci√≥n mostrar√° todos los archivos Excel (.xlsx o .xls) encontrados en la carpeta `data`
- Cada archivo se convertir√° en una tabla HTML
- Puedes recargar la p√°gina para actualizar los datos si agregas nuevos archivos Excel mientras la aplicaci√≥n est√° corriendo
````

## .gitignore

- Characters: 45
- Tokens: 0

```text
venv/
env/
__pycache__/
*.pyc
*.pyo
.DS_Store
```

## Statistics

- Total Files: 22
- Total Characters: 298276
- Total Tokens: 0
